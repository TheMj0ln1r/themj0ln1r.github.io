<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Hacked Labs x Osec CTF 2023
        
    </title><meta content="Hacked Labs x Osec CTF 2023" property=og:title><meta content="Known as TheMj0ln1r" property=og:description><meta content="Known as TheMj0ln1r" name=description><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://themj0ln1r.github.io/fonts.css rel=stylesheet><script src=https://themj0ln1r.github.io/js/codeblock.js></script><script src=https://themj0ln1r.github.io/js/toc.js></script><script src=https://themj0ln1r.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Charan Nomula" href=https://themj0ln1r.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://themj0ln1r.github.io/theme/light.css rel=stylesheet><link href=https://themj0ln1r.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://themj0ln1r.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://themj0ln1r.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://themj0ln1r.github.io/>Charan Nomula</a><div class=socials><a class=social href=https://x.com/TheMj0ln1r/ rel=me target=_blank> <img alt=twitter src=https://themj0ln1r.github.io/social_icons/twitter.svg> </a><a class=social href=https://linkedin.com/in/mj0ln1r/ rel=me target=_blank> <img alt=linkedin src=https://themj0ln1r.github.io/social_icons/linkedin.svg> </a><a class=social href=https://github.com/TheMj0ln1r/ rel=me target=_blank> <img alt=github src=https://themj0ln1r.github.io/social_icons/github.svg> </a><a href="mailto: playermj0ln1r@gmail.com" class=social rel=me target=_blank> <img alt=Email src=https://themj0ln1r.github.io/social_icons/email.svg> </a></div></div><nav><a href=https://themj0ln1r.github.io/posts style=margin-left:.5em>/posts</a><a href=https://themj0ln1r.github.io/writeups style=margin-left:.5em>/writeups</a><a href=https://themj0ln1r.github.io/projects style=margin-left:.5em>/projects</a><a href=https://themj0ln1r.github.io/contact style=margin-left:.5em>/contact</a><a href=https://themj0ln1r.github.io/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://themj0ln1r.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://themj0ln1r.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Hacked Labs x Osec CTF 2023<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2023-10-02</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://themj0ln1r.github.io/tags/ctf/>ctf</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/blockchain/>blockchain</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://themj0ln1r.github.io/writeups/hackedlabsctf/#babyotter>BabyOtter</a><li><a href=https://themj0ln1r.github.io/writeups/hackedlabsctf/#childotter>ChildOtter</a> <ul><li><a href=https://themj0ln1r.github.io/writeups/hackedlabsctf/#references>References</a></ul></ul></div><section class=body><p>Hello peers, I participated in a blockchain ctf conducted by 0xHacked Labs and OtterSec. These are the challenge writeups which i solved. We dont submit any flag to solve the challenge, we need to generate the ZK Proof of our exploit then that ZK Proof should be submitted to solve the challenge.<h1 id=babyotter><a aria-label="Anchor link for: babyotter" class=zola-anchor href=#babyotter>BabyOtter</a></h1><pre style=color:#61676c;background-color:#fafafa><code><span>As easy as 1, 2, 1337..
</span><span>
</span><span>rpc: http://18.207.142.64:38545
</span><span>contract: 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3
</span><span>block_number: 3
</span><span>
</span><span>Attached Files : [ https://github.com/0xHackedLabs/ctf/tree/main/src/BabyOtter/BabyOtter.sol ]
</span></code></pre><p><code>BabyOtter.sol</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>contract BabyOtter {
</span><span>    bool public solved = false;
</span><span>
</span><span>    function solve(uint x) public {
</span><span>        unchecked {
</span><span>            assert(x * 0x1337 == 1);
</span><span>        }
</span><span>        solved = true;
</span><span>    }
</span><span>}
</span></code></pre><p>The observation is that the contract uses <code>unchecked</code> block. unchecked block wont check for overflow of integer arithmetic. That means a <code>uint256</code> variable can store values less than <code>2**256-1</code>. If we tried to store values more than this value the value will be wrapped to mod <code>2**256</code>.<p>Simply, <code>uint256 x = 2**256 + 1</code> will become <code>0</code>. <code>uint256 x = 2**256 + 2</code> will be <code>1</code>.<p>So, we need to find value of <code>x</code> such that which can satisfy the equation <code>x * 0x1337 = 1</code>. We can think of this as a modular multiplicative inverse.<p><code>x = pow(0x1337, -1, 2**256)</code><p>In solidity we can find this as <code>x  =  0x1337 ** (2**254 -1)</code>. So, simply calling solve function with this value with the x value to solve the chalenge.<p><code>Exploit.sol</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>interface IBabyOtter {
</span><span>    function solve(uint x) external;
</span><span>}
</span><span>contract Exploit {
</span><span>    function exploit() public {
</span><span>        // write code here
</span><span>        address target = 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3;
</span><span>        uint leet = 0x1337;
</span><span>        uint x;
</span><span>        unchecked{x  =  leet ** (2**254 -1);}
</span><span>        IBabyOtter(target).solve(x);
</span><span>    }
</span><span>}
</span></code></pre><p>We can test this challenge with foundry test script.<p><code>Exploit.t.sol</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>import {Exploit as BoE} from "../src/BabyOtter/Exploit.sol";
</span><span>interface IChallenge {
</span><span>    function solved() external returns(bool);
</span><span>}
</span><span>
</span><span>contract ExploitTest is Test {
</span><span>
</span><span>    function setUp() public {
</span><span>        // fork the ctf chain
</span><span>        vm.createSelectFork("http://18.207.142.64:38545", 3);
</span><span>    }
</span><span>
</span><span>    function test_babyotter() public {
</span><span>        address target = 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3;
</span><span>
</span><span>        BoE exp = new BoE();
</span><span>        exp.exploit();
</span><span>        assertTrue(IChallenge(target).solved());
</span><span>    }
</span><span>}
</span></code></pre><p><code>forge test --match-test test_babyotter -vv</code> will confirm the challenge is solved. Submitting the exploit ZK Proof will credit some points in CTF.<h1 id=childotter><a aria-label="Anchor link for: childotter" class=zola-anchor href=#childotter>ChildOtter</a></h1><pre style=color:#61676c;background-color:#fafafa><code><span>rpc: http://18.207.142.64:38545
</span><span>contract: 0x63461D5b5b83bD9BA102fF21d8533b3aad172116
</span><span>block_number: 3
</span><span>
</span><span>Attached Files : [ https://github.com/0xHackedLabs/ctf/tree/main/src/ChildOtter/ChildOtter.sol ]
</span></code></pre><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>contract ChildOtter {
</span><span>    mapping(uint => mapping(uint => uint)) val;
</span><span>    bool public solved = false;
</span><span>
</span><span>    function solve(uint x) public { 
</span><span>      uint target;
</span><span>
</span><span>      val[0][0] = x;
</span><span>      assembly {
</span><span>        target := mload(32)
</span><span>      }
</span><span>      assert(target == x);
</span><span>      solved = true;
</span><span>    }
</span><span>}
</span></code></pre><p>This is the challenge for which I learned a lot of new things. To solve this I revised entire EVM internals from many sources(see references).<p>The challenge goal is to call the solve function with the value which is store at the EVM memory 32 bytes to 64 bytes. That is what actually <code>mload(32)</code> is doing.<p>Solidity reserves four 32-byte slots, with specific byte ranges (inclusive of endpoints) being used as follows:<p><code>0x00 - 0x3f</code> (64 bytes): scratch space for hashing methods<p><code>0x40 - 0x5f</code> (32 bytes): currently allocated memory size (aka. free memory pointer)<p><code>0x60 - 0x7f</code> (32 bytes): zero slot<p>Scratch space can be used between statements (i.e. within inline assembly). The zero slot is used as initial value for dynamic memory arrays and should never be written to (the free memory pointer points to 0x80 initially).<p>The challenge contract defines a nested mapping and stored a value in the mapping at <code>key [0][0]</code>.<p>The variable <code>val</code> is assigned to storage slot 0 (simply because it is the first one). But the mapped elements are elsewhere.<p>To compute the storage slot or location of the mapped elements, the following is used :<p><code>slot = keccak256([key, mappingSlot]) // concatenate key and mapping slot</code><p>So, when storing values in a mapping EVM will compute keccak256 hash of the key and mapping slot. EVM will use <code>scratch space</code> to perform hashing. So, that means <code>0x00-0x3f</code>(0 - 64 bytes) will store the <code>keccak256([0,0])</code>.<p>The actual <code>value[0][0] = x</code> will be stored at <code>storage</code> slot <code>uint(keccak256([0,keccak256([0,0]))))</code>. In memory from <code>32 bytes to 64 bytes</code> are used to store the <code>keccak256([0,0])</code>.<p>Lets confirm this with remix debugger.</p><img alt="childOtter remix" class=autoimg src=/assets/img/ctf_img/hackedlabs23/hackedlabsctf_1.png><p>Calling solve function with this value will solve the challenge.<p><code>Exploit.sol</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>interface IChildOtter {
</span><span>    function solve(uint x) external;
</span><span>}
</span><span>contract Exploit {
</span><span>    function exploit() public {
</span><span>        // write code here
</span><span>        address target = 0x63461D5b5b83bD9BA102fF21d8533b3aad172116;
</span><span>        uint x = uint(keccak256(abi.encode(0,0))); // slot 0, key 0
</span><span>        IChildOtter(target).solve(x);
</span><span>    }
</span><span>}
</span></code></pre><p>We can test this challenge with foundry test script.<p><code>Exploit.t.sol</code><pre class=language-solidity data-lang=solidity style=color:#61676c;background-color:#fafafa><code class=language-solidity data-lang=solidity><span>// SPDX-License-Identifier: UNLICENSED
</span><span>pragma solidity ^0.8.13;
</span><span>
</span><span>import {Exploit as CoE} from "../src/ChildOtter/Exploit.sol";
</span><span>interface IChallenge {
</span><span>    function solved() external returns(bool);
</span><span>}
</span><span>
</span><span>contract ExploitTest is Test {
</span><span>
</span><span>    function setUp() public {
</span><span>        // fork the ctf chain
</span><span>        vm.createSelectFork("http://18.207.142.64:38545", 3);
</span><span>    }
</span><span>
</span><span>    function test_childotter() public {
</span><span>        address target = 0x63461D5b5b83bD9BA102fF21d8533b3aad172116;
</span><span>        CoE exp = new CoE();
</span><span>        exp.exploit();
</span><span>        assertTrue(IChallenge(target).solved());
</span><span>    }
</span><span>}
</span></code></pre><p><code>forge test --match-test test_childotter -vv</code> will confirm the challenge is solved. Submitting the exploit ZK Proof will credit some points in CTF.<hr><h3 id=references><a aria-label="Anchor link for: references" class=zola-anchor href=#references>References</a></h3><ol><li><a href=https://ethereum.stackexchange.com/questions/114186/how-does-ethereum-fit-a-mapping-into-storage target=_blank>StackOverflow</a><li><a href=https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html target=_blank>Solidity lang docs</a><li><a href="https://youtu.be/i_LwhlFNSkI?feature=shared" target=_blank>How mappings stored in EVM - MappingsJesper Kristensen YT</a><li><a href="https://youtu.be/Ru3inmu1FuQ?feature=shared" target=_blank>EVM Explained - Owen Thurm YT</a><li><a href="https://youtu.be/kCswGz9naZg?feature=shared" target=_blank>EVM Guide - Jordan McKinney YT</a></ol></section></article></main></div>