<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Token Sale
        
    </title><meta content="Token Sale" property=og:title><meta content="Token Sale smart contract" property=og:description><meta content="Token Sale smart contract" name=description><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://themj0ln1r.github.io/fonts.css rel=stylesheet><script src=https://themj0ln1r.github.io/js/codeblock.js></script><script src=https://themj0ln1r.github.io/js/toc.js></script><script src=https://themj0ln1r.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Charan Nomula" href=https://themj0ln1r.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://themj0ln1r.github.io/theme/light.css rel=stylesheet><link href=https://themj0ln1r.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://themj0ln1r.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://themj0ln1r.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://themj0ln1r.github.io/>Charan Nomula</a><div class=socials><a class=social href=https://x.com/TheMj0ln1r/ rel=me target=_blank> <img alt=twitter src=https://themj0ln1r.github.io/social_icons/twitter.svg> </a><a class=social href=https://linkedin.com/in/mj0ln1r/ rel=me target=_blank> <img alt=linkedin src=https://themj0ln1r.github.io/social_icons/linkedin.svg> </a><a class=social href=https://github.com/TheMj0ln1r/ rel=me target=_blank> <img alt=github src=https://themj0ln1r.github.io/social_icons/github.svg> </a><a href="mailto: playermj0ln1r@gmail.com" class=social rel=me target=_blank> <img alt=Email src=https://themj0ln1r.github.io/social_icons/email.svg> </a></div></div><nav><a href=https://themj0ln1r.github.io/posts style=margin-left:.5em>/posts</a><a href=https://themj0ln1r.github.io/writeups style=margin-left:.5em>/writeups</a><a href=https://themj0ln1r.github.io/projects style=margin-left:.5em>/projects</a><a href=https://themj0ln1r.github.io/contact style=margin-left:.5em>/contact</a><a href=https://themj0ln1r.github.io/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://themj0ln1r.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://themj0ln1r.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Token Sale<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-01-23</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://themj0ln1r.github.io/tags/web3/>web3</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/defi/>defi</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#token-pre-sale-public-sale>Token Pre-Sale & Public Sale</a> <ul><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#documentation>Documentation</a></li><ul><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#features>Features</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#design-choices>Design Choices</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#security-considerations>Security Considerations</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#test-cases>Test Cases</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#usage>Usage</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#test>Test</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#gas-snapshots>Gas Snapshots</a><li><a href=https://themj0ln1r.github.io/projects/tokensaleproject/#deploy>Deploy</a></ul></ul></ul></div><section class=body><p>A simple Token Pre Sale and Public Sale Project developed by me for an internship task.<p>Project Repo : <a href=https://github.com/TheMj0ln1r/Token-Sale-Project target=_blank>Token Sale Project</a><hr><h1 id=token-pre-sale-public-sale><strong>Token Pre-Sale & Public Sale</strong></h1><p><strong>Token Sale is a fundraising mechanism used by blockchain projects to distribute and sell their native tokens to the public.</strong><h2 id=documentation>Documentation</h2><h3 id=features>Features</h3><p>This Token sale project has the following features :<p><strong>Presale:</strong><ul><li><p>Users can contribute Ether to the presale and receive project tokens in return.</p><li><p>The presale has a maximum cap on the total Ether that can be raised.</p><li><p>The presale has a minimum and maximum contribution limit per participant.</p><li><p>Tokens are distributed immediately upon contribution.</p></ul><p><strong>Public Sale:</strong><ul><li><p>After the presale ends, the public sale begins.</p><li><p>Users can contribute Ether to the public sale and receive project tokens in return.</p><li><p>The public sale has a maximum cap on the total Ether that can be raised.</p><li><p>The public sale has a minimum and maximum contribution limit per participant.</p><li><p>Tokens are distributed immediately upon contribution.</p></ul><p><strong>Token Distribution:</strong><ul><li>The smart contract should have a function to distribute project tokens to a specified address. This function can only be called by the owner of the contract.</ul><p><strong>Refund:</strong><ul><li>If the minimum cap for either the presale or public sale is not reached, contributors should be able to claim a refund.</ul><p><strong>Emergency Withdraw:</strong><ul><li>If there was any emergency situation that owner has to withdraw all the funds from contract. This can be done with the Emergency withdraw function.</ul><h3 id=design-choices>Design Choices</h3><p><strong>Inheritance and Libraries:</strong><ul><li>The contract inherits from the <code>Ownable</code>, <code>SafeERC20</code> contracts, which are part of the OpenZeppelin library. This ensures that only the owner of the contract has certain privileges and safely interact with ERC-20 tokens.</ul><p><strong>State Variables:</strong><ul><li><p>The contract has various state variables to manage the token sale parameters, such as minimum and maximum caps for both presale and public sale, contribution limits, durations, start times, and amounts raised.</p><li><p>Separate variables are used to track contributions for presale and public sale, and mappings are used to associate contributions with specific addresses.</p></ul><p><strong>Events:</strong><ul><li>The contract emits events to log important changes and actions, making it easier for external systems to track and respond to contract events.</ul><p><strong>Modifiers:</strong><ul><li>Modifiers are used to ensure that certain conditions are met before executing functions. For example, isValidCapacities ensures that the minimum and maximum values are valid, and isValidDuration ensures that the sale duration is greater than zero.</ul><p><strong>Constructor:</strong><ul><li>The constructor initializes the contract with the address of the ERC-20 token being sold. If the provided token address is zero, an error is triggered.</ul><p><strong>Presale and Public Sale Functions:</strong><ul><li><p>Separate functions are implemented to start the presale and public sale, each with parameters such as maximum and minimum caps, duration, and contribution limits. These functions can only be called by the owner.</p><li><p>The functions perform checks to ensure that the presale and public sale are not already active, and that the presale has occurred before starting the public sale.</p></ul><p><strong>Token Purchase Functions:</strong><ul><li>Functions like buyTokensInPresale and buyTokensInPublicsale allow participants to buy tokens during the presale and public sale, respectively. Checks are in place to ensure the sale is active, contribution limits are adhered to, and the minimum and maximum caps are not exceeded.</ul><p><strong>Refund Function:</strong><ul><li>The claimRefund function allows participants to claim a refund if the minimum cap for the presale or public sale is not reached. Refunds are only possible after the respective sale has ended.</ul><p><strong>Secure Value Transfer:</strong><ul><li>The contract includes a secure internal function (sendValue) to transfer Ether to an address. It checks the contract's balance and ensures that the transfer is successful.</ul><p><strong>Setters and Getters:</strong><ul><li>Various setter functions allow the owner to change parameters such as capacities, durations, and contribution limits. Getter functions are provided to check the status of the presale and public sale.</ul><p><strong>Emergency Withdraw Function:</strong><ul><li>An emergency withdrawal function (withdraw) is implemented, allowing the owner to withdraw any remaining tokens and Ether from the contract.</ul><p><strong>Fallback Function:</strong><ul><li>The contract includes a fallback function that emits an event when it receives Ether when an unexpected ether was sennt to this contract.</ul><h3 id=security-considerations>Security Considerations</h3><p><strong>Inheritance from OpenZeppelin Contracts:</strong> The contract uses OpenZeppelin's <code>Ownable</code> and <code>SafeERC20</code> contracts, which are well-tested and widely accepted in the Ethereum community for managing ownership and safe token transfers, respectively.<p><code>Access Control:</code> The <code>onlyOwner</code> modifier from the <code>Ownable</code> contract is used throughout the TokenSale contract to restrict certain sensitive functions to be executed only by the contract owner.<p><strong>Use of SafeERC20:</strong> The contract uses the <code>SafeERC20</code> library for safe token interactions, which helps prevent issues related to token transfers, such as <code>reentrancy</code> and token transfer edge cases.<p><strong>Custom Errors:</strong> The contract defines custom errors for various failure conditions, making it easier to understand why transactions fail and saving gas compared to traditional <code>require</code> statements with error messages. <code>solidity     error TokenSale_Invalid_Max_Min();     error TokenSale_Invalid_Sale_Duration();     error TokenSale_Invalid_Token();     error TokenSale_Presale_Already_Active();     error TokenSale_Presale_Not_Started();     error TokenSale_Contribution_Limit_Passed();     error TokenSale_Not_Enough_Contribution();     error TokenSale_Presale_Max_Cap_Passed();     error TokenSale_Insufficient_Token_Balance();     error TokenSale_Publicsale_Not_Started();     error TokenSale_Publicsale_Max_Cap_Passed();     error TokenSale_Publicsale_Already_Active();     error TokenSale_Invalid_To_Address();     error TokenSale_Sale_Min_Cap_Reached();     error TokenSale_InsufficientBalance(address);     error TokenSale_Refund_Tx_Failed();     error TokenSale_Not_Contributed();     error TokenSale_Owner_Cant_Buy();     </code><p><strong>Input Validation:</strong> The contract includes input validation using modifiers such as <code>isValidCapacities</code> and <code>isValidDuration</code> to ensure that the parameters for presale and public sale are within logical and acceptable ranges.<p><strong>State Checks:</strong> Functions like <code>buyTokensInPresale</code> and <code>buyTokensInPublicsale</code> check the state of the sale using conditions to ensure that tokens can only be bought when the sales are active and not otherwise.<p><strong>Contribution Tracking:</strong> The contract tracks contributions in mappings, allowing for individual refund logic and ensuring that contributions can be returned if certain conditions (like not reaching the minimum cap) are met.<p><strong>Refund Logic:</strong> The contract provides a claimRefund function that allows users to claim refunds after the presale or public sale ends if the minimum cap is not reached, with checks to prevent refunds while the sale is active.<p><strong>Emergency Withdrawal:</strong> The <code>withdraw</code> function allows the contract owner to withdraw all funds and tokens from the contract in case of emergency, using the <code>onlyOwner</code> modifier for access control.<p><strong>Visibility and State Mutability Restrictions:</strong> The contract uses appropriate visibility (public, internal, etc.) and state mutability (view, payable, etc.) specifiers to restrict access and modifications to functions and state variables.<p><strong>Event Emission:</strong> The contract emits events for significant actions like starting sales, token purchases, and refunds, which helps in tracking contract activity and debugging.<pre style=color:#61676c;background-color:#fafafa><code><span>```solidity
</span><span>event TokenSale_PreSale_Contribution_Limits_Changed(uint indexed min, uint indexed max);
</span><span>event TokenSale_PublicSale_Contribution_Limits_Changed(uint indexed min, uint indexed max);
</span><span>event TokenSale_Thanks_For_Donation(address indexed sender);
</span><span>event TokenSale_Pre_Sale_Started(uint);
</span><span>event TokenSale_Public_Sale_Started(uint);
</span><span>event TokenSale_Tokens_Sent_In_Presale(address indexed receiver, uint indexed amount);
</span><span>event TokenSale_Tokens_Sent_In_Publicsale(address indexed receiver, uint indexed amount);
</span><span>event Token_Presale_Refund_Success(address indexed receiver, uint);
</span><span>event Token_Publicsale_Refund_Success(address indexed receiver, uint);
</span><span>event TokenSale_Emergency_Withdraw(address indexed owner);
</span><span>event TokenSale_PublicSale_Cap_Set(uint min, uint max);
</span><span>event TokenSale_PreSale_Cap_Set(uint min, uint max);
</span><span>```
</span></code></pre><p><strong>Time-Based Logic:</strong> The contract uses block timestamps to manage the durations of the presale and public sale, ensuring that they only last for the intended period.<p><strong>Receive Function:</strong> A <code>receive</code> function is included to handle plain unexpected Ether transfers to the contract.<h3 id=test-cases>Test Cases</h3><ol><li><p><strong>setUp:</strong> Initializes the testing environment by deploying the EliteToken and TokenSale contracts and transferring some tokens to the TokenSale contract.</p><li><p><strong>testTokenBalance:</strong> Confirms that the TokenSale contract received the correct number of tokens and that the remaining balance is with the test contract (the owner).</p><li><p><strong>testInitialization:</strong> Validates that the TokenSale contract's owner is set correctly.</p><li><p><strong>testSetPresaleCapacity:</strong> Checks that the presale capacity (minimum and maximum caps) can be set correctly.</p><li><p><strong>testSetPresaleCapacityNotOwner:</strong> Ensures that only the owner can set the presale capacity by expecting a revert when a non-owner account attempts to set it.</p><li><p><strong>testSetPresaleCapacityInvalidParams:</strong> Tests various invalid parameters for setting the presale capacity to confirm that the contract correctly reverts these transactions.</p><li><p><strong>testSetPublicsaleCapacity:</strong> Similar to testSetPresaleCapacity, but for the public sale capacity.</p><li><p><strong>testSetPublicsaleCapacityNotOwner:</strong> Similar to testSetPresaleCapacityNotOwner, but for the public sale capacity.</p><li><p><strong>testSetPublicsaleCapacityInvalidParams:</strong> Similar to testSetPresaleCapacityInvalidParams, but for the public sale capacity.</p><li><p><strong>testSetPresaleDuration:</strong> Checks that the presale duration can be set correctly.</p><li><p><strong>testSetPresaleDurationNotOwner:</strong> Ensures that only the owner can set the presale duration.</p><li><p><strong>testSetPresaleDurationInvalidDuration:</strong> Tests that setting an invalid presale duration results in a revert.</p><li><p><strong>testStartPresaleInvalidContribution:</strong> This test checks that the startPreSale function reverts when called with invalid contribution limits. It validates that contributions cannot be zero, and the minimum contribution cannot be higher than the maximum contribution.</p><li><p><strong>testStartPresaleAgain:</strong> This test ensures that attempting to start a new presale while one is already active should fail. It tests that the contract prevents overlapping presales.</p><li><p><strong>testStartPresaleAgainAfterEnd:</strong> This test checks that a new presale can be started after the previous one has ended. It uses vm.warp to simulate time passing and ensures that starting a new presale is allowed only after the previous one has concluded.</p><li><p><strong>testStartPublicsale:</strong> This test verifies that the public sale can start correctly after the presale has ended. It simulates the end of the presale by advancing the block timestamp and then starts the public sale.</p><li><p><strong>testStartPublicsaleNotOwner:</strong> This test confirms that only the owner can start the public sale. It uses vm.prank to simulate a non-owner account attempting to start the sale, expecting the transaction to revert.</p><li><p><strong>testStartPublicsalePresaleRunning:</strong> This test ensures that the public sale cannot start if the presale is still active, expecting the relevant error to be thrown if this rule is violated.</p><li><p><strong>testStartPublicsalePresaleNotStarted:</strong> This test checks that the public sale cannot start if the presale has not been initialized, expecting a revert with the appropriate error.</p><li><p><strong>testStartPublicsaleAgain:</strong> This test verifies that once the public sale has started, attempting to start it again should fail to prevent duplicate sales.</p><li><p><strong>testStartPublicsaleAgainAfterEnd:</strong> This test checks that a new public sale can start after the previous one has ended, similar to the presale tests.</p><li><p><strong>testStartPublicsaleInvalidCap:</strong> This test is similar to testStartPresaleInvalidContribution, but for the public sale. It checks for reverts when invalid presale caps are provided.</p><li><p><strong>testStartPublicsaleInvalidDuration:</strong> This test checks that the public sale cannot be started with a duration of zero, expecting a revert with the appropriate error.</p><li><p><strong>testStartPublicsaleInvalidContribution:</strong> This test is similar to testStartPresaleInvalidContribution, but it checks the public sale's contribution limits for validity.</p><li><p><strong>testBuyTokensInPresale:</strong> This test verifies that tokens can be purchased in the presale. It uses hoax to simulate an account with Ether and checks the token and Ether balances after the purchase.</p><li><p><strong>testBuyTokensInPresaleMaxContribute:</strong> This test checks that an account cannot exceed the maximum contribution limit during the presale by making multiple purchases.</p><li><p><strong>testBuyTokensInPresaleAfterSomeTime:</strong> This test ensures that contributions can still be made after some time has passed in the presale, using <code>vm.warp</code> to simulate the passage of time.</p><li><p><strong>testBuyTokensInPresaleContributeLimits:</strong> This test checks that the presale contribution limits are enforced, expecting reverts if the contribution is too high or too low.</p><li><p><strong>testBuyTokensInPresaleNotStarted:</strong> This test ensures that attempting to buy tokens before the presale has started should fail.</p><li><p><strong>testBuyTokensInPresaleOver:</strong> This test confirms that once the presale is over, no more tokens can be purchased, simulating the end of the presale with <code>vm.warp</code>.</p><li><p><strong>testBuyTokensInPresaleCapLimits:</strong> This test verifies that the presale respects the maximum cap set for the sale. It simulates three different buyers trying to purchase tokens during the presale, with the third purchase exceeding the presale cap and expecting a revert.</p><li><p><strong>testBuyTokensInPresaleInsufficientBal</strong>: This test checks that the TokenSale contract cannot sell more tokens than it holds. It sets up a scenario where the contract has only a small number of tokens and attempts to sell more than that amount, expecting the transaction to revert due to insufficient token balance.</p><li><p><strong>testBuyTokensInPresaleWhileAndAfterPublicSale:</strong> This test ensures that once the public sale has started, and after it has ended, no purchases can be made through the presale function. It does this by starting the presale, then the public sale, and then trying to make a presale purchase, which should fail.</p><li><p><strong>testBuyTokensInPublicsale</strong>: This function tests the basic functionality of buying tokens during the public sale. It starts with the presale, advances time to allow the public sale to start, and then simulates a purchase of tokens during the public sale.</p><li><p><strong>testBuyTokensInPublicsaleMaxContribute:</strong> Similar to the presale test, this test checks that an individual cannot exceed the maximum contribution limit during the public sale, even with multiple purchases.</p><li><p><strong>testBuyTokensInPublicsaleContributeLimits:</strong> This test ensures that the public sale enforces both minimum and maximum contribution limits, expecting transactions that fall outside these limits to revert.</p><li><p><strong>testBuyTokensInPublicsaleNotStarted:</strong> This test ensures that the public sale function cannot be used before the public sale has officially started, expecting the transaction to revert if attempted.</p><li><p><strong>testBuyTokensInPublicsaleOver:</strong> This test verifies that no purchases can be made through the public sale function once the public sale has ended.</p><li><p><strong>testBuyTokensInPublicsaleCapLimits:</strong> This test is similar to testBuyTokensInPresaleCapLimits, but for the public sale. It ensures that the public sale respects its maximum cap and that attempts to buy beyond this cap will fail.</p><li><p><strong>testBuyTokensInPublicsaleInsufficientBal:</strong> This test, akin to testBuyTokensInPresaleInsufficientBal, checks that the TokenSale contract cannot sell more tokens than it possesses during the public sale.</p><li><p><strong>testBuyTokensInPrePublicsales:</strong> This test checks the scenario where an investor buys tokens during the presale and then again during the public sale, verifying the token balances after each purchase and ensuring that no purchases can be made once the public sale is over.</p><li><p><strong>testsendTokensTo:</strong> This function tests the sendTokensTo functionality of the contract, which is likely a way to distribute tokens to a specific address. It ensures that only authorized accounts (presumably the contract owner) can call this function.</p><li><p><strong>testReceive:</strong> This test seems to check the behavior of the contract when it receives a plain Ether transfer, which might trigger a fallback function designed to handle such transactions. It expects a specific event to be emitted, acknowledging the receipt of the donation.</p><li><p><strong>testIsPresaleActive:</strong> This test checks the isPresaleActive function of the TokenSale contract. It starts the presale and asserts that isPresaleActive returns true. Then it warps the blockchain time by one day and checks that isPresaleActive returns false, indicating the presale has ended.</p><li><p><strong>testIsPublicsaleActive:</strong> This test verifies the isPublicsaleActive function. It starts the presale, then warps time by one day to start the public sale. It checks that isPresaleActive returns false and isPublicsaleActive returns true. After warping time by an additional two days, it asserts that isPublicsaleActive returns false, indicating the public sale has ended.</p><li><p><strong>testIsPublicsaleHappened:</strong> This test checks if the isPresaleHappened function correctly tracks whether the presale has occurred. Initially, it asserts the function returns false. After starting the presale and warping time by three days, it asserts the function returns true.</p><li><p><strong>testClaimRefundPresale:</strong> This test ensures that participants can claim refunds after the presale ends. It starts the presale, has an account buy tokens, then warps time by one day and calls claimRefund. It checks that the account's balance is refunded.</p><li><p><strong>testClaimRefundPresaleNotEnd:</strong> This test confirms that trying to claim a refund while the presale is still active should fail and cause a revert with the appropriate error.</p><li><p><strong>testClaimRefundPublicsale:</strong> Similar to the presale refund test, this checks that participants can claim refunds after the public sale ends. It starts the presale, starts the public sale after one day, has an account buy tokens, warps time by two days, and then calls claimRefund, checking for a refund.</p><li><p><strong>testClaimRefundPrePublicsalesNotEnd:</strong> This test verifies that attempting to claim a refund from the public sale while it's still active should fail, resulting in a revert with the appropriate error.</p><li><p><strong>testClaimRefundPrePublicsalesMinCapReached:</strong> This test ensures that if the minimum cap of the sale is reached, participants cannot claim refunds, expecting a revert with the appropriate error.</p><li><p><strong>testWithdraw:</strong> This test checks the withdraw function of the TokenSale contract. It expects an event to be emitted indicating an emergency withdrawal and confirms that only authorized accounts can call this function, expecting a revert for unauthorized accounts.</p><li><p>**testDeployScript:**This test ensures that the deployment script works correctly. It deploys the contracts using the DeployScript and checks that the token and sale contract addresses are non-zero and that the sale contract has the correct token balance.</p></ol><p>And 10 more tests....<h3 id=usage>Usage</h3><pre class=language-shell data-lang=shell style=color:#61676c;background-color:#fafafa><code class=language-shell data-lang=shell><span>$ forge build
</span></code></pre><h3 id=test>Test</h3><pre class=language-shell data-lang=shell style=color:#61676c;background-color:#fafafa><code class=language-shell data-lang=shell><span>$ forge test
</span></code></pre><h3 id=gas-snapshots>Gas Snapshots</h3><pre class=language-shell data-lang=shell style=color:#61676c;background-color:#fafafa><code class=language-shell data-lang=shell><span>$ forge snapshot
</span></code></pre><h3 id=deploy>Deploy</h3><pre class=language-shell data-lang=shell style=color:#61676c;background-color:#fafafa><code class=language-shell data-lang=shell><span>$ forge script script/DeployScript.s.sol:DeployScript --rpc-url &LTyour_rpc_url> --private-key &LTyour_private_key>
</span></code></pre></section></article></main></div>