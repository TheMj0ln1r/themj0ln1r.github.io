<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         RareSkills Circom Puzzles - Spoilers
        
    </title><meta content="RareSkills Circom Puzzles - Spoilers" property=og:title><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://themj0ln1r.github.io/fonts.css rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel=stylesheet><script async data-goatcounter=https://themj0ln1r.goatcounter.com/count src=https://themj0ln1r.github.io/js/count.js></script><noscript><img src="https://themj0ln1r.goatcounter.com//count?p=/writings/circom-puzzles-rareskills/&t=RareSkills Circom Puzzles - Spoilers"></noscript><script src=https://themj0ln1r.github.io/js/codeblock.js></script><script src=https://themj0ln1r.github.io/js/toc.js></script><script src=https://themj0ln1r.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="TheMj0ln1r Blog" href=https://themj0ln1r.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://themj0ln1r.github.io/theme/light.css rel=stylesheet><link href=https://themj0ln1r.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://themj0ln1r.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://themj0ln1r.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://themj0ln1r.github.io/><b>TheMj0ln1r Blog</b></a><div class=socials></div></div><nav><a href=https://themj0ln1r.github.io/cv style=margin-left:.5em><b>CV</b></a><a href=https://themj0ln1r.github.io/archive style=margin-left:.5em><b>Archive</b></a><a href=https://themj0ln1r.github.io/tags style=margin-left:.5em><b>Tags</b></a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://themj0ln1r.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://themj0ln1r.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>RareSkills Circom Puzzles - Spoilers</div><div class=meta>Posted on <time>2025-11-06</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://themj0ln1r.github.io/tags/web3/>web3</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/zk/>zk</a>, <a class=post-tag href=https://themj0ln1r.github.io/tags/circom/>circom</a> </span></div></div><div class=toc-container><h5 class=toc-title>Table of Contents</h5><ul class=toc-list><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#1-addition>1. Addition</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#2-multiply-no-output>2. Multiply No Output</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#3-compile>3. Compile</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#4-binary-xy>4. Binary XY</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#5-all-binary>5. All Binary</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#6-for-loop>6. For Loop</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#7-summation>7. Summation</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#8-equality>8. Equality</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#9-not-equal>9. Not Equal</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#10-multi-and>10. Multi AND</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#11-multi-and-no-output>11. Multi AND No Output</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#12-multi-or>12. Multi OR</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#13-four-bit-binary>13. Four Bit Binary</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#14-has-at-least-one>14. Has At Least One</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#15-increasing-distance>15. Increasing Distance</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#16-is-sorted>16. Is Sorted</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#17-is-tribonacci>17. Is Tribonacci</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#18-integer-division>18. Integer Division</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#19-integer-division-output>19. Integer Division Output</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#20-integer-square-root>20. Integer Square Root</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#21-integer-square-root-output>21. Integer Square Root Output</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#22-quadratic-equation>22. Quadratic Equation</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#23-power>23. Power</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#24-range-check>24. Range Check</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#25-poseidon-hash>25. Poseidon Hash</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#26-salt>26. Salt</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#27-sudoku-4x4>27. Sudoku (4x4)</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#28-sujiko>28. Sujiko</a><li><a href=https://themj0ln1r.github.io/writings/circom-puzzles-rareskills/#key-takeaways>Key Takeaways</a></ul></div><section class=body><p>Solutions to the RareSkills Circom puzzles from the <a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles>zero-knowledge-puzzles</a> repository.<h2 id=1-addition>1. Addition</h2><p><strong>Problem</strong>: Create a constraint that enforces <code>in[0]</code> equals the sum of <code>in[1]</code> and <code>in[2]</code>.<p><strong>Solution</strong>: Used a simple constraint <code>in[0] === in[1] + in[2]</code> to verify the addition relationship.<p><strong>Concepts covered</strong>: Basic constraint syntax in Circom and expressing arithmetic relationships directly.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Addition/Add.circom>Solution</a><hr><h2 id=2-multiply-no-output>2. Multiply No Output</h2><p><strong>Problem</strong>: Constrain the third signal to be the product of the first two signals without using an output signal.<p><strong>Solution</strong>: Directly constrained <code>in[2] === in[0] * in[1]</code> to verify the multiplication.<p><strong>Concepts covered</strong>: Constraints can verify relationships without explicit output signals.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/MultiplyNoOut/MultiplyNoOut.circom>Solution</a><hr><h2 id=3-compile>3. Compile</h2><p><strong>Problem</strong>: Learn how to compile a Circom circuit to R1CS and generate a Solidity verifier contract.<p><strong>Solution</strong>: Created a simple multiplier circuit with public input <code>a</code> and private input <code>b</code> that computes <code>c = a * b</code>.<p><strong>Concepts covered</strong>: The compilation pipeline from Circom to on-chain verification, and the distinction between public and private inputs.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Compile/Mul.circom>Solution</a><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Compile/Notes.md>Life Cycle of ZK circuit</a><hr><h2 id=4-binary-xy>4. Binary XY</h2><p><strong>Problem</strong>: Create constraints that enforce two input signals are binary (0 or 1).<p><strong>Solution</strong>: Used the constraint <code>in[i] * (in[i] - 1) === 0</code> for each input. This works because only 0 and 1 satisfy this equation.<p><strong>Concepts covered</strong>: Quadratic constraints for range checking. A binary value multiplied by itself minus one always equals zero.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/BinaryXY/BinaryXY.circom>Solution</a><hr><h2 id=5-all-binary>5. All Binary</h2><p><strong>Problem</strong>: Extend binary checking to work with an array of n signals.<p><strong>Solution</strong>: Looped through the array and applied the binary constraint <code>in[i] * (in[i] - 1) === 0</code> to each element.<p><strong>Concepts covered</strong>: Using loops to apply constraints to array elements and creating parameterized templates.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/AllBinary/AllBinary.circom>Solution</a><hr><h2 id=6-for-loop>6. For Loop</h2><p><strong>Problem</strong>: Add <code>a[0]</code> and <code>a[1]</code> four times using a for loop.<p><strong>Solution</strong>: Used an intermediate signal array to accumulate the sum. Initialized with <code>sum[0] = a[0]</code>, then looped to compute <code>sum[i+1] = sum[i] + a[1]</code> four times.<p><strong>Concepts covered</strong>: Managing intermediate signals in loops. Each constraint creates a new signal assignment.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/ForLoop/ForLoop.circom>Solution</a><hr><h2 id=7-summation>7. Summation</h2><p><strong>Problem</strong>: Constrain that a sum equals the total of all elements in an array of length n.<p><strong>Solution</strong>: Created intermediate signals to accumulate the sum progressively: <code>summ[i] = summ[i-1] + in[i]</code>, then constrained the final sum.<p><strong>Concepts covered</strong>: Accumulation pattern in Circom where each step builds on the previous using intermediate signals.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Summation/Summation.circom>Solution</a><hr><h2 id=8-equality>8. Equality</h2><p><strong>Problem</strong>: Check if three values in an array are all equal.<p><strong>Solution</strong>: Implemented <code>IsZero</code> template that checks if a value is zero by finding its modular inverse. Used <code>IsEqual</code> which applies <code>IsZero</code> to the difference of two values. Combined two <code>IsEqual</code> checks with multiplication - both must return 1 for all three values to be equal.<p><strong>Concepts covered</strong>:<ul><li>Using modular inverse to check if a value is zero in a finite field<li>The pattern: <code>out = -in * inv + 1</code> forces out=1 when in=0 and out=0 when in`0<li>The constraint <code>in * out === 0</code> additionally ensures the inverse is computed correctly<li>Why simple assignments without constraints create underconstrained circuits</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Equality/Equality.circom>Solution</a><hr><h2 id=9-not-equal>9. Not Equal</h2><p><strong>Problem</strong>: Check if two values are not equal, output 1 if different, 0 if same.<p><strong>Solution</strong>: Used the <code>IsEqual</code> component and negated its result: <code>c = 1 - ise.out</code>.<p><strong>Concepts covered</strong>: Boolean negation in circuits through arithmetic subtraction from 1.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/NotEqual/NotEqual.circom>Solution</a><hr><h2 id=10-multi-and>10. Multi AND</h2><p><strong>Problem</strong>: Return 1 if all signals in an array are 1, otherwise return 0. Ensure all inputs are binary.<p><strong>Solution</strong>: First constrained all inputs to be binary, then computed the product of all elements - the result is 1 only if all elements are 1.<p><strong>Concepts covered</strong>: AND operation as multiplication in binary arithmetic. Accumulating products through intermediate signals.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/MultiAND/MultiAND.circom>Solution</a><hr><h2 id=11-multi-and-no-output>11. Multi AND No Output</h2><p><strong>Problem</strong>: Verify that all signals in an array equal 1, without an output signal.<p><strong>Solution</strong>: Simply constrained each element directly: <code>in[i] === 1</code> in a loop.<p><strong>Concepts covered</strong>: Constraints can verify conditions without producing outputs. Simpler when you only need to verify, not compute.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/MultiANDNoOut/MultiANDNoOut.circom>Solution</a><hr><h2 id=12-multi-or>12. Multi OR</h2><p><strong>Problem</strong>: Return 1 if at least one signal is 1, return 0 if all are 0. Inputs must be binary.<p><strong>Solution</strong>: Constrained inputs to binary, then computed OR iteratively using: <code>found[i] = found[i-1] + in[i] - found[i-1]*in[i]</code>. This implements <code>A OR B = A + B - A*B</code>.<p><strong>Concepts covered</strong>: OR operation in arithmetic circuits using the algebraic formula that avoids exceeding 1 when both inputs are 1.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/MultiOR/MultiOR.circom>Solution</a><hr><h2 id=13-four-bit-binary>13. Four Bit Binary</h2><p><strong>Problem</strong>: Verify that a 4-element array represents the binary form of a number n (0-15).<p><strong>Solution</strong>: Constrained each element to be binary, then computed the decimal value: <code>bin_sum[i+1] = bin_sum[i] + in[i] * (1 &lt;&lt; i)</code>. Finally constrained the sum equals n.<p><strong>Concepts covered</strong>: Converting binary representation to decimal in circuits using positional notation with powers of 2.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/FourBitBinary/FourBitBinary.circom>Solution</a><hr><h2 id=14-has-at-least-one>14. Has At Least One</h2><p><strong>Problem</strong>: Return 1 if a value k exists in an array, otherwise 0.<p><strong>Solution</strong>: Used <code>IsEqual</code> to check each element against k, then ORed all results together using: <code>found[i+1] = found[i] + ise[i].out - found[i]*ise[i].out</code>.<p><strong>Concepts covered</strong>: Combining equality checks with OR logic to implement membership testing in arrays.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/HasAtLeastOne/HasAtLeastOne.circom>Solution</a><hr><h2 id=15-increasing-distance>15. Increasing Distance</h2><p><strong>Problem</strong>: Enforce constraints where <code>in1[i] * in2[i] === in3[i] + i</code> for each index i.<p><strong>Solution</strong>: Looped through arrays and applied the constraint directly: <code>in1[i] * in2[i] === in3[i] + i</code>.<p><strong>Concepts covered</strong>: Creating dynamic constraints that vary based on loop iteration index.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IncreasingDistance/IncreasingDistance.circom>Solution</a><hr><h2 id=16-is-sorted>16. Is Sorted</h2><p><strong>Problem</strong>: Verify that a 4-element array is sorted in non-decreasing order.<p><strong>Solution</strong>: Used <code>LessEqThan</code> comparator to verify <code>in[i] &lt;= in[i+1]</code> for each consecutive pair.<p><strong>Concepts covered</strong>: Verifying ordering relationships using comparison circuits from circomlib.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IsSorted/IsSorted.circom>Solution</a><hr><h2 id=17-is-tribonacci>17. Is Tribonacci</h2><p><strong>Problem</strong>: Verify that an array follows the Tribonacci sequence (0, 1, 1, 2, 4, 7, 13, ...).<p><strong>Solution</strong>: Constrained the first three elements to 0, 1, 1, then constrained each subsequent element to be the sum of the previous three: <code>in[i] === in[i-1] + in[i-2] + in[i-3]</code>.<p><strong>Concepts covered</strong>: Expressing recursive sequences as constraints in zero-knowledge circuits.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IsTribonacci/IsTribonacci.circom>Solution</a><hr><h2 id=18-integer-division>18. Integer Division</h2><p><strong>Problem</strong>: Verify that numerator, denominator, quotient, and remainder represent a valid integer division.<p><strong>Solution</strong>: Applied three key constraints:<ol><li><code>denominator != 0</code> using <code>IsZero</code><li><code>remainder &lt; denominator</code> using <code>LessThan</code><li><code>numerator = denominator * quotient + remainder</code></ol><p><strong>Concepts covered</strong>: Verifying division without computing it directly. Division properties can be checked through multiplication and comparison constraints.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IntDiv/IntDiv.circom>Solution</a><hr><h2 id=19-integer-division-output>19. Integer Division Output</h2><p><strong>Problem</strong>: Same as Integer Division but compute the quotient as output.<p><strong>Solution</strong>: Used <code>&lt;--</code> to compute quotient and remainder off-circuit (<code>quotient &lt;-- numerator \ denominator</code>), then applied the same three constraints from IntDiv to verify correctness.<p><strong>Concepts covered</strong>: The "compute then constrain" pattern - use <code>&lt;--</code> for witness computation, then <code>&lt;==</code> and <code>===</code> to constrain the computed values.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IntDivOut/IntDivOut.circom>Solution</a><hr><h2 id=20-integer-square-root>20. Integer Square Root</h2><p><strong>Problem</strong>: Verify that <code>in[0]</code> is the floor of the integer square root of <code>in[1]</code>.<p><strong>Solution</strong>: A value b is the integer square root of a if:<ul><li><code>b &lt;= a</code> (floor property)<li><code>(b+1)*(b+1) > a</code> (can't go higher)<li><code>b &lt; 2^125</code> (overflow prevention)</ul><p>Implemented using <code>LessEqThan</code>, <code>GreaterThan</code> and range check to prevent finite field overflow.<p><strong>Concepts covered</strong>:<ul><li>Verifying integer square roots without computing them<li>Finite field overflow issues: if input is too large (>126 bits), the squared value wraps around modulo p<li>Why <code>b &lt; 2^125</code>: prevents <code>(b+1)*(b+1)</code> from exceeding the 252-bit comparator limit</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IntSqrt/IntSqrt.circom>Solution</a><hr><h2 id=21-integer-square-root-output>21. Integer Square Root Output</h2><p><strong>Problem</strong>: Compute the integer square root and constrain it using the logic from IntSqrt.<p><strong>Solution</strong>: Implemented Babylonian/Heron's method in a Circom function to compute the square root off-circuit. The algorithm iteratively computes <code>new_guess = (guess + n/guess) / 2</code>, which converges to the square root. Then applied the same constraints from IntSqrt to verify the result.<p><strong>Concepts covered</strong>:<ul><li>Implementing iterative algorithms in Circom functions (executed at compile/witness generation time)<li>The Babylonian method: imagine a rectangle with area n, width x, and height n/x - averaging these dimensions converges to n<li>Separating computation (function) from verification (constraints)</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/IntSqrtOut/IntSqrtOut.circom>Solution</a><hr><h2 id=22-quadratic-equation>22. Quadratic Equation</h2><p><strong>Problem</strong>: Verify a quadratic equation <code>axï¿½ + bx + c = res</code>.<p><strong>Solution</strong>: Used intermediate signals to satisfy the "at most one multiplication per constraint" rule:<ul><li><code>x_squared &lt;== x * x</code><li><code>a_x_squared &lt;== a * x_squared</code><li><code>computed_res &lt;== a_x_squared + b * x + c</code><li>Checked if <code>computed_res == res</code> using <code>IsEqual</code></ul><p><strong>Concepts covered</strong>: Breaking down complex expressions into quadratic constraints. Each constraint in Circom can have at most one multiplication.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/QuadraticEquation/QuadraticEquation.circom>Solution</a><hr><h2 id=23-power>23. Power</h2><p><strong>Problem</strong>: Compute <code>a[0]^a[1]</code> where the exponent can be 0-10.<p><strong>Solution</strong>: Pre-computed all powers (a^0 through a^10) in a loop. Then used <code>IsEqual</code> to find which power index matches the exponent, multiplied that result by the corresponding power value, and summed to get the final answer.<p><strong>Concepts covered</strong>:<ul><li>Implementing power operations when direct exponentiation isn't available<li>The selection pattern: pre-compute all possibilities, use equality checks to select the correct one<li>One component instance needed per loop iteration in Circom</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Power/pow.circom>Solution</a><hr><h2 id=24-range-check>24. Range Check</h2><p><strong>Problem</strong>: Verify that a value falls within a given range [lowerbound, upperbound].<p><strong>Solution</strong>: Implemented custom comparator templates from scratch:<ul><li><code>MyLessThan(n)</code>: Uses bit decomposition - compute <code>Lambda = 2^n + (a-b)</code> and check the MSB. If a &lt; b, then Lambda &lt; 2^n so MSB=0, otherwise MSB=1.<li>Built other comparators on top: <code>LessThanOrEqual(a,b) = LessThan(a, b+1)</code>, <code>GreaterThan(a,b) = LessThan(b,a)</code>, etc.<li>Final check: <code>(a >= lowerbound) AND (a &lt;= upperbound)</code> using multiplication.</ul><p><strong>Concepts covered</strong>:<ul><li>How comparison works in ZK circuits using bit decomposition<li>The midpoint trick: adding 2^n creates a reference point to check if a number is above or below it based on MSB<li>Why 2^(n-1) is the smallest n-bit number with MSB=1</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Range/Range.circom>Solution</a><hr><h2 id=25-poseidon-hash>25. Poseidon Hash</h2><p><strong>Problem</strong>: Hash four input values using the Poseidon hash function from circomlib.<p><strong>Solution</strong>: Imported the Poseidon template from circomlib, instantiated it with parameter 4 (number of inputs), wired the inputs to <code>pose.inputs[0..3]</code>, and connected the output.<p><strong>Concepts covered</strong>: Using circomlib's ZK-friendly hash functions. Poseidon is optimized for arithmetic circuits unlike traditional hashes like SHA-256.<p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Poseidon/Poseidon.circom>Solution</a><hr><h2 id=26-salt>26. Salt</h2><p><strong>Problem</strong>: Hash two values (a, b) with a secret salt to prevent brute force attacks.<p><strong>Solution</strong>: Used MiMCSponge hash with 2 inputs and 220 rounds. Passed <code>a</code> and <code>b</code> as inputs, and <code>salt</code> as the key parameter.<p><strong>Concepts covered</strong>:<ul><li>MiMCSponge as another ZK-friendly hash function<li>All inputs are private by default in Circom unless explicitly marked public</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Salt/Salt.circom>Solution</a><hr><h2 id=27-sudoku-4x4>27. Sudoku (4x4)</h2><p><strong>Problem</strong>: Verify a 4x4 Sudoku solution against a given question.<p><strong>Solution</strong>: Built comprehensive verification with multiple constraint layers:<ol><li><strong>Input validation</strong>: Solution matches non-zero question cells<li><strong>Range checks</strong>: All values are 1-4<li><strong>Row constraints</strong>: Each row sums to 10 and has unique values<li><strong>Column constraints</strong>: Each column sums to 10 and has unique values<li><strong>Box constraints</strong>: Each 2x2 box sums to 10 and has unique values<li><strong>Uniqueness checks</strong>: For each row/column/box, verified all pairs are different using nested loops</ol><p><strong>Concepts covered</strong>:<ul><li>Building complex verification logic by layering multiple constraint types<li>Chained array lookups don't work in Circom - must use intermediate variables<li>Using AND logic (multiplication) to combine multiple boolean checks into final output<li>Comprehensive constraint coverage prevents false proofs</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Sudoku/Sudoku.circom>Solution</a><hr><h2 id=28-sujiko>28. Sujiko</h2><p><strong>Problem</strong>: Verify a 3x3 Sujiko puzzle where four central circles show sums of their surrounding 2x2 blocks.<p><strong>Solution</strong>:<ol><li>Constrained each of the 4 circle values equals the sum of its surrounding 4 cells<li>Verified each number 1-9 appears exactly once using a double loop: outer loop iterates 1-9, inner loop counts occurrences of that number in the solution<li>Used <code>assert</code> to validate solution values are in range 1-9</ol><p><strong>Concepts covered</strong>:<ul><li>Expressing puzzle rules as arithmetic constraints<li>Using nested loops with <code>IsEqual</code> to verify uniqueness across a set<li>The difference between <code>assert</code> (compile-time check) and constraints (proof-time check)</ul><p><a href=https://github.com/TheMj0ln1r/zero-knowledge-puzzles/blob/main/Sujiko/Sujiko.circom>Solution</a><hr><h2 id=key-takeaways>Key Takeaways</h2><p>Throughout these puzzles, you will learn:<ol><li><strong>Constraint Design Patterns</strong>: Compute-then-constrain, indicate-then-constrain<li><strong>Finite Field Arithmetic</strong>: How operations work modulo p and potential overflow issues<li><strong>Quadratic Constraints</strong>: Each constraint can have at most one multiplication<li><strong>Intermediate Signals</strong>: Essential for complex computations and accumulation patterns<li><strong>Boolean Logic in Arithmetic</strong>: AND (multiplication), OR (A+B-A*B), NOT (1-A)<li><strong>Circomlib Components</strong>: IsZero, IsEqual, LessThan, Poseidon, MiMCSponge, etc.<li><strong>Security Considerations</strong>: Proper constraint coverage prevents underconstrained circuits and fake proofs<li><strong>Compute vs Verify</strong>: Functions for computation, constraints for verification</ol></section></article></main></div>