<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Google CTF 2023
        
    </title><meta content="Google CTF 2023" property=og:title><link href=/favicons/favicon.ico rel=icon type=image/png><link href=https://themj0ln1r.github.io/fonts.css rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel=stylesheet><script async data-goatcounter=https://themj0ln1r.goatcounter.com/count src=https://themj0ln1r.github.io/js/count.js></script><noscript><img src="https://themj0ln1r.goatcounter.com//count?p=/archive/googlectf23/&t=Google CTF 2023"></noscript><script src=https://themj0ln1r.github.io/js/codeblock.js></script><script src=https://themj0ln1r.github.io/js/toc.js></script><script src=https://themj0ln1r.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="TheMj0ln1r Blog" href=https://themj0ln1r.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://themj0ln1r.github.io/theme/light.css rel=stylesheet><link href=https://themj0ln1r.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://themj0ln1r.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://themj0ln1r.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://themj0ln1r.github.io/><b>TheMj0ln1r Blog</b></a><div class=socials></div></div><nav><a href=https://themj0ln1r.github.io/cv style=margin-left:.5em><b>CV</b></a><a href=https://themj0ln1r.github.io/archive style=margin-left:.5em><b>Archive</b></a><a href=https://themj0ln1r.github.io/tags style=margin-left:.5em><b>Tags</b></a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://themj0ln1r.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://themj0ln1r.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Google CTF 2023</div><div class=meta>Posted on <time>2023-06-26</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://themj0ln1r.github.io/tags/ctf/>ctf</a> </span></div></div><div class=toc-container><h5 class=toc-title>Table of Contents</h5><ul class=toc-list><li><a href=https://themj0ln1r.github.io/archive/googlectf23/#crypto-least-common-genominator>Crypto - LEAST COMMON GENOMINATOR?</a></ul></div><section class=body><p>Hello all! I played <a href=https://ctftime.org/event/1929 target=_blank>Google CTF 2023</a> which was happened from 24 June to 26 June.<h1 id=crypto-least-common-genominator>Crypto - LEAST COMMON GENOMINATOR?</h1><p><img alt=LCG src=/assets/img/ctf_img/googlectf23/googlectf23_lcg.png><p>Attached File : [generate.py,dump.txt,flag.txt,public.pem]<p><code>generate.py</code><pre class=language-python data-lang=python style=color:#323232;background-color:#fff><code class=language-python data-lang=python><span style=color:#a71d5d;font-weight:700>from </span><span>secret </span><span style=color:#a71d5d;font-weight:700>import </span><span>config
</span><span style=color:#a71d5d;font-weight:700>from </span><span>Crypto.PublicKey </span><span style=color:#a71d5d;font-weight:700>import </span><span style=color:#0086b3>RSA
</span><span style=color:#a71d5d;font-weight:700>from </span><span>Crypto.Util.number </span><span style=color:#a71d5d;font-weight:700>import </span><span>bytes_to_long, isPrime
</span><span>
</span><span style=color:#a71d5d;font-weight:700>class </span><span style=color:#0086b3>LCG</span><span>:
</span><span>    lcg_m </span><span style=color:#a71d5d;font-weight:700>= </span><span>config.m
</span><span>    lcg_c </span><span style=color:#a71d5d;font-weight:700>= </span><span>config.c
</span><span>    lcg_n </span><span style=color:#a71d5d;font-weight:700>= </span><span>config.n
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#62a35c;font-weight:700>__init__</span><span>(self, lcg_s):
</span><span>        self.state </span><span style=color:#a71d5d;font-weight:700>= </span><span>lcg_s
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>next</span><span>(self):
</span><span>        self.state </span><span style=color:#a71d5d;font-weight:700>= </span><span>(self.state </span><span style=color:#a71d5d;font-weight:700>* </span><span>self.lcg_m </span><span style=color:#a71d5d;font-weight:700>+ </span><span>self.lcg_c) </span><span style=color:#a71d5d;font-weight:700>% </span><span>self.lcg_n
</span><span>        </span><span style=color:#a71d5d;font-weight:700>return </span><span>self.state
</span><span>
</span><span style=color:#a71d5d;font-weight:700>if </span><span>__name__ </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#183691>'__main__'</span><span>:
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span style=color:#0086b3>4096 </span><span style=color:#a71d5d;font-weight:700>% </span><span>config.it </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#0086b3>0
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span>config.it </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#0086b3>8
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span style=color:#0086b3>4096 </span><span style=color:#a71d5d;font-weight:700>% </span><span>config.bits </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#0086b3>0
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span>config.bits </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#0086b3>512
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Find prime value of specified bits a specified amount of times
</span><span>    seed </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
</span><span>    lcg </span><span style=color:#a71d5d;font-weight:700>= </span><span>LCG(seed)
</span><span>    primes_arr </span><span style=color:#a71d5d;font-weight:700>= </span><span>[]
</span><span>    
</span><span>    dump </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>True
</span><span>    items </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>0
</span><span>    dump_file </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>open</span><span>(</span><span style=color:#183691>"dump.txt"</span><span>, </span><span style=color:#183691>"w"</span><span>)
</span><span>
</span><span>    primes_n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>while </span><span style=color:#0086b3>True</span><span>:
</span><span>        </span><span style=color:#a71d5d;font-weight:700>for </span><span>i </span><span style=color:#a71d5d;font-weight:700>in </span><span style=color:#62a35c>range</span><span>(config.it):
</span><span>            </span><span style=color:#a71d5d;font-weight:700>while </span><span style=color:#0086b3>True</span><span>:
</span><span>                prime_candidate </span><span style=color:#a71d5d;font-weight:700>= </span><span>lcg.next()
</span><span>                </span><span style=color:#a71d5d;font-weight:700>if </span><span>dump:
</span><span>                    dump_file.write(</span><span style=color:#0086b3>str</span><span>(prime_candidate) </span><span style=color:#a71d5d;font-weight:700>+ </span><span style=color:#183691>'</span><span style=color:#0086b3>\n</span><span style=color:#183691>'</span><span>)
</span><span>                    items </span><span style=color:#a71d5d;font-weight:700>+= </span><span style=color:#0086b3>1
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>if </span><span>items </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#0086b3>6</span><span>:
</span><span>                        dump </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>False
</span><span>                        dump_file.close()
</span><span>                </span><span style=color:#a71d5d;font-weight:700>if not </span><span>isPrime(prime_candidate):
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>                </span><span style=color:#a71d5d;font-weight:700>elif </span><span>prime_candidate.bit_length() </span><span style=color:#a71d5d;font-weight:700>!= </span><span>config.bits:
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>                </span><span style=color:#a71d5d;font-weight:700>else</span><span>:
</span><span>                    primes_n </span><span style=color:#a71d5d;font-weight:700>*= </span><span>prime_candidate
</span><span>                    primes_arr.append(prime_candidate)
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>break
</span><span>        
</span><span>        </span><span style=color:#969896;font-style:italic># Check bit length
</span><span>        </span><span style=color:#a71d5d;font-weight:700>if </span><span>primes_n.bit_length() </span><span style=color:#a71d5d;font-weight:700>> </span><span style=color:#0086b3>4096</span><span>:
</span><span>            </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#183691>"bit length"</span><span>, primes_n.bit_length())
</span><span>            primes_arr.clear()
</span><span>            primes_n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>            </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>        </span><span style=color:#a71d5d;font-weight:700>else</span><span>:
</span><span>            </span><span style=color:#a71d5d;font-weight:700>break
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Create public key 'n'
</span><span>    n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>for </span><span>j </span><span style=color:#a71d5d;font-weight:700>in </span><span>primes_arr:
</span><span>        n </span><span style=color:#a71d5d;font-weight:700>*= </span><span>j
</span><span>    </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#183691>"[+] Public Key: "</span><span>, n)
</span><span>    </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#183691>"[+] size: "</span><span>, n.bit_length(), </span><span style=color:#183691>"bits"</span><span>)
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Calculate totient 'Phi(n)'
</span><span>    phi </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>for </span><span>k </span><span style=color:#a71d5d;font-weight:700>in </span><span>primes_arr:
</span><span>        phi </span><span style=color:#a71d5d;font-weight:700>*= </span><span>(k </span><span style=color:#a71d5d;font-weight:700>- </span><span style=color:#0086b3>1</span><span>)
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Calculate private key 'd'
</span><span>    d </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>pow</span><span>(config.e, </span><span style=color:#a71d5d;font-weight:700>-</span><span style=color:#0086b3>1</span><span>, phi)
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Generate Flag
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span>config.flag.startswith(</span><span style=color:#a71d5d;font-weight:700>b</span><span style=color:#183691>"CTF{"</span><span>)
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span>config.flag.endswith(</span><span style=color:#a71d5d;font-weight:700>b</span><span style=color:#183691>"}"</span><span>)
</span><span>    enc_flag </span><span style=color:#a71d5d;font-weight:700>= </span><span>bytes_to_long(config.flag)
</span><span>    </span><span style=color:#a71d5d;font-weight:700>assert </span><span>enc_flag </span><span style=color:#a71d5d;font-weight:700>&lt; </span><span>n
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Encrypt Flag
</span><span>    _enc </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>pow</span><span>(enc_flag, config.e, n)
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>with </span><span style=color:#62a35c>open </span><span>(</span><span style=color:#183691>"flag.txt"</span><span>, </span><span style=color:#183691>"wb"</span><span>) </span><span style=color:#a71d5d;font-weight:700>as </span><span>flag_file:
</span><span>        flag_file.write(_enc.to_bytes(n.bit_length(), </span><span style=color:#183691>"little"</span><span>))
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Export RSA Key
</span><span>    rsa </span><span style=color:#a71d5d;font-weight:700>= </span><span>RSA.construct((n, config.e))
</span><span>    </span><span style=color:#a71d5d;font-weight:700>with </span><span style=color:#62a35c>open </span><span>(</span><span style=color:#183691>"public.pem"</span><span>, </span><span style=color:#183691>"w"</span><span>) </span><span style=color:#a71d5d;font-weight:700>as </span><span>pub_file:
</span><span>        pub_file.write(rsa.exportKey().decode())
</span></code></pre><p><code>dump.txt</code><pre style=color:#323232;background-color:#fff><code><span>2166771675595184069339107365908377157701164485820981409993925279512199123418374034275465590004848135946671454084220731645099286746251308323653144363063385
</span><span>6729272950467625456298454678219613090467254824679318993052294587570153424935267364971827277137521929202783621553421958533761123653824135472378133765236115
</span><span>2230396903302352921484704122705539403201050490164649102182798059926343096511158288867301614648471516723052092761312105117735046752506523136197227936190287
</span><span>4578847787736143756850823407168519112175260092601476810539830792656568747136604250146858111418705054138266193348169239751046779010474924367072989895377792
</span><span>7578332979479086546637469036948482551151240099803812235949997147892871097982293017256475189504447955147399405791875395450814297264039908361472603256921612
</span><span>2550420443270381003007873520763042837493244197616666667768397146110589301602119884836605418664463550865399026934848289084292975494312467018767881691302197
</span></code></pre><p>And the <code>flag.txt</code> is an encrypted flag.<p>Observations:<pre style=color:#323232;background-color:#fff><code><span>1. The actual flag was encrypted with the RSA
</span><span>2. The primes are generated using a Linear Congruential Generator
</span><span>3. The seed is known
</span><span>4. First 6 generated random values of LCG are known
</span></code></pre><p>The LCG works on equation :<p>$$ X_{n+1} = (a \times X_{n}+c) mod p $$<p>Where,<ul><li>$$X(n)$$ is a sequence of pseudo random values.<li>$$p$$ is modulo defined as $$0 &lt; p$$<li>$$a$$ is the multiplier defined as $$0 &lt; a &lt; p$$<li>$$c$$ is the increment $$0 &lt;= c &lt; p$$ ( if $$c = 0$$ the LCG is called Multiplicative Congruential Generator)</ul><p>We can see the generate.py implementation.<p><code>lcg_m = a lcg_c = c lcg_n = p</code><p>We have total generated values of lcg including seed.<p>We can find the <code>n(modulus)</code> by making the 4 $$2 \times 2$$ matrices from $$ X_1,X_2,X_3,X_4,X_5,X_6,X_7$$ and finding the GCD of the determinant values of these 7 values.<p>The 4 $$2 \times 2$$ matrices, $$ \begin{bmatrix} X_1 - X_0 & X_2 - X_1\ X_2 - X_0 & X_3 - X_1 \end{bmatrix} \begin{bmatrix} X_2 - X_0 & X_3 - X_1\ X_3 - X_0 & X_4 - X_1 \end{bmatrix}$$<p>$$ \begin{bmatrix} X_3 - X_0 & X_4 - X_1\ X_4 - X_0 & X_5 - X_1 \end{bmatrix}, \begin{bmatrix} X_4 - X_0 & X_5 - X_1\ X_5 - X_0 & X_6 - X_1 \end{bmatrix} $$<p>Finding determinant of these all and then finding the GCD of them will give us the modulus(n) used in lcg.<p>With $$n$$ we can find $$a$$ by solving these equations.<p>$$ X_1 = (a \times X_0+c) mod p\ X_2 = (a \times X_1+c) mod p\ $$<p>$$ X_2 - X_1 = (a \times X_1+c - (X_0 \times a+c)) mod p\ X_2 - X_1 = (a \times X_1 - (X_0 \times a)) mod p\ X_2 - X_1 = (X_1 - X_0) \times a mod p\ \frac{X_2 - X_1}{X_1 - X_0} = a mod p \ a = \frac{X_2 - X_1}{X_1 - X_0} mod p\ a = ((X_2 - X_1)) \times InverseMod(X_1 - X_0,p) mod p\ $$<p>Lets solve for $$c$$,<p>$$ X_1 = (a \times X_0+c) mod p\ X_1 - c = (a \times X_0) mod p\ -c = (a \times X_0 - X_1) mod p\ c = (X_1 - a \times X_0) mod p $$<p>So, with <code>n,c,m</code> we can generate entire series which is used to generate primes in the encryption.<p>The python implementation to find <code>n,c,m</code><pre class=language-python data-lang=python style=color:#323232;background-color:#fff><code class=language-python data-lang=python><span style=color:#a71d5d;font-weight:700>import </span><span>math
</span><span>
</span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>calc_det</span><span>(i, j, X):
</span><span>    a1 </span><span style=color:#a71d5d;font-weight:700>= </span><span>X[i] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>0</span><span>]
</span><span>    b1 </span><span style=color:#a71d5d;font-weight:700>= </span><span>X[i </span><span style=color:#a71d5d;font-weight:700>+ </span><span style=color:#0086b3>1</span><span>] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>1</span><span>]
</span><span>    a2 </span><span style=color:#a71d5d;font-weight:700>= </span><span>X[j] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>0</span><span>]
</span><span>    b2 </span><span style=color:#a71d5d;font-weight:700>= </span><span>X[j </span><span style=color:#a71d5d;font-weight:700>+ </span><span style=color:#0086b3>1</span><span>] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>1</span><span>]
</span><span>    det </span><span style=color:#a71d5d;font-weight:700>= </span><span>a1 </span><span style=color:#a71d5d;font-weight:700>* </span><span>b2 </span><span style=color:#a71d5d;font-weight:700>- </span><span>a2 </span><span style=color:#a71d5d;font-weight:700>* </span><span>b1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>return </span><span style=color:#62a35c>abs</span><span>(det)
</span><span>
</span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>GCD</span><span>(a, b):
</span><span>
</span><span>    a </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>abs</span><span>(a)
</span><span>    b </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>abs</span><span>(b)
</span><span>    </span><span style=color:#a71d5d;font-weight:700>while </span><span>a:
</span><span>        a, b </span><span style=color:#a71d5d;font-weight:700>= </span><span>b </span><span style=color:#a71d5d;font-weight:700>% </span><span>a, a
</span><span>    </span><span style=color:#a71d5d;font-weight:700>return </span><span>b
</span><span>
</span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>modInverse</span><span>(a, m):
</span><span>    </span><span style=color:#a71d5d;font-weight:700>if </span><span>GCD(a, m) </span><span style=color:#a71d5d;font-weight:700>!= </span><span style=color:#0086b3>1</span><span>:
</span><span>        </span><span style=color:#a71d5d;font-weight:700>return </span><span style=color:#0086b3>None  </span><span style=color:#969896;font-style:italic>#if not releatively prime no modinv
</span><span>    u1, u2, u3 </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1</span><span>, </span><span style=color:#0086b3>0</span><span>, a
</span><span>    v1, v2, v3 </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>0</span><span>, </span><span style=color:#0086b3>1</span><span>, m
</span><span>    </span><span style=color:#a71d5d;font-weight:700>while </span><span>v3 </span><span style=color:#a71d5d;font-weight:700>!= </span><span style=color:#0086b3>0</span><span>:
</span><span>        q </span><span style=color:#a71d5d;font-weight:700>= </span><span>u3 </span><span style=color:#a71d5d;font-weight:700>// </span><span>v3 
</span><span>        v1, v2, v3, u1, u2, u3 </span><span style=color:#a71d5d;font-weight:700>= </span><span>(
</span><span>            u1 </span><span style=color:#a71d5d;font-weight:700>- </span><span>q </span><span style=color:#a71d5d;font-weight:700>* </span><span>v1,
</span><span>            u2 </span><span style=color:#a71d5d;font-weight:700>- </span><span>q </span><span style=color:#a71d5d;font-weight:700>* </span><span>v2,
</span><span>            u3 </span><span style=color:#a71d5d;font-weight:700>- </span><span>q </span><span style=color:#a71d5d;font-weight:700>* </span><span>v3,
</span><span>            v1,
</span><span>            v2,
</span><span>            v3,
</span><span>        )
</span><span>    </span><span style=color:#a71d5d;font-weight:700>return </span><span>u1 </span><span style=color:#a71d5d;font-weight:700>% </span><span>m
</span><span>
</span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>main</span><span>():
</span><span>    </span><span style=color:#a71d5d;font-weight:700>while </span><span style=color:#0086b3>True</span><span>:
</span><span>        </span><span style=color:#a71d5d;font-weight:700>try</span><span>:
</span><span>            X </span><span style=color:#a71d5d;font-weight:700>= </span><span>[
</span><span>                </span><span style=color:#0086b3>211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635</span><span>,
</span><span>                </span><span style=color:#0086b3>2166771675595184069339107365908377157701164485820981409993925279512199123418374034275465590004848135946671454084220731645099286746251308323653144363063385</span><span>,
</span><span>                </span><span style=color:#0086b3>6729272950467625456298454678219613090467254824679318993052294587570153424935267364971827277137521929202783621553421958533761123653824135472378133765236115</span><span>,
</span><span>                </span><span style=color:#0086b3>2230396903302352921484704122705539403201050490164649102182798059926343096511158288867301614648471516723052092761312105117735046752506523136197227936190287</span><span>,
</span><span>                </span><span style=color:#0086b3>4578847787736143756850823407168519112175260092601476810539830792656568747136604250146858111418705054138266193348169239751046779010474924367072989895377792</span><span>,
</span><span>                </span><span style=color:#0086b3>7578332979479086546637469036948482551151240099803812235949997147892871097982293017256475189504447955147399405791875395450814297264039908361472603256921612</span><span>,
</span><span>                </span><span style=color:#0086b3>2550420443270381003007873520763042837493244197616666667768397146110589301602119884836605418664463550865399026934848289084292975494312467018767881691302197</span><span>,
</span><span>            ]
</span><span>
</span><span>            Det_X </span><span style=color:#a71d5d;font-weight:700>= </span><span>[]
</span><span>            Det_X.append(calc_det(</span><span style=color:#0086b3>1</span><span>, </span><span style=color:#0086b3>2</span><span>, X))
</span><span>            Det_X.append(calc_det(</span><span style=color:#0086b3>2</span><span>, </span><span style=color:#0086b3>3</span><span>, X))
</span><span>            Det_X.append(calc_det(</span><span style=color:#0086b3>3</span><span>, </span><span style=color:#0086b3>4</span><span>, X))
</span><span>            Det_X.append(calc_det(</span><span style=color:#0086b3>4</span><span>, </span><span style=color:#0086b3>5</span><span>, X))
</span><span>
</span><span>            found_p </span><span style=color:#a71d5d;font-weight:700>= </span><span>math.gcd(math.gcd(Det_X[</span><span style=color:#0086b3>0</span><span>], Det_X[</span><span style=color:#0086b3>1</span><span>]), math.gcd(Det_X[</span><span style=color:#0086b3>2</span><span>], Det_X[</span><span style=color:#0086b3>3</span><span>]))
</span><span>
</span><span>            </span><span style=color:#969896;font-style:italic># To find 'a' and 'c' we need to solve the 
</span><span>            mod_inv_a </span><span style=color:#a71d5d;font-weight:700>= </span><span>modInverse((X[</span><span style=color:#0086b3>2</span><span>] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>3</span><span>]), found_p) 
</span><span>            found_a </span><span style=color:#a71d5d;font-weight:700>= </span><span>((X[</span><span style=color:#0086b3>3</span><span>] </span><span style=color:#a71d5d;font-weight:700>- </span><span>X[</span><span style=color:#0086b3>4</span><span>]) </span><span style=color:#a71d5d;font-weight:700>* </span><span>mod_inv_a) </span><span style=color:#a71d5d;font-weight:700>% </span><span>found_p
</span><span>            
</span><span>            found_c </span><span style=color:#a71d5d;font-weight:700>= </span><span>(X[</span><span style=color:#0086b3>4</span><span>] </span><span style=color:#a71d5d;font-weight:700>- </span><span>found_a </span><span style=color:#a71d5d;font-weight:700>* </span><span>X[</span><span style=color:#0086b3>3</span><span>]) </span><span style=color:#a71d5d;font-weight:700>% </span><span>found_p
</span><span>           
</span><span>            </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#183691>"n = </span><span style=color:#0086b3>%d\n</span><span style=color:#183691>m = </span><span style=color:#0086b3>%d\n</span><span style=color:#183691>c = </span><span style=color:#0086b3>%d\n</span><span style=color:#183691>" </span><span style=color:#a71d5d;font-weight:700>% </span><span>(found_p, found_a, found_c))
</span><span>            </span><span style=color:#a71d5d;font-weight:700>break
</span><span>        </span><span style=color:#a71d5d;font-weight:700>except </span><span style=color:#0086b3>TypeError</span><span>:
</span><span>            </span><span style=color:#a71d5d;font-weight:700>pass
</span><span>
</span><span style=color:#a71d5d;font-weight:700>if </span><span>__name__ </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#183691>"__main__"</span><span>:
</span><span>    main()
</span><span>
</span><span style=color:#969896;font-style:italic>#Output
</span><span style=color:#969896;font-style:italic># n = 8311271273016946265169120092240227882013893131681882078655426814178920681968884651437107918874328518499850252591810409558783335118823692585959490215446923
</span><span style=color:#969896;font-style:italic># m = 99470802153294399618017402366955844921383026244330401927153381788409087864090915476376417542092444282980114205684938728578475547514901286372129860608477
</span><span style=color:#969896;font-style:italic># c = 3910539794193409979886870049869456815685040868312878537393070815966881265118275755165613835833103526090552456472867019296386475520134783987251699999776365
</span></code></pre><p>With these values as input we can find the modulus used in the encryption, <code>n</code>, <code>phi</code> and followed by <code>d</code>.<p>Or we can just import the <code>public.pem</code> to find <code>e,n</code> used in the encryption.<p>Here is the final solution script to get the flag.<pre class=language-python data-lang=python style=color:#323232;background-color:#fff><code class=language-python data-lang=python><span style=color:#a71d5d;font-weight:700>from </span><span>Crypto.PublicKey </span><span style=color:#a71d5d;font-weight:700>import </span><span style=color:#0086b3>RSA
</span><span style=color:#a71d5d;font-weight:700>from </span><span>Crypto.Util.number </span><span style=color:#a71d5d;font-weight:700>import </span><span>bytes_to_long, isPrime,long_to_bytes
</span><span>
</span><span style=color:#a71d5d;font-weight:700>class </span><span style=color:#0086b3>LCG</span><span>:
</span><span>    lcg_m </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>99470802153294399618017402366955844921383026244330401927153381788409087864090915476376417542092444282980114205684938728578475547514901286372129860608477
</span><span>    lcg_c </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>3910539794193409979886870049869456815685040868312878537393070815966881265118275755165613835833103526090552456472867019296386475520134783987251699999776365
</span><span>    lcg_n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>8311271273016946265169120092240227882013893131681882078655426814178920681968884651437107918874328518499850252591810409558783335118823692585959490215446923
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#62a35c;font-weight:700>__init__</span><span>(self, lcg_s):
</span><span>        self.state </span><span style=color:#a71d5d;font-weight:700>= </span><span>lcg_s
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>next</span><span>(self):
</span><span>        self.state </span><span style=color:#a71d5d;font-weight:700>= </span><span>(self.state </span><span style=color:#a71d5d;font-weight:700>* </span><span>self.lcg_m </span><span style=color:#a71d5d;font-weight:700>+ </span><span>self.lcg_c) </span><span style=color:#a71d5d;font-weight:700>% </span><span>self.lcg_n
</span><span>        </span><span style=color:#a71d5d;font-weight:700>return </span><span>self.state
</span><span>
</span><span style=color:#a71d5d;font-weight:700>if </span><span>__name__ </span><span style=color:#a71d5d;font-weight:700>== </span><span style=color:#183691>'__main__'</span><span>:
</span><span>
</span><span>    it </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>8
</span><span>    bits </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>512
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Find prime value of specified bits a specified amount of times
</span><span>    seed </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
</span><span>    lcg </span><span style=color:#a71d5d;font-weight:700>= </span><span>LCG(seed)
</span><span>    primes_arr </span><span style=color:#a71d5d;font-weight:700>= </span><span>[]
</span><span>    
</span><span>    dump </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>True
</span><span>    items </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>0
</span><span>
</span><span>    primes_n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>while </span><span style=color:#0086b3>True</span><span>:
</span><span>        </span><span style=color:#a71d5d;font-weight:700>for </span><span>i </span><span style=color:#a71d5d;font-weight:700>in </span><span style=color:#62a35c>range</span><span>(it):
</span><span>            </span><span style=color:#a71d5d;font-weight:700>while </span><span style=color:#0086b3>True</span><span>:
</span><span>                prime_candidate </span><span style=color:#a71d5d;font-weight:700>= </span><span>lcg.next()
</span><span>                </span><span style=color:#a71d5d;font-weight:700>if not </span><span>isPrime(prime_candidate):
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>                </span><span style=color:#a71d5d;font-weight:700>elif </span><span>prime_candidate.bit_length() </span><span style=color:#a71d5d;font-weight:700>!= </span><span>bits:
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>                </span><span style=color:#a71d5d;font-weight:700>else</span><span>:
</span><span>                    primes_n </span><span style=color:#a71d5d;font-weight:700>*= </span><span>prime_candidate
</span><span>                    primes_arr.append(prime_candidate)
</span><span>                    </span><span style=color:#a71d5d;font-weight:700>break
</span><span>        
</span><span>        </span><span style=color:#969896;font-style:italic># Check bit length
</span><span>        </span><span style=color:#a71d5d;font-weight:700>if </span><span>primes_n.bit_length() </span><span style=color:#a71d5d;font-weight:700>> </span><span style=color:#0086b3>4096</span><span>:
</span><span>            </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#183691>"bit length"</span><span>, primes_n.bit_length())
</span><span>            primes_arr.clear()
</span><span>            primes_n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>            </span><span style=color:#a71d5d;font-weight:700>continue
</span><span>        </span><span style=color:#a71d5d;font-weight:700>else</span><span>:
</span><span>            </span><span style=color:#a71d5d;font-weight:700>break
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Create public key 'n'
</span><span>    n </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>for </span><span>j </span><span style=color:#a71d5d;font-weight:700>in </span><span>primes_arr:
</span><span>        n </span><span style=color:#a71d5d;font-weight:700>*= </span><span>j
</span><span>    </span><span style=color:#969896;font-style:italic># Calculate totient 'Phi(n)'
</span><span>    phi </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>1
</span><span>    </span><span style=color:#a71d5d;font-weight:700>for </span><span>k </span><span style=color:#a71d5d;font-weight:700>in </span><span>primes_arr:
</span><span>        phi </span><span style=color:#a71d5d;font-weight:700>*= </span><span>(k </span><span style=color:#a71d5d;font-weight:700>- </span><span style=color:#0086b3>1</span><span>)
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Read the public key from the "public.pem" file
</span><span>    </span><span style=color:#a71d5d;font-weight:700>with </span><span style=color:#62a35c>open</span><span>(</span><span style=color:#183691>"public.pem"</span><span>, </span><span style=color:#183691>"rb"</span><span>) </span><span style=color:#a71d5d;font-weight:700>as </span><span>pub_file:
</span><span>        rsa_key </span><span style=color:#a71d5d;font-weight:700>= </span><span>RSA.import_key(pub_file.read())
</span><span>    </span><span style=color:#969896;font-style:italic># Extract the values of e and n from the RSA key
</span><span>    e </span><span style=color:#a71d5d;font-weight:700>= </span><span>rsa_key.e
</span><span>    n </span><span style=color:#a71d5d;font-weight:700>= </span><span>rsa_key.n
</span><span>
</span><span>    </span><span style=color:#969896;font-style:italic># Calculate private key 'd'
</span><span>    d </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>pow</span><span>(e, </span><span style=color:#a71d5d;font-weight:700>-</span><span style=color:#0086b3>1</span><span>, phi)
</span><span>
</span><span>    </span><span style=color:#a71d5d;font-weight:700>with </span><span style=color:#62a35c>open</span><span>(</span><span style=color:#183691>"flag.txt"</span><span>, </span><span style=color:#183691>"rb"</span><span>) </span><span style=color:#a71d5d;font-weight:700>as </span><span>flag_file:
</span><span>        flag_data </span><span style=color:#a71d5d;font-weight:700>= </span><span>flag_file.read()
</span><span>
</span><span>    _enc </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>int</span><span>.from_bytes(flag_data, </span><span style=color:#183691>"little"</span><span>)
</span><span>   
</span><span>    </span><span style=color:#969896;font-style:italic># decrypt flag
</span><span>    flag </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>pow</span><span>(_enc,d,n)
</span><span>    </span><span style=color:#62a35c>print</span><span>(long_to_bytes(flag))
</span><span>
</span><span style=color:#969896;font-style:italic># b'CTF{C0nGr@tz_RiV35t_5h4MiR_nD_Ad13MaN_W0ulD_b_h@pPy}'
</span><span>
</span></code></pre><blockquote><p><code>Flag : CTF{C0nGr@tz_RiV35t_5h4MiR_nD_Ad13MaN_W0ulD_b_h@pPy}</code></blockquote><hr><p>Reference : <a href=https://teamrocketist.github.io/2019/03/31/Crypto-VolgaCtf2019-LG/ target=_blank>https://teamrocketist.github.io/2019/03/31/Crypto-VolgaCtf2019-LG/</a></section></article></main></div>